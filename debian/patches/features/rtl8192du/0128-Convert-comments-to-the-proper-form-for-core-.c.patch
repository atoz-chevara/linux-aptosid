From 14262ad20dff0235237305c02d885b5e8feb2e53 Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Sun, 5 May 2013 22:37:12 -0500
Subject: [PATCH 128/390] Convert // comments to the proper form for core/*.c

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 core/rtw_io.c        |   33 +-
 core/rtw_ioctl_set.c |  144 ++-
 core/rtw_iol.c       |   14 +-
 core/rtw_mlme.c      |  447 ++++----
 core/rtw_mlme_ext.c  | 3120 ++++++++++++++++++++++++--------------------------
 core/rtw_p2p.c       | 1588 +++++++++++++------------
 core/rtw_pwrctrl.c   |  127 +-
 core/rtw_recv.c      |  571 +++++----
 core/rtw_security.c  |  178 ++-
 core/rtw_sreset.c    |    2 +-
 core/rtw_sta_mgt.c   |   58 +-
 core/rtw_tdls.c      |  547 +++++----
 core/rtw_wlan_util.c |  225 ++--
 core/rtw_xmit.c      |  434 ++++---
 14 files changed, 3582 insertions(+), 3906 deletions(-)

--- a/drivers/staging/rtl8192du/core/rtw_io.c
+++ b/drivers/staging/rtl8192du/core/rtw_io.c
@@ -50,7 +50,7 @@ jackson@realtek.com.tw
 u8 _rtw_read8(struct rtw_adapter *adapter, u32 addr)
 {
 	u8 r_val;
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u8 (*_read8)(struct intf_hdl *pintfhdl, u32 addr);
@@ -65,7 +65,7 @@ u8 _rtw_read8(struct rtw_adapter *adapte
 u16 _rtw_read16(struct rtw_adapter *adapter, u32 addr)
 {
 	u16 r_val;
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u16	(*_read16)(struct intf_hdl *pintfhdl, u32 addr);
@@ -80,7 +80,7 @@ u16 _rtw_read16(struct rtw_adapter *adap
 u32 _rtw_read32(struct rtw_adapter *adapter, u32 addr)
 {
 	u32 r_val;
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u32	(*_read32)(struct intf_hdl *pintfhdl, u32 addr);
@@ -94,7 +94,7 @@ u32 _rtw_read32(struct rtw_adapter *adap
 
 int _rtw_write8(struct rtw_adapter *adapter, u32 addr, u8 val)
 {
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write8)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
@@ -109,7 +109,7 @@ int _rtw_write8(struct rtw_adapter *adap
 }
 int _rtw_write16(struct rtw_adapter *adapter, u32 addr, u16 val)
 {
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write16)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
@@ -124,7 +124,7 @@ int _rtw_write16(struct rtw_adapter *ada
 }
 int _rtw_write32(struct rtw_adapter *adapter, u32 addr, u32 val)
 {
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write32)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
@@ -140,7 +140,7 @@ int _rtw_write32(struct rtw_adapter *ada
 
 int _rtw_writeN(struct rtw_adapter *adapter, u32 addr ,u32 length , u8 *pdata)
 {
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
         struct	intf_hdl	*pintfhdl = (struct intf_hdl*)(&(pio_priv->intf));
 	int (*_writeN)(struct intf_hdl *pintfhdl, u32 addr,u32 length, u8 *pdata);
@@ -155,7 +155,7 @@ int _rtw_writeN(struct rtw_adapter *adap
 }
 int _rtw_write8_async(struct rtw_adapter *adapter, u32 addr, u8 val)
 {
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write8_async)(struct intf_hdl *pintfhdl, u32 addr, u8 val);
@@ -170,7 +170,7 @@ int _rtw_write8_async(struct rtw_adapter
 }
 int _rtw_write16_async(struct rtw_adapter *adapter, u32 addr, u16 val)
 {
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write16_async)(struct intf_hdl *pintfhdl, u32 addr, u16 val);
@@ -185,7 +185,7 @@ int _rtw_write16_async(struct rtw_adapte
 }
 int _rtw_write32_async(struct rtw_adapter *adapter, u32 addr, u32 val)
 {
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	int (*_write32_async)(struct intf_hdl *pintfhdl, u32 addr, u32 val);
@@ -201,7 +201,7 @@ int _rtw_write32_async(struct rtw_adapte
 void _rtw_read_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
 {
 	void (*_read_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 
@@ -223,7 +223,7 @@ void _rtw_read_mem(struct rtw_adapter *a
 void _rtw_write_mem(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
 {
 	void (*_write_mem)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 
@@ -239,7 +239,7 @@ void _rtw_write_mem(struct rtw_adapter *
 void _rtw_read_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
 {
 	u32 (*_read_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
+	/* struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue; */
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 
@@ -273,7 +273,6 @@ void _rtw_read_port_cancel(struct rtw_ad
 u32 _rtw_write_port(struct rtw_adapter *adapter, u32 addr, u32 cnt, u8 *pmem)
 {
 	u32 (*_write_port)(struct intf_hdl *pintfhdl, u32 addr, u32 cnt, u8 *pmem);
-	//struct	io_queue	*pio_queue = (struct io_queue *)adapter->pio_queue;
 	struct io_priv *pio_priv = &adapter->iopriv;
 	struct	intf_hdl		*pintfhdl = &(pio_priv->intf);
 	u32 ret = _SUCCESS;
@@ -338,12 +337,12 @@ int rtw_init_io_priv(struct rtw_adapter
 #ifdef DBG_IO
 
 u16 read_sniff_ranges[][2] = {
-	//{0x550, 0x551},
+	/* 0x550, 0x551}, */
 };
 
 u16 write_sniff_ranges[][2] = {
-	//{0x550, 0x551},
-	//{0x4c, 0x4c},
+	/* 0x550, 0x551}, */
+	/* 0x4c, 0x4c}, */
 };
 
 int read_sniff_num = sizeof(read_sniff_ranges)/sizeof(u16)/2;
--- a/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
+++ b/drivers/staging/rtl8192du/core/rtw_ioctl_set.c
@@ -52,7 +52,7 @@ _func_enter_;
 
 	for (i = 0; i < ssid->SsidLength; i++)
 	{
-		//wifi, printable ascii code must be supported
+		/* wifi, printable ascii code must be supported */
 		if (!((ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e))) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));
 			ret= false;
@@ -97,15 +97,15 @@ _func_enter_;
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
-		//when set_ssid/set_bssid for rtw_do_join(), but scanning queue is empty
-		//we try to issue sitesurvey firstly
+		/* when set_ssid/set_bssid for rtw_do_join(), but scanning queue is empty */
+		/* we try to issue sitesurvey firstly */
 
 		if (pmlmepriv->LinkDetectInfo.bBusyTraffic ==false
 			|| rtw_to_roaming(padapter) > 0
 		)
 		{
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_do_join(): site survey if scanned_queue is empty\n."));
-			// submit site_survey_cmd
+			/*  submit site_survey_cmd */
 			if (_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0))) {
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_do_join(): site survey return error\n."));
 			}
@@ -122,7 +122,7 @@ _func_enter_;
 			pmlmepriv->to_join = false;
 			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 		}
-		else if (ret == 2)//there is no need to wait for join
+		else if (ret == 2)/* there is no need to wait for join */
 		{
 			ret = _SUCCESS;
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
@@ -132,9 +132,9 @@ _func_enter_;
 		{
 			if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true)
 			{
-				// submit createbss_cmd to change to a ADHOC_MASTER
+				/*  submit createbss_cmd to change to a ADHOC_MASTER */
 
-				//pmlmepriv->lock has been acquired by caller...
+				/* pmlmepriv->lock has been acquired by caller... */
 				struct wlan_bssid_ex    *pdev_network = &(padapter->registrypriv.dev_network);
 
 				pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
@@ -160,11 +160,11 @@ _func_enter_;
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("***Error=> rtw_select_and_join_from_scanned_queue FAIL under STA_Mode***\n "));
 
 			} else {
-				// can't associate ; reset under-linking
+				/*  can't associate ; reset under-linking */
 				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
-				//when set_ssid/set_bssid for rtw_do_join(), but there are no desired bss in scanning queue
-				//we try to issue sitesurvey firstly
+				/* when set_ssid/set_bssid for rtw_do_join(), but there are no desired bss in scanning queue */
+				/* we try to issue sitesurvey firstly */
 				if (pmlmepriv->LinkDetectInfo.bBusyTraffic==false ||
 				    rtw_to_roaming(padapter) > 0) {
 					if (_SUCCESS!=(ret=rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)))
@@ -222,7 +222,7 @@ _func_enter_;
 		if (_rtw_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN) == true)
 		{
 			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)
-				goto release_mlme_lock;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
+				goto release_mlme_lock;/* it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again. */
 		} else {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("Set BSSID not the same bssid\n"));
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("set_bssid=%pM\n", bssid));
@@ -243,7 +243,7 @@ _func_enter_;
 	}
 
 handle_tkip_countermeasure:
-	//should we add something here...?
+	/* should we add something here...? */
 
 	if (padapter->securitypriv.btkip_countermeasure == true) {
 		cur_time = rtw_get_current_time();
@@ -328,7 +328,7 @@ _func_enter_;
 
 				if (rtw_is_same_ibss(padapter, pnetwork) == false)
 				{
-					//if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again
+					/* if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again */
 					rtw_disassoc_cmd(padapter, 0, true);
 
 					if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
@@ -343,7 +343,7 @@ _func_enter_;
 				}
 				else
 				{
-					goto release_mlme_lock;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
+					goto release_mlme_lock;/* it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again. */
 				}
 			}
 #ifdef CONFIG_LPS
@@ -418,11 +418,6 @@ _func_exit_;
 	return status;
 }
 
-/*
-rtw_set_802_11_infrastructure_mode(~)
-	### NOTE:#### (!!!!)
-	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock and scanned_queue->lock in sequence
-*/
 u8 rtw_set_802_11_infrastructure_mode(struct rtw_adapter* padapter,
 	enum NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
 {
@@ -439,10 +434,9 @@ _func_enter_;
 	if (*pold_state != networktype)
 	{
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,(" change mode!"));
-		//DBG_8192D("change mode, old_mode=%d, new_mode=%d, fw_state=0x%x\n", *pold_state, networktype, get_fwstate(pmlmepriv));
 
 		if (*pold_state==NDIS802_11APMODE) {
-			//change to other mode from Ndis802_11APMode
+			/* change to other mode from Ndis802_11APMode */
 			cur_network->join_res = -1;
 
 #ifdef CONFIG_NATIVEAP_MLME
@@ -461,7 +455,7 @@ _func_enter_;
 	       {
 			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 			{
-				rtw_indicate_disconnect(padapter); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not
+				rtw_indicate_disconnect(padapter); /* will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not */
 			}
 	       }
 
@@ -483,7 +477,7 @@ _func_enter_;
 				set_fwstate(pmlmepriv, WIFI_AP_STATE);
 #ifdef CONFIG_NATIVEAP_MLME
 				start_ap_mode(padapter);
-				//rtw_indicate_connect(padapter);
+				/* rtw_indicate_connect(padapter); */
 #endif
 
 				break;
@@ -493,10 +487,10 @@ _func_enter_;
 				break;
 		}
 
-		//SecClearAllKeys(adapter);
+		/* SecClearAllKeys(adapter); */
 
-		//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("set_infrastructure: fw_state:%x after changing mode\n",
-		//									get_fwstate(pmlmepriv)));
+		/* RT_TRACE(COMP_OID_SET, DBG_LOUD, ("set_infrastructure: fw_state:%x after changing mode\n", */
+		/* 									get_fwstate(pmlmepriv))); */
 
 	}
 
@@ -552,7 +546,7 @@ _func_enter_;
 	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true) ||
 		(pmlmepriv->LinkDetectInfo.bBusyTraffic == true))
 	{
-		// Scan or linking is in progress, do nothing.
+		/*  Scan or linking is in progress, do nothing. */
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("rtw_set_802_11_bssid_list_scan fail since fw_state = %x\n", get_fwstate(pmlmepriv)));
 		res = true;
 
@@ -619,8 +613,8 @@ u8 rtw_set_802_11_add_wep(struct rtw_ada
 
 _func_enter_;
 
-	bdefaultkey=(wep->KeyIndex & 0x40000000) > 0 ? false : true;   //for ???
-	btransmitkey= (wep->KeyIndex & 0x80000000) > 0 ? true  : false;	//for ???
+	bdefaultkey=(wep->KeyIndex & 0x40000000) > 0 ? false : true;   /* for ??? */
+	btransmitkey= (wep->KeyIndex & 0x80000000) > 0 ? true  : false;	/* for ??? */
 	keyid=wep->KeyIndex & 0x3fffffff;
 
 	if (keyid>4)
@@ -716,14 +710,14 @@ u8 rtw_set_802_11_add_key(struct rtw_ada
 	u8 * pbssid;
 	struct sta_info *stainfo;
 	u8	bgroup = false;
-	u8	bgrouptkey = false;//can be remove later
+	u8	bgrouptkey = false;/* can be remove later */
 	u8	ret=_SUCCESS;
 
 _func_enter_;
 
 	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)) {
-		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination,
-		// it must fail the request and return NDIS_STATUS_INVALID_DATA.
+		/*  It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination, */
+		/*  it must fail the request and return NDIS_STATUS_INVALID_DATA. */
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key: ((key->KeyIndex & 0x80000000) == 0)[=%d] ",(int)(key->KeyIndex & 0x80000000) == 0));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key:((key->KeyIndex & 0x40000000) > 0)[=%d]" , (int)(key->KeyIndex & 0x40000000) > 0));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_info_,("rtw_set_802_11_add_key: key->KeyIndex=%d\n" ,(int)key->KeyIndex));
@@ -733,7 +727,7 @@ _func_enter_;
 
 	if (key->KeyIndex & 0x40000000)
 	{
-		// Pairwise key
+		/*  Pairwise key */
 
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Pairwise key +++++\n"));
 
@@ -758,23 +752,23 @@ _func_enter_;
 		}
 
 		if (key->KeyIndex & 0x000000FF) {
-			// The key index is specified in the lower 8 bits by values of zero to 255.
-			// The key index should be set to zero for a Pairwise key, and the driver should fail with
-			// NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero
+			/*  The key index is specified in the lower 8 bits by values of zero to 255. */
+			/*  The key index should be set to zero for a Pairwise key, and the driver should fail with */
+			/*  NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero */
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" key->KeyIndex & 0x000000FF.\n"));
 			ret= _FAIL;
 			goto exit;
 		}
 
-		// check BSSID
+		/*  check BSSID */
 		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("MacAddr_isBcst(key->BSSID)\n"));
 			ret= false;
 			goto exit;
 		}
 
-		// Check key length for TKIP.
-		//if (encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32)
+		/*  Check key length for TKIP. */
+		/* if (encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32) */
 		if ((encryptionalgo== _TKIP_)&& (key->KeyLength != 32)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("TKIP KeyLength:0x%x != 32\n", key->KeyLength));
 			ret=_FAIL;
@@ -782,9 +776,9 @@ _func_enter_;
 
 		}
 
-		// Check key length for AES.
+		/*  Check key length for AES. */
 		if ((encryptionalgo== _AES_)&& (key->KeyLength != 16)) {
-			// For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case.
+			/*  For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case. */
 			if (key->KeyLength == 32) {
 				key->KeyLength = 16;
 			} else {
@@ -793,7 +787,7 @@ _func_enter_;
 			}
 		}
 
-		// Check key length for WEP. For NDTEST, 2005.01.27, by rcnjko.
+		/*  Check key length for WEP. For NDTEST, 2005.01.27, by rcnjko. */
 		if (	(encryptionalgo== _WEP40_|| encryptionalgo== _WEP104_) && (key->KeyLength != 5 || key->KeyLength != 13)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("WEP KeyLength:0x%x != 5 or 13\n", key->KeyLength));
 			ret=_FAIL;
@@ -802,7 +796,7 @@ _func_enter_;
 
 		bgroup = false;
 
-		// Check the pairwise key. Added by Annie, 2005-07-06.
+		/*  Check the pairwise key. Added by Annie, 2005-07-06. */
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("[Pairwise Key set]\n"));
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("------------------------------------------\n"));
@@ -813,11 +807,11 @@ _func_enter_;
 	}
 	else
 	{
-		// Group key - KeyIndex(BIT30==0)
+		/*  Group key - KeyIndex(BIT30==0) */
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ Group key +++++\n"));
 
 
-		// when add wep key through add key and didn't assigned encryption type before
+		/*  when add wep key through add key and didn't assigned encryption type before */
 		if ((padapter->securitypriv.ndisauthtype<=3)&&(padapter->securitypriv.dot118021XGrpPrivacy==0))
 		{
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("keylen=%d(Adapter->securitypriv.dot11PrivacyAlgrthm=%x )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n", key->KeyLength,padapter->securitypriv.dot11PrivacyAlgrthm,padapter->securitypriv.dot118021XGrpPrivacy));
@@ -856,27 +850,27 @@ _func_enter_;
 			goto exit;
 		}
 
-		// Check key length for TKIP
+		/*  Check key length for TKIP */
 		if ((encryptionalgo== _TKIP_) && (key->KeyLength != 32)) {
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,(" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));
 			ret= _FAIL;
 			goto exit;
 
 		} else if (encryptionalgo== _AES_ && (key->KeyLength != 16 && key->KeyLength != 32)) {
-			// Check key length for AES
-			// For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko.
+			/*  Check key length for AES */
+			/*  For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko. */
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n", key->KeyLength));
 			ret= _FAIL;
 			goto exit;
 		}
 
-		// Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03.
+		/*  Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03. */
 		if ((encryptionalgo==  _AES_) && (key->KeyLength == 32)) {
 			key->KeyLength = 16;
 			RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("AES key length changed: %u\n", key->KeyLength));
 		}
 
-		if (key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
+		if (key->KeyIndex & 0x8000000) {/* error ??? 0x8000_0000 */
 			bgrouptkey = true;
 		}
 
@@ -896,7 +890,7 @@ _func_enter_;
 
 	}
 
-	// If WEP encryption algorithm, just call rtw_set_802_11_add_wep().
+	/*  If WEP encryption algorithm, just call rtw_set_802_11_add_wep(). */
 	if ((padapter->securitypriv.dot11AuthAlgrthm !=dot11AuthAlgrthm_8021X)&&(encryptionalgo== _WEP40_  || encryptionalgo== _WEP104_))
 	{
 		u8 ret;
@@ -926,7 +920,7 @@ _func_enter_;
 	}
 
 	if (key->KeyIndex & 0x20000000) {
-		// SetRSC
+		/*  SetRSC */
 		RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));
 		if (bgroup == true)
 		{
@@ -941,9 +935,9 @@ _func_enter_;
 
 	}
 
-	// Indicate this key idx is used for TX
-	// Save the key in KeyMaterial
-	if (bgroup == true) // Group transmit key
+	/*  Indicate this key idx is used for TX */
+	/*  Save the key in KeyMaterial */
+	if (bgroup == true) /*  Group transmit key */
 	{
 		int res;
 
@@ -988,7 +982,7 @@ _func_enter_;
 
 		}
 
-		//set group key by index
+		/* set group key by index */
 		memcpy(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial, key->KeyLength);
 
 		key->KeyIndex=key->KeyIndex & 0x03;
@@ -1007,7 +1001,7 @@ _func_enter_;
 		goto exit;
 
 	}
-	else // Pairwise Key
+	else /*  Pairwise Key */
 	{
 		u8 res;
 
@@ -1016,7 +1010,7 @@ _func_enter_;
 
 		if (stainfo!=NULL)
 		{
-			memset(&stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
+			memset(&stainfo->dot118021x_UncstKey, 0, 16);/*  clear keybuffer */
 
 			memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
 
@@ -1024,11 +1018,11 @@ _func_enter_;
 			{
 				padapter->securitypriv.busetkipkey=false;
 
-				//_set_timer(&padapter->securitypriv.tkip_timer, 50);
+				/* _set_timer(&padapter->securitypriv.tkip_timer, 50); */
 
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n ==========_set_timer\n"));
 
-				// if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255]
+				/*  if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255] */
 				if ((key->KeyIndex & 0x10000000)) {
 					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
 					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);
@@ -1045,8 +1039,8 @@ _func_enter_;
 			}
 
 
-			//Set key to CAM through H2C command
-			if (bgrouptkey)//never go to here
+			/* Set key to CAM through H2C command */
+			if (bgrouptkey)/* never go to here */
 			{
 				res=rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, false);
 				RT_TRACE(_module_rtl871x_ioctl_set_c_,_drv_err_,("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));
@@ -1087,23 +1081,23 @@ _func_enter_;
 
 	if (bgroup == true) {
 		encryptionalgo= padapter->securitypriv.dot118021XGrpPrivacy;
-		// clear group key by index
-		//NdisZeroMemory(Adapter->MgntInfo.SecurityInfo.KeyBuf[keyIndex], MAX_WEP_KEY_LEN);
-		//Adapter->MgntInfo.SecurityInfo.KeyLen[keyIndex] = 0;
+		/*  clear group key by index */
+		/* NdisZeroMemory(Adapter->MgntInfo.SecurityInfo.KeyBuf[keyIndex], MAX_WEP_KEY_LEN); */
+		/* Adapter->MgntInfo.SecurityInfo.KeyLen[keyIndex] = 0; */
 
 		memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex], 0, 16);
 
-		//! \todo Send a H2C Command to Firmware for removing this Key in CAM Entry.
+		/*  \todo Send a H2C Command to Firmware for removing this Key in CAM Entry. */
 	} else {
 		pbssid=get_bssid(&padapter->mlmepriv);
 		stainfo=rtw_get_stainfo(&padapter->stapriv , pbssid);
 		if (stainfo !=NULL) {
 			encryptionalgo=stainfo->dot118021XPrivacy;
 
-		// clear key by BSSID
+		/*  clear key by BSSID */
 		memset(&stainfo->dot118021x_UncstKey, 0, 16);
 
-		//! \todo Send a H2C Command to Firmware for disable this Key in CAM Entry.
+		/*  \todo Send a H2C Command to Firmware for disable this Key in CAM Entry. */
 
 		}
 		else {
@@ -1164,11 +1158,11 @@ u16 rtw_get_cur_max_rate(struct rtw_adap
 
 			memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
 
-			//bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
-			//cur_bwmod is updated by beacon, pmlmeinfo is updated by association response
+			/* bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0; */
+			/* cur_bwmod is updated by beacon, pmlmeinfo is updated by association response */
 			bw_40MHz = (pmlmeext->cur_bwmode && (HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH & pmlmeinfo->HT_info.infos[0])) ? 1:0;
 
-			//short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+			/* short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0; */
 			short_GI_20 = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info&IEEE80211_HT_CAP_SGI_20) ? 1:0;
 			short_GI_40 = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info&IEEE80211_HT_CAP_SGI_40) ? 1:0;
 
@@ -1183,7 +1177,7 @@ u16 rtw_get_cur_max_rate(struct rtw_adap
 		}
 	}
 	else
-#endif //CONFIG_80211N_HT
+#endif /* CONFIG_80211N_HT */
 	{
 		while ((pcur_bss->SupportedRates[i]!=0) && (pcur_bss->SupportedRates[i]!=0xFF))
 		{
@@ -1228,7 +1222,7 @@ int rtw_set_channel_plan(struct rtw_adap
 	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
 
-	//handle by cmd_thread to sync with scan operation
+	/* handle by cmd_thread to sync with scan operation */
 	return rtw_set_chplan_cmd(adapter, channel_plan, 1);
 }
 
@@ -1245,8 +1239,8 @@ int rtw_set_country(struct rtw_adapter *
 
 	DBG_8192D("%s country_code:%s\n", __func__, country_code);
 
-	//TODO: should have a table to match country code and RT_CHANNEL_DOMAIN
-	//TODO: should consider 2-character and 3-character country code
+	/* TODO: should have a table to match country code and RT_CHANNEL_DOMAIN */
+	/* TODO: should consider 2-character and 3-character country code */
 	if (0 == strcmp(country_code, "US"))
 		channel_plan = RT_CHANNEL_DOMAIN_FCC;
 	else if (0 == strcmp(country_code, "EU"))
--- a/drivers/staging/rtl8192du/core/rtw_iol.c
+++ b/drivers/staging/rtl8192du/core/rtw_iol.c
@@ -60,11 +60,11 @@ int rtw_IOL_append_cmds(struct xmit_fram
 	u16 buf_offset;
 	u32 ori_len;
 
-//Todo: bulkout without this offset
+/* Todo: bulkout without this offset */
 	buf_offset = TXDESC_OFFSET;
 	ori_len = buf_offset+pattrib->pktlen;
 
-	//check if the io_buf can accommodate new cmds
+	/* check if the io_buf can accommodate new cmds */
 	if (ori_len + cmd_len + 8 > MAX_XMITBUF_SZ) {
 		DBG_871X("%s %u is large than MAX_XMITBUF_SZ:%u, can't accommodate new cmds\n", __func__
 			, ori_len + cmd_len + 8, MAX_XMITBUF_SZ);
@@ -149,7 +149,7 @@ int rtw_IOL_append_DELAY_US_cmd(struct x
 
 	RTW_PUT_BE32((u8*)&cmd.value, (u32)us);
 
-	//DBG_871X("%s %u\n", __func__, us);
+	/* DBG_871X("%s %u\n", __func__, us); */
 
 	return rtw_IOL_append_cmds(xmit_frame, (u8*)&cmd, 8);
 }
@@ -160,7 +160,7 @@ int rtw_IOL_append_DELAY_MS_cmd(struct x
 
 	RTW_PUT_BE32((u8*)&cmd.value, (u32)ms);
 
-	//DBG_871X("%s %u\n", __func__, ms);
+	/* DBG_871X("%s %u\n", __func__, ms); */
 
 	return rtw_IOL_append_cmds(xmit_frame, (u8*)&cmd, 8);
 }
@@ -172,11 +172,11 @@ int rtw_IOL_append_END_cmd(struct xmit_f
 	u32 ori_len;
 	IOL_CMD end_cmd = {0x0, IOL_CMD_END, 0x0, 0x0};
 
-//Todo: bulkout without this offset
+/* Todo: bulkout without this offset */
 	buf_offset = TXDESC_OFFSET;
 	ori_len = buf_offset+pattrib->pktlen;
 
-	//check if the io_buf can accommodate new cmds
+	/* check if the io_buf can accommodate new cmds */
 	if (ori_len + 8 > MAX_XMITBUF_SZ) {
 		DBG_871X("%s %u is large than MAX_XMITBUF_SZ:%u, can't accommodate end cmd\n", __func__
 			, ori_len + 8, MAX_XMITBUF_SZ);
@@ -223,4 +223,4 @@ bool rtw_IOL_applied(ADAPTER *adapter)
 	return false;
 }
 
-#endif //CONFIG_IOL
+#endif /* CONFIG_IOL */
--- a/drivers/staging/rtl8192du/core/rtw_mlme.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme.c
@@ -38,9 +38,9 @@ extern u8 rtw_do_join(struct rtw_adapter
 #ifdef CONFIG_DISABLE_MCS13TO15
 extern unsigned char	MCS_rate_2R_MCS13TO15_OFF[16];
 extern unsigned char	MCS_rate_2R[16];
-#else //CONFIG_DISABLE_MCS13TO15
+#else /* CONFIG_DISABLE_MCS13TO15 */
 extern unsigned char	MCS_rate_2R[16];
-#endif //CONFIG_DISABLE_MCS13TO15
+#endif /* CONFIG_DISABLE_MCS13TO15 */
 extern unsigned char	MCS_rate_1R[16];
 
 int	_rtw_init_mlme_priv (struct rtw_adapter* padapter)
@@ -53,15 +53,15 @@ int	_rtw_init_mlme_priv (struct rtw_adap
 
 _func_enter_;
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
-	//memset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv));
+	/*  We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc(). */
+	/* memset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv)); */
 
 	pmlmepriv->nic_hdl = (u8 *)padapter;
 
 	pmlmepriv->pscanned = NULL;
 	pmlmepriv->fw_state = 0;
 	pmlmepriv->cur_network.network.InfrastructureMode = NDIS802_11AUTOUNK;
-	pmlmepriv->scan_mode=SCAN_ACTIVE;// 1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff)
+	pmlmepriv->scan_mode=SCAN_ACTIVE;/*  1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff) */
 
 	_rtw_spinlock_init(&(pmlmepriv->lock));
 	_rtw_init_queue(&(pmlmepriv->free_bss_pool));
@@ -90,7 +90,7 @@ _func_enter_;
 		pnetwork++;
 	}
 
-	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
 
 	rtw_clear_scan_deny(padapter);
 
@@ -207,7 +207,7 @@ _func_exit_;
 	return pnetwork;
 }
 
-struct	wlan_network *_rtw_alloc_network(struct	mlme_priv *pmlmepriv)//(struct __queue *free_queue)
+struct	wlan_network *_rtw_alloc_network(struct	mlme_priv *pmlmepriv)/* struct __queue *free_queue) */
 {
 	struct	wlan_network	*pnetwork;
 	struct __queue *free_queue = &pmlmepriv->free_bss_pool;
@@ -268,7 +268,7 @@ _func_enter_;
 	{
 		delta_time = (curr_time -pnetwork->last_scanned)/HZ;
 
-		if (delta_time < lifetime)// unit:sec
+		if (delta_time < lifetime)/*  unit:sec */
 		{
 			goto exit;
 		}
@@ -316,7 +316,7 @@ _func_exit_;
 /*
 	return the wlan_network with the matching addr
 
-	Shall be calle under atomic context... to avoid possible racing condition...
+	Shall be called under atomic context... to avoid possible racing condition...
 */
 struct wlan_network *_rtw_find_network(struct __queue *scanned_queue, u8 *addr)
 {
@@ -331,7 +331,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	//spin_lock_bh(&scanned_queue->lock);
+	/* spin_lock_bh(&scanned_queue->lock); */
 
 	phead = get_list_head(scanned_queue);
 	plist = get_next(phead);
@@ -349,7 +349,7 @@ _func_enter_;
 	if (plist == phead)
 		pnetwork = NULL;
 
-	//spin_unlock_bh(&scanned_queue->lock);
+	/* spin_unlock_bh(&scanned_queue->lock); */
 
 exit:
 
@@ -414,12 +414,12 @@ void rtw_generate_random_ibss(u8* pibss)
 	u32	curtime = rtw_get_current_time();
 
 _func_enter_;
-	pibss[0] = 0x02;  //in ad-hoc mode bit1 must set to 1
+	pibss[0] = 0x02;  /* in ad-hoc mode bit1 must set to 1 */
 	pibss[1] = 0x11;
 	pibss[2] = 0x87;
-	pibss[3] = (u8)(curtime & 0xff) ;//p[0];
-	pibss[4] = (u8)((curtime>>8) & 0xff) ;//p[1];
-	pibss[5] = (u8)((curtime>>16) & 0xff) ;//p[2];
+	pibss[3] = (u8)(curtime & 0xff) ;/* p[0]; */
+	pibss[4] = (u8)((curtime>>8) & 0xff) ;/* p[1]; */
+	pibss[5] = (u8)((curtime>>16) & 0xff) ;/* p[2]; */
 _func_exit_;
 	return;
 }
@@ -452,11 +452,11 @@ u8 *rtw_get_beacon_interval_from_ie(u8 *
 }
 
 
-int	rtw_init_mlme_priv (struct rtw_adapter *padapter)//(struct	mlme_priv *pmlmepriv)
+int	rtw_init_mlme_priv (struct rtw_adapter *padapter)/* struct	mlme_priv *pmlmepriv) */
 {
 	int	res;
 _func_enter_;
-	res = _rtw_init_mlme_priv(padapter);// (pmlmepriv);
+	res = _rtw_init_mlme_priv(padapter);/*  (pmlmepriv); */
 _func_exit_;
 	return res;
 }
@@ -488,7 +488,7 @@ _func_exit_;
 	return pnetwork;
 }
 
-struct	wlan_network *rtw_alloc_network(struct	mlme_priv *pmlmepriv)//(struct __queue	*free_queue)
+struct	wlan_network *rtw_alloc_network(struct	mlme_priv *pmlmepriv)/* struct __queue	*free_queue) */
 {
 	struct	wlan_network	*pnetwork;
 _func_enter_;
@@ -509,7 +509,7 @@ void rtw_free_network_nolock(struct mlme
 void rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork)
 {
 _func_enter_;
-	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s\n\n" , pnetwork->network.Ssid.Ssid));
+	/* RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s\n\n" , pnetwork->network.Ssid.Ssid)); */
 	_rtw_free_network_nolock(pmlmepriv, pnetwork);
 _func_exit_;
 }
@@ -525,7 +525,7 @@ _func_exit_;
 /*
 	return the wlan_network with the matching addr
 
-	Shall be calle under atomic context... to avoid possible racing condition...
+	Shall be called under atomic context... to avoid possible racing condition...
 */
 struct	wlan_network *rtw_find_network(struct __queue *scanned_queue, u8 *addr)
 {
@@ -560,8 +560,8 @@ int rtw_is_same_ibss(struct rtw_adapter
 inline int is_same_ess(struct wlan_bssid_ex *a, struct wlan_bssid_ex *b);
 inline int is_same_ess(struct wlan_bssid_ex *a, struct wlan_bssid_ex *b)
 {
-	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(%s,%d)(%s,%d)\n",
-	//		a->Ssid.Ssid,a->Ssid.SsidLength,b->Ssid.Ssid,b->Ssid.SsidLength));
+	/* RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(%s,%d)(%s,%d)\n", */
+	/* 		a->Ssid.Ssid,a->Ssid.SsidLength,b->Ssid.Ssid,b->Ssid.SsidLength)); */
 	return (a->Ssid.SsidLength == b->Ssid.SsidLength)
 		&&  _rtw_memcmp(a->Ssid.Ssid, b->Ssid.Ssid, a->Ssid.SsidLength)==true;
 }
@@ -582,7 +582,7 @@ _func_enter_;
 _func_exit_;
 
 	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
-		//	(src->Configuration.DSConfig == dst->Configuration.DSConfig) &&
+		/* 	(src->Configuration.DSConfig == dst->Configuration.DSConfig) && */
 			((_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == true) &&
 			((_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == true) &&
 			((s_cap & WLAN_CAPABILITY_IBSS) ==
@@ -638,7 +638,7 @@ static void update_network(struct wlan_b
 _func_enter_;
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
-	rtw_hal_antdiv_rssi_compared(padapter, dst, src); //this will update src.Rssi, need consider again
+	rtw_hal_antdiv_rssi_compared(padapter, dst, src); /* this will update src.Rssi, need consider again */
 #endif
 
 	#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) && 1
@@ -702,9 +702,9 @@ _func_enter_;
 
 	if ((check_fwstate(pmlmepriv, _FW_LINKED)== true) && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)))
 	{
-		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n");
+		/* RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n"); */
 
-		//if (pmlmepriv->cur_network.network.IELength<= pnetwork->IELength)
+		/* if (pmlmepriv->cur_network.network.IELength<= pnetwork->IELength) */
 		{
 			update_network(&(pmlmepriv->cur_network.network), pnetwork,adapter, true);
 			rtw_update_protection(adapter, (pmlmepriv->cur_network.network.IEs) + sizeof (struct ndis_802_11_fixed_ies),
@@ -765,16 +765,14 @@ _func_enter_;
 	if (rtw_end_of_queue_search(phead,plist)== true) {
 		if (_rtw_queue_empty(&(pmlmepriv->free_bss_pool)) == true) {
 			/* If there are no more slots, expire the oldest */
-			//list_del_init(&oldest->list);
+			/* list_del_init(&oldest->list); */
 			pnetwork = oldest;
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
-			//target->PhyInfo.Optimum_antenna = pHalData->CurAntenna;//optimum_antenna=>For antenna diversity
 			rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(target->PhyInfo.Optimum_antenna));
 #endif
 			memcpy(&(pnetwork->network), target,  get_wlan_bssid_ex_sz(target));
-			//pnetwork->last_scanned = rtw_get_current_time();
-			// variable initialize
+			/*  variable initialize */
 			pnetwork->fixed = false;
 			pnetwork->last_scanned = rtw_get_current_time();
 
@@ -789,7 +787,7 @@ _func_enter_;
 		else {
 			/* Otherwise just pull from the free list */
 
-			pnetwork = rtw_alloc_network(pmlmepriv); // will update scan_time
+			pnetwork = rtw_alloc_network(pmlmepriv); /*  will update scan_time */
 
 			if (pnetwork==NULL) {
 				RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n\n\nsomething wrong here\n\n\n"));
@@ -799,7 +797,7 @@ _func_enter_;
 			bssid_ex_sz = get_wlan_bssid_ex_sz(target);
 			target->Length = bssid_ex_sz;
 #ifdef CONFIG_ANTENNA_DIVERSITY
-			//target->PhyInfo.Optimum_antenna = pHalData->CurAntenna;
+			/* target->PhyInfo.Optimum_antenna = pHalData->CurAntenna; */
 			rtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(target->PhyInfo.Optimum_antenna));
 #endif
 			memcpy(&(pnetwork->network), target, bssid_ex_sz);
@@ -823,7 +821,7 @@ _func_enter_;
 
 		pnetwork->last_scanned = rtw_get_current_time();
 
-		//target.Reserved[0]==1, means that scaned network is a bcn frame.
+		/* target.Reserved[0]==1, means that scaned network is a bcn frame. */
 		if ((pnetwork->network.IELength>target->IELength) && (target->Reserved[0]==1))
 			update_ie = false;
 
@@ -843,7 +841,7 @@ void rtw_add_network(struct rtw_adapter
 
 _func_enter_;
 
-	//spin_lock_bh(&queue->lock);
+	/* spin_lock_bh(&queue->lock); */
 
 	#if defined(CONFIG_P2P) && defined(CONFIG_P2P_REMOVE_GROUP_INFO)
 	rtw_wlan_bssid_ex_remove_p2p_attr(pnetwork, P2P_ATTR_GROUP_INFO);
@@ -853,17 +851,17 @@ _func_enter_;
 
 	rtw_update_scanned_network(adapter, pnetwork);
 
-	//spin_unlock_bh(&queue->lock);
+	/* spin_unlock_bh(&queue->lock); */
 
 _func_exit_;
 }
 
-//select the desired network based on the capability of the (i)bss.
-// check items: (1) security
-//			   (2) network_type
-//			   (3) WMM
-//			   (4) HT
-//                     (5) others
+/* select the desired network based on the capability of the (i)bss. */
+/*  check items: (1) security */
+/* 			   (2) network_type */
+/* 			   (3) WMM */
+/* 			   (4) HT */
+/*                      (5) others */
 int rtw_is_desired_network(struct rtw_adapter *adapter, struct wlan_network *pnetwork);
 int rtw_is_desired_network(struct rtw_adapter *adapter, struct wlan_network *pnetwork)
 {
@@ -872,7 +870,7 @@ int rtw_is_desired_network(struct rtw_ad
 	u32 desired_encmode;
 	u32 privacy;
 
-	//u8 wps_ie[512];
+	/* u8 wps_ie[512]; */
 	uint wps_ielen;
 
 	int bselected = true;
@@ -891,7 +889,7 @@ int rtw_is_desired_network(struct rtw_ad
 			return false;
 		}
 	}
-	if (adapter->registrypriv.wifi_spec == 1) //for  correct flow of 8021X  to do....
+	if (adapter->registrypriv.wifi_spec == 1) /* for  correct flow of 8021X  to do.... */
 	{
 		if ((desired_encmode == NDIS802_11ENCRYPTION_DISABLED) && (privacy != 0))
 	            bselected = false;
@@ -945,7 +943,7 @@ _func_enter_;
 
 	spin_lock_bh(&pmlmepriv->lock);
 
-	// update IBSS_network 's timestamp
+	/*  update IBSS_network 's timestamp */
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) {
 		if (_rtw_memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN)) {
 			struct wlan_network* ibss_wlan = NULL;
@@ -963,7 +961,7 @@ _func_enter_;
 		}
 	}
 
-	// lock pmlmepriv->lock when you accessing network_q
+	/*  lock pmlmepriv->lock when you accessing network_q */
 	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == false)
 	{
 	        if (pnetwork->Ssid.Ssid[0] == 0)
@@ -1040,7 +1038,6 @@ _func_enter_;
 					struct wlan_bssid_ex    *pdev_network = &(adapter->registrypriv.dev_network);
 					u8 *pibss = adapter->registrypriv.dev_network.MacAddress;
 
-					//pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;//because don't set assoc_timer
 					_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 
 					RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("switching to adhoc master\n"));
@@ -1071,7 +1068,7 @@ _func_enter_;
 			{
 			     _set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 			}
-			else if (s_ret == 2)//there is no need to wait for join
+			else if (s_ret == 2)/* there is no need to wait for join */
 			{
 				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 				rtw_indicate_connect(adapter);
@@ -1092,7 +1089,7 @@ _func_enter_;
 							intel_widi_wk_cmd(adapter, INTEL_WIDI_LISTEN_WK, NULL);
 							DBG_8192D("change to widi listen\n");
 						}
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 						rtw_free_assoc_resources(adapter, 1);
 						rtw_indicate_disconnect(adapter);
 					} else {
@@ -1106,7 +1103,7 @@ _func_enter_;
 	}
 
 	indicate_wx_scan_complete_event(adapter);
-	//DBG_8192D("scan complete in %dms\n",rtw_get_passing_time_ms(pmlmepriv->scan_start_time));
+	/* DBG_8192D("scan complete in %dms\n",rtw_get_passing_time_ms(pmlmepriv->scan_start_time)); */
 
 	spin_unlock_bh(&pmlmepriv->lock);
 
@@ -1114,7 +1111,7 @@ _func_enter_;
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
 		p2p_ps_wk_cmd(adapter, P2P_PS_SCAN_DONE, 0);
 	}
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 
 	rtw_os_xmit_schedule(adapter);
 #ifdef CONFIG_CONCURRENT_MODE
@@ -1142,7 +1139,7 @@ _func_enter_;
 
 #ifdef CONFIG_IOCTL_CFG80211
 	rtw_cfg80211_surveydone_event_callback(adapter);
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 _func_exit_;
 }
@@ -1197,7 +1194,7 @@ void rtw_free_assoc_resources(struct rtw
 
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 _func_enter_;
 
 	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_free_assoc_resources\n"));
@@ -1219,7 +1216,7 @@ _func_enter_;
 			spin_lock_bh(&(pstapriv->sta_hash_lock));
 		}
 		else
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 		{
 			spin_lock_bh(&(pstapriv->sta_hash_lock));
 			rtw_free_stainfo(adapter,  psta);
@@ -1257,11 +1254,8 @@ _func_enter_;
 	}
 
 
-	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) && (adapter->stapriv.asoc_sta_count== 1))
-		/*||check_fwstate(pmlmepriv, WIFI_STATION_STATE)*/)
-	{
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) && (adapter->stapriv.asoc_sta_count== 1)))
 		rtw_free_network_nolock(pmlmepriv, pwlan);
-	}
 
 	if (lock_scanned_queue)
 		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
@@ -1316,7 +1310,7 @@ _func_enter_;
 		intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_WK, NULL);
 		DBG_8192D("change to widi listen\n");
 	}
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 
 	rtw_set_scan_deny(padapter, 3000);
 
@@ -1358,12 +1352,12 @@ _func_enter_;
 
 #ifdef CONFIG_P2P_PS
 	p2p_ps_wk_cmd(padapter, P2P_PS_DISABLE, 1);
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 
 #ifdef CONFIG_LPS
 #ifdef CONFIG_WOWLAN
 	if (padapter->pwrctrlpriv.wowlan_mode==false)
-#endif //CONFIG_WOWLAN
+#endif /* CONFIG_WOWLAN */
 	rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 1);
 
 #endif
@@ -1415,7 +1409,7 @@ static struct sta_info *rtw_joinbss_upda
 		psta = rtw_alloc_stainfo(pstapriv, pnetwork->network.MacAddress);
 	}
 
-	if (psta) //update ptarget_sta
+	if (psta) /* update ptarget_sta */
 	{
 		DBG_8192D("%s\n", __func__);
 
@@ -1432,7 +1426,7 @@ static struct sta_info *rtw_joinbss_upda
 
 		psta->raid = networktype_to_raid(pmlmeext->cur_wireless_mode);
 
-		//security related
+		/* security related */
 		if (padapter->securitypriv.dot11AuthAlgrthm== dot11AuthAlgrthm_8021X)
 		{
 			padapter->securitypriv.binstallGrpkey=false;
@@ -1451,9 +1445,9 @@ static struct sta_info *rtw_joinbss_upda
 			memset((u8 *)&psta->dot11rxpn, 0, sizeof (union pn48));
 		}
 
-		//	Commented by Albert 2012/07/21
-		//	When doing the WPS, the wps_ie_len won't equal to 0
-		//	And the Wi-Fi driver shouldn't allow the data packet to be tramsmitted.
+		/* 	Commented by Albert 2012/07/21 */
+		/* 	When doing the WPS, the wps_ie_len won't equal to 0 */
+		/* 	And the Wi-Fi driver shouldn't allow the data packet to be tramsmitted. */
 		if (padapter->securitypriv.wps_ie_len != 0)
 		{
 			psta->ieee8021x_blocked=true;
@@ -1461,12 +1455,12 @@ static struct sta_info *rtw_joinbss_upda
 		}
 
 
-		//for A-MPDU Rx reordering buffer control for bmc_sta & sta_info
-		//if A-MPDU Rx is enabled, reseting  rx_ordering_ctrl wstart_b(indicate_seq) to default value=0xffff
-		//todo: check if AP can send A-MPDU packets
+		/* for A-MPDU Rx reordering buffer control for bmc_sta & sta_info */
+		/* if A-MPDU Rx is enabled, reseting  rx_ordering_ctrl wstart_b(indicate_seq) to default value=0xffff */
+		/* todo: check if AP can send A-MPDU packets */
 		for (i=0; i < 16 ; i++)
 		{
-			//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+			/* preorder_ctrl = &precvpriv->recvreorder_ctrl[i]; */
 			preorder_ctrl = &psta->recvreorder_ctrl[i];
 			preorder_ctrl->enable = false;
 			preorder_ctrl->indicate_seq = 0xffff;
@@ -1475,7 +1469,7 @@ static struct sta_info *rtw_joinbss_upda
 				preorder_ctrl->indicate_seq);
 			#endif
 			preorder_ctrl->wend_b= 0xffff;
-			preorder_ctrl->wsize_b = 64;//max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
+			preorder_ctrl->wsize_b = 64;/* max_ampdu_sz; ex. 32(kbytes) -> wsize_b=32 */
 		}
 
 
@@ -1484,7 +1478,7 @@ static struct sta_info *rtw_joinbss_upda
 		{
 			for (i=0; i < 16 ; i++)
 			{
-				//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+				/* preorder_ctrl = &precvpriv->recvreorder_ctrl[i]; */
 				preorder_ctrl = &bmc_sta->recvreorder_ctrl[i];
 				preorder_ctrl->enable = false;
 				preorder_ctrl->indicate_seq = 0xffff;
@@ -1493,12 +1487,12 @@ static struct sta_info *rtw_joinbss_upda
 					preorder_ctrl->indicate_seq);
 				#endif
 				preorder_ctrl->wend_b= 0xffff;
-				preorder_ctrl->wsize_b = 64;//max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
+				preorder_ctrl->wsize_b = 64;/* max_ampdu_sz; ex. 32(kbytes) -> wsize_b=32 */
 			}
 		}
 
 
-		//misc.
+		/* misc. */
 		update_sta_info(padapter, psta);
 
 	}
@@ -1506,8 +1500,8 @@ static struct sta_info *rtw_joinbss_upda
 	return psta;
 }
 
-//pnetwork : returns from rtw_joinbss_event_callback
-//ptarget_wlan: found from scanned_queue
+/* pnetwork : returns from rtw_joinbss_event_callback */
+/* ptarget_wlan: found from scanned_queue */
 static void rtw_joinbss_update_network(struct rtw_adapter *padapter, struct wlan_network *ptarget_wlan, struct wlan_network  *pnetwork)
 {
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
@@ -1519,7 +1513,7 @@ static void rtw_joinbss_update_network(s
 		,get_fwstate(pmlmepriv), pnetwork->network.MacAddress));
 
 
-	// why not use ptarget_wlan??
+	/*  why not use ptarget_wlan?? */
 	memcpy(&cur_network->network, &pnetwork->network, pnetwork->network.Length);
 
 	cur_network->aid = pnetwork->join_res;
@@ -1530,7 +1524,7 @@ static void rtw_joinbss_update_network(s
 #endif
 	padapter->recvpriv.signal_strength = ptarget_wlan->network.PhyInfo.SignalStrength;
 	padapter->recvpriv.signal_qual = ptarget_wlan->network.PhyInfo.SignalQuality;
-	//the ptarget_wlan->network.Rssi is raw data, we use ptarget_wlan->network.PhyInfo.SignalStrength instead (has scaled)
+	/* the ptarget_wlan->network.Rssi is raw data, we use ptarget_wlan->network.PhyInfo.SignalStrength instead (has scaled) */
 	padapter->recvpriv.rssi = translate_percentage_to_dbm(ptarget_wlan->network.PhyInfo.SignalStrength);
 	#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) && 1
 		DBG_8192D("%s signal_strength:%3u, rssi:%3d, signal_qual:%3u"
@@ -1545,7 +1539,7 @@ static void rtw_joinbss_update_network(s
 	rtw_set_signal_stat_timer(&padapter->recvpriv);
 #endif
 
-	//update fw_state //will clr _FW_UNDER_LINKING here indirectly
+	/* update fw_state will clr _FW_UNDER_LINKING here indirectly */
 	switch (pnetwork->network.InfrastructureMode)
 	{
 		case NDIS802_11INFRA:
@@ -1574,14 +1568,14 @@ static void rtw_joinbss_update_network(s
 
 }
 
-//Notes: the fucntion could be > passive_level (the same context as Rx tasklet)
-//pnetwork : returns from rtw_joinbss_event_callback
-//ptarget_wlan: found from scanned_queue
-//if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist.
-//if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist.
-//if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan !=NULL).
-//
-//#define REJOIN
+/* Notes: the fucntion could be > passive_level (the same context as Rx tasklet) */
+/* pnetwork : returns from rtw_joinbss_event_callback */
+/* ptarget_wlan: found from scanned_queue */
+/* if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist. */
+/* if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist. */
+/* if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan !=NULL). */
+/*  */
+/* define REJOIN */
 void rtw_joinbss_event_prehandle(struct rtw_adapter *adapter, u8 *pbuf)
 {
 	static u8 retry=0;
@@ -1629,7 +1623,7 @@ _func_enter_;
 		retry = 0;
 		if (check_fwstate(pmlmepriv,_FW_UNDER_LINKING))
 		{
-			//s1. find ptarget_wlan
+			/* s1. find ptarget_wlan */
 			if (check_fwstate(pmlmepriv, _FW_LINKED))
 			{
 				if (the_same_macaddr == true)
@@ -1663,7 +1657,7 @@ _func_enter_;
 				}
 			}
 
-			//s2. update cur_network
+			/* s2. update cur_network */
 			if (ptarget_wlan)
 			{
 				rtw_joinbss_update_network(adapter, ptarget_wlan, pnetwork);
@@ -1676,7 +1670,7 @@ _func_enter_;
 			}
 
 
-			//s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode
+			/* s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode */
 			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 			{
 				ptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);
@@ -1688,19 +1682,19 @@ _func_enter_;
 				}
 			}
 
-			//s4. indicate connect
+			/* s4. indicate connect */
 			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 			{
 				rtw_indicate_connect(adapter);
 			}
 			else
 			{
-				//adhoc mode will rtw_indicate_connect when rtw_stassoc_event_callback
+				/* adhoc mode will rtw_indicate_connect when rtw_stassoc_event_callback */
 				RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("adhoc mode, fw_state:%x", get_fwstate(pmlmepriv)));
 			}
 
 
-			//s5. Cancle assoc_timer
+			/* s5. Cancle assoc_timer */
 			_cancel_timer(&pmlmepriv->assoc_timer, &timer_cancelled);
 
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_info_,("Cancle assoc_timer\n"));
@@ -1721,7 +1715,7 @@ _func_enter_;
 		rtw_reset_securitypriv(adapter);
 		_set_timer(&pmlmepriv->assoc_timer, 1);
 
-		//rtw_free_assoc_resources(adapter, 1);
+		/* rtw_free_assoc_resources(adapter, 1); */
 
 		if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == true)
 		{
@@ -1730,7 +1724,7 @@ _func_enter_;
 		}
 
 	}
-	else //if join_res < 0 (join fails), then try again
+	else /* if join_res < 0 (join fails), then try again */
 	{
 		#ifdef REJOIN
 		res = _FAIL;
@@ -1741,11 +1735,11 @@ _func_enter_;
 
 		 if (res == _SUCCESS)
 		{
-			//extend time of assoc_timer
+			/* extend time of assoc_timer */
 			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
 			retry++;
 		}
-		else if (res == 2)//there is no need to wait for join
+		else if (res == 2)/* there is no need to wait for join */
 		{
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 			rtw_indicate_connect(adapter);
@@ -1756,7 +1750,7 @@ _func_enter_;
 		#endif
 
 			_set_timer(&pmlmepriv->assoc_timer, 1);
-			//rtw_free_assoc_resources(adapter, 1);
+			/* rtw_free_assoc_resources(adapter, 1); */
 			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
 
 		#ifdef REJOIN
@@ -1839,8 +1833,8 @@ _func_enter_;
 
 				kfree(passoc_req);
 			}
-#endif //(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 			ap_sta_info_defer_update(adapter, psta);
 		}
@@ -1851,11 +1845,11 @@ _func_enter_;
 	psta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);
 	if (psta != NULL)
 	{
-		//the sta have been in sta_info_queue => do nothing
+		/* the sta have been in sta_info_queue => do nothing */
 
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Error: rtw_stassoc_event_callback: sta has been in sta_hash_queue\n"));
 
-		goto exit; //(between drv has received this event before and  fw have not yet to set key to CAM_ENTRY)
+		goto exit; /* between drv has received this event before and  fw have not yet to set key to CAM_ENTRY) */
 	}
 
 	psta = rtw_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);
@@ -1864,10 +1858,10 @@ _func_enter_;
 		goto exit;
 	}
 
-	//to do : init sta_info variable
+	/* to do : init sta_info variable */
 	psta->qos_option = 0;
 	psta->mac_id = (uint)pstassoc->cam_id;
-	//psta->aid = (uint)pstassoc->cam_id;
+	/* psta->aid = (uint)pstassoc->cam_id; */
 
 	if (adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
 		psta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;
@@ -1885,7 +1879,7 @@ _func_enter_;
 			ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
 			if (ptarget_wlan)	ptarget_wlan->fixed = true;
 			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-			// a sta + bc/mc_stainfo (not Ibss_stainfo)
+			/*  a sta + bc/mc_stainfo (not Ibss_stainfo) */
 			rtw_indicate_connect(adapter);
 		}
 	}
@@ -1919,8 +1913,8 @@ _func_enter_;
 
 #elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 		rtw_cfg80211_indicate_sta_disassoc(adapter, pstadel->macaddr, *(u16*)pstadel->rsvd);
-#endif //(LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37)) || defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 		return;
         }
@@ -1939,7 +1933,7 @@ _func_enter_;
 			rtw_set_roaming(adapter, adapter->registrypriv.max_roaming_times);
 #ifdef CONFIG_INTEL_WIDI
 		if (adapter->mlmepriv.widi_state != INTEL_WIDI_STATE_CONNECTED)
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 		if (*((unsigned short *)(pstadel->rsvd)) != WLAN_REASON_EXPIRATION_CHK)
 			rtw_set_roaming(adapter, 0); /* don't roam */
 		#endif
@@ -1949,7 +1943,7 @@ _func_enter_;
 		rtw_free_assoc_resources(adapter, 1);
 		rtw_indicate_disconnect(adapter);
 		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-		// remove the network entry in scanned_queue
+		/*  remove the network entry in scanned_queue */
 		pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 		if (pwlan) {
 			pwlan->fixed = false;
@@ -1962,7 +1956,7 @@ _func_enter_;
 #ifdef CONFIG_INTEL_WIDI
 		if (!rtw_to_roaming(adapter))
 			process_intel_widi_disconnect(adapter, 1);
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 	}
 
 	if (check_fwstate(pmlmepriv,WIFI_ADHOC_MASTER_STATE) ||
@@ -1974,12 +1968,10 @@ _func_enter_;
 		rtw_free_stainfo(adapter,  psta);
 		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
-		if (adapter->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
+		if (adapter->stapriv.asoc_sta_count== 1) /* a sta + bc/mc_stainfo (not Ibss_stainfo) */
 		{
-			//rtw_indicate_disconnect(adapter);//removed@20091105
 			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
-			//free old ibss network
-			//pwlan = rtw_find_network(&pmlmepriv->scanned_queue, pstadel->macaddr);
+			/* free old ibss network */
 			pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
 			if (pwlan)
 			{
@@ -1987,7 +1979,7 @@ _func_enter_;
 				rtw_free_network_nolock(pmlmepriv, pwlan);
 			}
 			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
-			//re-create ibss
+			/* re-create ibss */
 			pdev_network = &(adapter->registrypriv.dev_network);
 			pibss = adapter->registrypriv.dev_network.MacAddress;
 
@@ -2050,7 +2042,7 @@ void _rtw_join_timeout_handler (struct r
 	struct	mlme_priv *pmlmepriv = &adapter->mlmepriv;
 #ifdef CONFIG_LAYER2_ROAMING
 	int do_join_r;
-#endif //CONFIG_LAYER2_ROAMING
+#endif /* CONFIG_LAYER2_ROAMING */
 
 _func_enter_;
 	DBG_8192D("%s, fw_state=%x\n", __func__, get_fwstate(pmlmepriv));
@@ -2080,7 +2072,7 @@ _func_enter_;
 					intel_widi_wk_cmd(adapter, INTEL_WIDI_LISTEN_WK, NULL);
 					DBG_8192D("change to widi listen\n");
 				}
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 				DBG_8192D("%s We've try roaming but fail\n", __func__);
 				rtw_indicate_disconnect(adapter);
 				break;
@@ -2091,7 +2083,7 @@ _func_enter_;
 	#endif
 	{
 		rtw_indicate_disconnect(adapter);
-		free_scanqueue(pmlmepriv);//???
+		free_scanqueue(pmlmepriv);/*  */
 	}
 
 	spin_unlock_bh(&pmlmepriv->lock);
@@ -2128,26 +2120,10 @@ static void rtw_auto_scan_handler(struct
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;
 
-	//auto site survey per 60sec
-	if (pmlmepriv->scan_interval >0)
-	{
+	/* auto site survey per 60sec */
+	if (pmlmepriv->scan_interval > 0) {
 		pmlmepriv->scan_interval--;
-		if (pmlmepriv->scan_interval==0)
-		{
-/*
-			if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
-			{
-				DBG_8192D("exit %s when _FW_UNDER_SURVEY|_FW_UNDER_LINKING ->\n", __func__);
-				return;
-			}
-
-			if (pmlmepriv->sitesurveyctrl.traffic_busy == true)
-			{
-				DBG_8192D("%s exit cause traffic_busy(%x)\n",__func__, pmlmepriv->sitesurveyctrl.traffic_busy);
-				return;
-			}
-*/
-
+		if (pmlmepriv->scan_interval==0) {
 #ifdef CONFIG_CONCURRENT_MODE
 			if (rtw_buddy_adapter_up(padapter))
 			{
@@ -2164,7 +2140,7 @@ static void rtw_auto_scan_handler(struct
 
 			rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);
 
-			pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+			pmlmepriv->scan_interval = SCAN_INTERVAL;/*  30*2 sec = 60sec */
 
 		}
 
@@ -2175,7 +2151,7 @@ void rtw_dynamic_check_timer_handlder(st
 {
 #ifdef CONFIG_AP_MODE
 	struct mlme_priv *pmlmepriv = &adapter->mlmepriv;
-#endif //CONFIG_AP_MODE
+#endif /* CONFIG_AP_MODE */
 	struct registry_priv *pregistrypriv = &adapter->registrypriv;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter * pbuddy_adapter = adapter->pbuddy_adapter;
@@ -2200,7 +2176,7 @@ void rtw_dynamic_check_timer_handlder(st
 		}
 	}
 	else
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 	if (adapter->net_closed == true)
 	{
 		return;
@@ -2215,7 +2191,7 @@ void rtw_dynamic_check_timer_handlder(st
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 #endif
 		{
-			//auto site survey
+			/* auto site survey */
 			rtw_auto_scan_handler(adapter);
 		}
 	}
@@ -2227,22 +2203,22 @@ void rtw_dynamic_check_timer_handlder(st
 		expire_timeout_chk(adapter);
 	}
 #endif
-#endif //!CONFIG_ACTIVE_KEEP_ALIVE_CHECK
+#endif /* CONFIG_ACTIVE_KEEP_ALIVE_CHECK */
 
 #ifdef CONFIG_BR_EXT
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 	rcu_read_lock();
-#endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#endif	/*  (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 	if (adapter->pnetdev->br_port)
-#else	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#else	/*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 	if (rcu_dereference(adapter->pnetdev->rx_handler_data)
-#endif	// (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#endif	/*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 		&& (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true))
 	{
-		// expire NAT2.5 entry
+		/*  expire NAT2.5 entry */
 		void nat25_db_expire(struct rtw_adapter *priv);
 		nat25_db_expire(adapter);
 
@@ -2250,7 +2226,7 @@ void rtw_dynamic_check_timer_handlder(st
 			adapter->pppoe_connection_in_progress--;
 		}
 
-		// due to rtw_dynamic_check_timer_handlder() is called every 2 seconds
+		/*  due to rtw_dynamic_check_timer_handlder() is called every 2 seconds */
 		if (adapter->pppoe_connection_in_progress > 0) {
 			adapter->pppoe_connection_in_progress--;
 		}
@@ -2258,9 +2234,9 @@ void rtw_dynamic_check_timer_handlder(st
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
 	rcu_read_unlock();
-#endif	// (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#endif	/*  (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)) */
 
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 }
 
 
@@ -2303,7 +2279,7 @@ void rtw_set_scan_deny(struct rtw_adapte
 #endif
 
 #if defined(IEEE80211_SCAN_RESULT_EXPIRE)
-#define RTW_SCAN_RESULT_EXPIRE IEEE80211_SCAN_RESULT_EXPIRE/HZ*1000 -1000 //3000 -1000
+#define RTW_SCAN_RESULT_EXPIRE IEEE80211_SCAN_RESULT_EXPIRE/HZ*1000 -1000 /* 3000 -1000 */
 #else
 #define RTW_SCAN_RESULT_EXPIRE 2000
 #endif
@@ -2320,13 +2296,13 @@ static int rtw_check_join_candidate(stru
 	struct rtw_adapter *adapter = container_of(pmlmepriv, struct rtw_adapter, mlmepriv);
 
 
-	//check bssid, if needed
+	/* check bssid, if needed */
 	if (pmlmepriv->assoc_by_bssid==true) {
 		if (_rtw_memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN) ==false)
 			goto exit;
 	}
 
-	//check ssid, if needed
+	/* check ssid, if needed */
 	if (pmlmepriv->assoc_ssid.Ssid && pmlmepriv->assoc_ssid.SsidLength) {
 		if (	competitor->network.Ssid.SsidLength != pmlmepriv->assoc_ssid.SsidLength
 			|| _rtw_memcmp(competitor->network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength) == false
@@ -2426,7 +2402,7 @@ _func_enter_;
 	}
 
 
-	// check for situation of  _FW_LINKED
+	/*  check for situation of  _FW_LINKED */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		DBG_8192D("%s: _FW_LINKED while ask_for_joinbss!!!\n", __func__);
@@ -2470,7 +2446,7 @@ _func_enter_;
 
 	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 	if (pcmd==NULL) {
-		res= _FAIL;  //try again
+		res= _FAIL;  /* try again */
 		goto exit;
 	}
 
@@ -2518,7 +2494,7 @@ _func_enter_;
 
 	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
 	if (pcmd==NULL) {
-		res= _FAIL;  //try again
+		res= _FAIL;  /* try again */
 		goto exit;
 	}
 	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
@@ -2539,7 +2515,7 @@ _func_enter_;
 		RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("\n rtw_set_key: psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm=%d\n", psetkeyparm->algorithm));
 
 	}
-	psetkeyparm->keyid = (u8)keyid;//0~3
+	psetkeyparm->keyid = (u8)keyid;/* 0~3 */
 	psetkeyparm->set_tx = set_tx;
 	pmlmepriv->key_mask |= BIT(psetkeyparm->keyid);
 #ifdef CONFIG_AUTOSUSPEND
@@ -2587,7 +2563,7 @@ _func_enter_;
 
 	INIT_LIST_HEAD(&pcmd->list);
 
-	//_rtw_init_sema(&(pcmd->cmd_sem), 0);
+	/* _rtw_init_sema(&(pcmd->cmd_sem), 0); */
 
 	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
 
@@ -2597,29 +2573,20 @@ _func_exit_;
 }
 
 
-//adjust IEs for rtw_joinbss_cmd in WMM
+/* adjust IEs for rtw_joinbss_cmd in WMM */
 int rtw_restruct_wmm_ie(struct rtw_adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len)
 {
 	unsigned	int ielength=0;
 	unsigned int i, j;
 
-	i = 12; //after the fixed IE
+	i = 12; /* after the fixed IE */
 	while (i<in_len)
 	{
 		ielength = initial_out_len;
 
-		if (in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) //WMM element ID and OUI
+		if (in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) /* WMM element ID and OUI */
 		{
-			//Append WMM IE to the last index of out_ie
-			/*
-			for (j=i; j< i+(in_ie[i+1]+2); j++)
-			{
-				out_ie[ielength] = in_ie[j];
-				ielength++;
-			}
-			out_ie[initial_out_len+8] = 0x00; //force the QoS Info Field to be zero
-	                */
-
+			/* Append WMM IE to the last index of out_ie */
                         for (j = i; j < i + 9; j++)
                         {
                             out_ie[ ielength] = in_ie[ j ];
@@ -2632,23 +2599,23 @@ int rtw_restruct_wmm_ie(struct rtw_adapt
 			break;
 		}
 
-		i+=(in_ie[i+1]+2); // to the next IE element
+		i+=(in_ie[i+1]+2); /*  to the next IE element */
 	}
 
 	return ielength;
 }
 
 
-//
-// Ported from 8185: IsInPreAuthKeyList(). (Renamed from SecIsInPreAuthKeyList(), 2006-10-13.)
-// Added by Annie, 2006-05-07.
-//
-// Search by BSSID,
-// Return Value:
-//		-1		:if there is no pre-auth key in the  table
-//		>=0		:if there is pre-auth key, and   return the entry id
-//
-//
+/*  */
+/*  Ported from 8185: IsInPreAuthKeyList(). (Renamed from SecIsInPreAuthKeyList(), 2006-10-13.) */
+/*  Added by Annie, 2006-05-07. */
+/*  */
+/*  Search by BSSID, */
+/*  Return Value: */
+/* 		-1		:if there is no pre-auth key in the  table */
+/* 		>=0		:if there is pre-auth key, and   return the entry id */
+/*  */
+/*  */
 
 static int SecIsInPMKIDList(struct rtw_adapter *Adapter, u8 *bssid)
 {
@@ -2665,45 +2632,45 @@ static int SecIsInPMKIDList(struct rtw_a
 		else
 		{
 			i++;
-			//continue;
+			/* continue; */
 		}
 
 	}while (i<NUM_PMKID_CACHE);
 
 	if (i == NUM_PMKID_CACHE)
 	{
-		i = -1;// Could not find.
+		i = -1;/*  Could not find. */
 	}
 	else
 	{
-		// There is one Pre-Authentication Key for the specific BSSID.
+		/*  There is one Pre-Authentication Key for the specific BSSID. */
 	}
 
 	return (i);
 }
 
-//
-// Check the RSN IE length
-// If the RSN IE length <= 20, the RSN IE didn't include the PMKID information
-// 0-11th element in the array are the fixed IE
-// 12th element in the array is the IE
-// 13th element in the array is the IE length
-//
+/*  */
+/*  Check the RSN IE length */
+/*  If the RSN IE length <= 20, the RSN IE didn't include the PMKID information */
+/*  0-11th element in the array are the fixed IE */
+/*  12th element in the array is the IE */
+/*  13th element in the array is the IE length */
+/*  */
 
 static int rtw_append_pmkid(struct rtw_adapter *Adapter,int iEntry, u8 *ie, uint ie_len)
 {
 	struct security_priv *psecuritypriv=&Adapter->securitypriv;
 
 	if (ie[13]<=20) {
-		// The RSN IE didn't include the PMK ID, append the PMK information
+		/*  The RSN IE didn't include the PMK ID, append the PMK information */
 			ie[ie_len]=1;
 			ie_len++;
-			ie[ie_len]=0;	//PMKID count = 0x0100
+			ie[ie_len]=0;	/* PMKID count = 0x0100 */
 			ie_len++;
 			memcpy(	&ie[ie_len], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);
 
 			ie_len+=16;
-			ie[13]+=18;//PMKID length = 2+16
+			ie[13]+=18;/* PMKID length = 2+16 */
 
 	}
 	return (ie_len);
@@ -2727,7 +2694,7 @@ _func_enter_;
 		 ("+rtw_restruct_sec_ie: ndisauthmode=%d ndissecuritytype=%d\n",
 		  ndisauthmode, ndissecuritytype));
 
-	//copy fixed ie only
+	/* copy fixed ie only */
 	memcpy(out_ie, in_ie,12);
 	ielength=12;
 	if ((ndisauthmode==NDIS802_11AUTHMODEWPA)||(ndisauthmode==NDIS802_11AUTHMODEWPAPSK))
@@ -2743,7 +2710,7 @@ _func_enter_;
 	}
 	else if ((authmode==_WPA_IE_ID_)||(authmode==_WPA2_IE_ID_))
 	{
-		//copy RSN or SSN
+		/* copy RSN or SSN */
 		memcpy(&out_ie[ielength], &psecuritypriv->supplicant_ie[0], psecuritypriv->supplicant_ie[1]+2);
 		ielength+=psecuritypriv->supplicant_ie[1]+2;
 		rtw_report_sec_ie(adapter, authmode, psecuritypriv->supplicant_ie);
@@ -2802,11 +2769,11 @@ void rtw_update_registrypriv_dev_network
 	struct wlan_bssid_ex    *pdev_network = &pregistrypriv->dev_network;
 	struct	security_priv*	psecuritypriv = &adapter->securitypriv;
 	struct	wlan_network	*cur_network = &adapter->mlmepriv.cur_network;
-	//struct	xmit_priv	*pxmitpriv = &adapter->xmitpriv;
+	/* struct	xmit_priv	*pxmitpriv = &adapter->xmitpriv; */
 
 _func_enter_;
 
-	pdev_network->Privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0) ; // adhoc no 802.1x
+	pdev_network->Privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0) ; /*  adhoc no 802.1x */
 
 	pdev_network->Rssi = 0;
 
@@ -2832,7 +2799,7 @@ _func_enter_;
 			pdev_network->NetworkTypeInUse = (NDIS802_11OFDM24);
 		break;
 	default :
-		// TODO
+		/*  TODO */
 		break;
 	}
 
@@ -2844,19 +2811,15 @@ _func_enter_;
 
 	pdev_network->InfrastructureMode = (cur_network->network.InfrastructureMode);
 
-	// 1. Supported rates
-	// 2. IE
+	/*  1. Supported rates */
+	/*  2. IE */
 
-	//rtw_set_supported_rate(pdev_network->SupportedRates, pregistrypriv->wireless_mode) ; // will be called in rtw_generate_ie
 	sz = rtw_generate_ie(pregistrypriv);
 
 	pdev_network->IELength = sz;
 
 	pdev_network->Length = get_wlan_bssid_ex_sz((struct wlan_bssid_ex  *)pdev_network);
 
-	//notes: translate IELength & Length after assign the Length to cmdsz in createbss_cmd();
-	//pdev_network->IELength = cpu_to_le32(sz);
-
 _func_exit_;
 }
 
@@ -2868,7 +2831,7 @@ _func_enter_;
 _func_exit_;
 }
 
-//the fucntion is at passive_level
+/* the fucntion is at passive_level */
 void rtw_joinbss_reset(struct rtw_adapter *padapter)
 {
 	u8	threshold;
@@ -2878,7 +2841,7 @@ void rtw_joinbss_reset(struct rtw_adapte
 	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
 #endif
 
-	//todo: if you want to do something io/reg/hw setting before join_bss, please add code here
+	/* todo: if you want to do something io/reg/hw setting before join_bss, please add code here */
 
 
 
@@ -2889,10 +2852,10 @@ void rtw_joinbss_reset(struct rtw_adapte
 
 	pmlmepriv->num_sta_no_ht = 0;
 
-	phtpriv->ampdu_enable = false;//reset to disabled
+	phtpriv->ampdu_enable = false;/* reset to disabled */
 
-	// TH=1 => means that invalidate usb rx aggregation
-	// TH=0 => means that validate usb rx aggregation, use init value.
+	/*  TH=1 => means that invalidate usb rx aggregation */
+	/*  TH=0 => means that validate usb rx aggregation, use init value. */
 	if (phtpriv->ht_option)
 	{
 		if (padapter->registrypriv.wifi_spec==1)
@@ -2911,7 +2874,7 @@ void rtw_joinbss_reset(struct rtw_adapte
 
 #ifdef CONFIG_80211N_HT
 
-//the fucntion is >= passive_level
+/* the fucntion is >= passive_level */
 unsigned int rtw_restructure_ht_ie(struct rtw_adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len, u8 channel)
 {
 	u32 ielen, out_len;
@@ -2945,7 +2908,7 @@ unsigned int rtw_restructure_ht_ie(struc
 
 		ht_capie.cap_info =  IEEE80211_HT_CAP_SGI_20 | IEEE80211_HT_CAP_TX_STBC |
 							IEEE80211_HT_CAP_DSSSCCK40;
-		//if insert module set only support 20MHZ, don't add the 40MHZ and SGI_40
+		/* if insert module set only support 20MHZ, don't add the 40MHZ and SGI_40 */
 		if (channel > 14)
 		{
 			if (pregpriv->cbw40_enable & BIT(1))
@@ -2964,10 +2927,10 @@ unsigned int rtw_restructure_ht_ie(struc
 			u32 rx_packet_offset, max_recvbuf_sz;
 			rtw_hal_get_def_var(padapter, HAL_DEF_RX_PACKET_OFFSET, &rx_packet_offset);
 			rtw_hal_get_def_var(padapter, HAL_DEF_MAX_RECVBUF_SZ, &max_recvbuf_sz);
-			//if (max_recvbuf_sz-rx_packet_offset>(8191-256)) {
-			//	DBG_8192D("%s IEEE80211_HT_CAP_MAX_AMSDU is set\n", __func__);
-			//	ht_capie.cap_info = ht_capie.cap_info |IEEE80211_HT_CAP_MAX_AMSDU;
-			//}
+			/* if (max_recvbuf_sz-rx_packet_offset>(8191-256)) { */
+			/* 	DBG_8192D("%s IEEE80211_HT_CAP_MAX_AMSDU is set\n", __func__); */
+			/* 	ht_capie.cap_info = ht_capie.cap_info |IEEE80211_HT_CAP_MAX_AMSDU; */
+			/*  */
 		}
 
 		ht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR&0x03);
@@ -2980,12 +2943,6 @@ unsigned int rtw_restructure_ht_ie(struc
 
 		pframe = rtw_set_ie(out_ie+out_len, _HT_CAPABILITY_IE_,
 							sizeof(struct rtw_ieee80211_ht_cap), (unsigned char*)&ht_capie, pout_len);
-
-
-		//memcpy(out_ie+out_len, p, ielen+2);//gtest
-		//*pout_len = *pout_len + (ielen+2);
-
-
 		phtpriv->ht_option = true;
 
 		p = rtw_get_ie(in_ie+12, _HT_ADD_INFO_IE_, &ielen, in_len-12);
@@ -3000,20 +2957,20 @@ unsigned int rtw_restructure_ht_ie(struc
 	return (phtpriv->ht_option);
 }
 
-//the fucntion is > passive_level (in critical_section)
+/* the fucntion is > passive_level (in critical_section) */
 void rtw_update_ht_cap(struct rtw_adapter *padapter, u8 *pie, uint ie_len, u8 channel)
 {
 	u8 *p, max_ampdu_sz;
 	int len;
-	//struct sta_info *bmc_sta, *psta;
+	/* struct sta_info *bmc_sta, *psta; */
 	struct rtw_ieee80211_ht_cap *pht_capie;
 	struct ieee80211_ht_addt_info *pht_addtinfo;
-	//struct recv_reorder_ctrl *preorder_ctrl;
+	/* struct recv_reorder_ctrl *preorder_ctrl; */
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
-	//struct recv_priv *precvpriv = &padapter->recvpriv;
+	/* struct recv_priv *precvpriv = &padapter->recvpriv; */
 	struct registry_priv *pregistrypriv = &padapter->registrypriv;
-	//struct wlan_network *pcur_network = &(pmlmepriv->cur_network);;
+	/* struct wlan_network *pcur_network = &(pmlmepriv->cur_network);; */
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8 cbw40_enable=0;
@@ -3026,7 +2983,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 
 	DBG_8192D("+rtw_update_ht_cap()\n");
 
-	//maybe needs check if ap supports rx ampdu.
+	/* maybe needs check if ap supports rx ampdu. */
 	if ((phtpriv->ampdu_enable==false) &&(pregistrypriv->ampdu_enable==1))
 	{
 		if (pregistrypriv->wifi_spec==1)
@@ -3044,16 +3001,16 @@ void rtw_update_ht_cap(struct rtw_adapte
 	}
 
 
-	//check Max Rx A-MPDU Size
+	/* check Max Rx A-MPDU Size */
 	len = 0;
 	p = rtw_get_ie(pie+sizeof (struct ndis_802_11_fixed_ies), _HT_CAPABILITY_IE_, &len, ie_len-sizeof (struct ndis_802_11_fixed_ies));
 	if (p && len>0)
 	{
 		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
 		max_ampdu_sz = (pht_capie->ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);
-		max_ampdu_sz = 1 << (max_ampdu_sz+3); // max_ampdu_sz (kbytes);
+		max_ampdu_sz = 1 << (max_ampdu_sz+3); /*  max_ampdu_sz (kbytes); */
 
-		//DBG_8192D("rtw_update_ht_cap(): max_ampdu_sz=%d\n", max_ampdu_sz);
+		/* DBG_8192D("rtw_update_ht_cap(): max_ampdu_sz=%d\n", max_ampdu_sz); */
 		phtpriv->rx_ampdu_maxlen = max_ampdu_sz;
 
 	}
@@ -3064,7 +3021,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 	if (p && len>0)
 	{
 		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p+2);
-		//todo:
+		/* todo: */
 	}
 
 	if (channel > 14)
@@ -3077,7 +3034,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 			cbw40_enable = 1;
 
 
-	//update cur_bwmode & cur_ch_offset
+	/* update cur_bwmode & cur_ch_offset */
 	if ((cbw40_enable) &&
 		(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & BIT(1)) &&
 		(pmlmeinfo->HT_info.infos[0] & BIT(2)))
@@ -3087,7 +3044,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
-		//update the MCS rates
+		/* update the MCS rates */
 		for (i = 0; i < 16; i++)
 		{
 			if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
@@ -3105,7 +3062,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 					pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
 				#else
 				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
-				#endif //CONFIG_DISABLE_MCS13TO15
+				#endif /* CONFIG_DISABLE_MCS13TO15 */
 			}
 			#ifdef RTL8192C_RECONFIG_TO_1T1R
 			{
@@ -3117,7 +3074,7 @@ void rtw_update_ht_cap(struct rtw_adapte
 				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
 
 		}
-		//switch to the 40M Hz mode accoring to the AP
+		/* switch to the 40M Hz mode accoring to the AP */
 		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
 		switch ((pmlmeinfo->HT_info.infos[0] & 0x3))
 		{
@@ -3135,24 +3092,18 @@ void rtw_update_ht_cap(struct rtw_adapte
 		}
 	}
 
-	//
-	// Config SM Power Save setting
-	//
+	/*  */
+	/*  Config SM Power Save setting */
+	/*  */
 	pmlmeinfo->SM_PS = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 0x0C) >> 2;
 	if (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)
 	{
-		/*u8 i;
-		//update the MCS rates
-		for (i = 0; i < 16; i++)
-		{
-			pmlmeinfo->HT_caps.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
-		}*/
 		DBG_8192D("%s(): WLAN_HT_CAP_SM_PS_STATIC\n",__func__);
 	}
 
-	//
-	// Config current HT Protection mode.
-	//
+	/*  */
+	/*  Config current HT Protection mode. */
+	/*  */
 	pmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;
 }
 
@@ -3300,4 +3251,4 @@ int check_buddy_fwstate(struct rtw_adapt
 
 	return false;
 }
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
--- a/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
+++ b/drivers/staging/rtl8192du/core/rtw_mlme_ext.c
@@ -112,143 +112,120 @@ MCS rate definitions
 #ifdef CONFIG_DISABLE_MCS13TO15
 unsigned char	MCS_rate_2R_MCS13TO15_OFF[16] = {0xff, 0x1f, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
 unsigned char	MCS_rate_2R[16] = {0xff, 0xff, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
-#else //CONFIG_DISABLE_MCS13TO15
+#else /* CONFIG_DISABLE_MCS13TO15 */
 unsigned char	MCS_rate_2R[16] = {0xff, 0xff, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
-#endif //CONFIG_DISABLE_MCS13TO15
+#endif /* CONFIG_DISABLE_MCS13TO15 */
 unsigned char	MCS_rate_1R[16] = {0xff, 0x00, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
 
 /********************************************************
 ChannelPlan definitions
 *********************************************************/
-/*static struct rt_channel_plan	DefaultChannelPlan[RT_CHANNEL_DOMAIN_MAX] = {
-	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},32},					// 0x00, RT_CHANNEL_DOMAIN_FCC
-	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},31},						// 0x01, RT_CHANNEL_DOMAIN_IC
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},32},						// 0x02, RT_CHANNEL_DOMAIN_ETSI
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},																					// 0x03, RT_CHANNEL_DOMAIN_SPAIN
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},																					// 0x04, RT_CHANNEL_DOMAIN_FRANCE
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},																					// 0x05, RT_CHANNEL_DOMAIN_MKK
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},																					// 0x06, RT_CHANNEL_DOMAIN_MKK1
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64},21},																// 0x07, RT_CHANNEL_DOMAIN_ISRAEL
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14,36,40,44,48,52,56,60,64},22},															// 0x08, RT_CHANNEL_DOMAIN_TELEC
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14},																				// 0x09, RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},																					// 0x0A, RT_CHANNEL_DOMAIN_WORLD_WIDE_13
-	{{1,2,3,4,5,6,7,8,9,10,11,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},26},									// 0x0B, RT_CHANNEL_DOMAIN_TAIWAN
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,149,153,157,161,165},18},																// 0x0C, RT_CHANNEL_DOMAIN_CHINA
-	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64,149,153,157,161,165},24},												// 0x0D, RT_CHANNEL_DOMAIN_SINGAPORE_INDIA_MEXICO
-	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,149,153,157,161,165},31},						// 0x0E, RT_CHANNEL_DOMAIN_KOREA
-	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,52,56,60,64},19},																	// 0x0F, RT_CHANNEL_DOMAIN_TURKEY
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},32},						// 0x10, RT_CHANNEL_DOMAIN_JAPAN
-	{{1,2,3,4,5,6,7,8,9,10,11,36,40,44,48,149,153,157,161,165},20},															// 0x11, RT_CHANNEL_DOMAIN_FCC_NO_DFS
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48},17},																		// 0x12, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165},37},	// 0x13, RT_CHANNEL_DOMAIN_WORLD_WIDE_5G
-	{{1,2,3,4,5,6,7,8,9,10,11,56,60,64,149,153,157,161,165},19},																// 0x14, RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS
-};*/
 
 static struct rt_channel_plan_2g RTW_ChannelPlan2G[RT_CHANNEL_DOMAIN_2G_MAX] = {
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},		// 0x00, RT_CHANNEL_DOMAIN_2G_WORLD , Passive scan CH 12, 13
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},		// 0x01, RT_CHANNEL_DOMAIN_2G_ETSI1
-	{{1,2,3,4,5,6,7,8,9,10,11},11},			// 0x02, RT_CHANNEL_DOMAIN_2G_FCC1
-	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14},	// 0x03, RT_CHANNEL_DOMAIN_2G_MIKK1
-	{{10,11,12,13},4},						// 0x04, RT_CHANNEL_DOMAIN_2G_ETSI2
-	{{},0},									// 0x05, RT_CHANNEL_DOMAIN_2G_NULL
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},		/*  0x00, RT_CHANNEL_DOMAIN_2G_WORLD , Passive scan CH 12, 13 */
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13},13},		/*  0x01, RT_CHANNEL_DOMAIN_2G_ETSI1 */
+	{{1,2,3,4,5,6,7,8,9,10,11},11},			/*  0x02, RT_CHANNEL_DOMAIN_2G_FCC1 */
+	{{1,2,3,4,5,6,7,8,9,10,11,12,13,14},14},	/*  0x03, RT_CHANNEL_DOMAIN_2G_MIKK1 */
+	{{10,11,12,13},4},						/*  0x04, RT_CHANNEL_DOMAIN_2G_ETSI2 */
+	{{},0},									/*  0x05, RT_CHANNEL_DOMAIN_2G_NULL */
 };
 
 static struct rt_channel_plan_5g RTW_ChannelPlan5G[RT_CHANNEL_DOMAIN_5G_MAX] = {
-	{{},0},																					// 0x00, RT_CHANNEL_DOMAIN_5G_NULL
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},						// 0x01, RT_CHANNEL_DOMAIN_5G_ETSI1
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165},24},	// 0x02, RT_CHANNEL_DOMAIN_5G_ETSI2
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,149,153,157,161,165},22},			// 0x03, RT_CHANNEL_DOMAIN_5G_ETSI3
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165},24},	// 0x04, RT_CHANNEL_DOMAIN_5G_FCC1
-	{{36,40,44,48,149,153,157,161,165},9},														// 0x05, RT_CHANNEL_DOMAIN_5G_FCC2
-	{{36,40,44,48,52,56,60,64,149,153,157,161,165},13},											// 0x06, RT_CHANNEL_DOMAIN_5G_FCC3
-	{{36,40,44,48,52,56,60,64,149,153,157,161},12},												// 0x07, RT_CHANNEL_DOMAIN_5G_FCC4
-	{{149,153,157,161,165},5},																	// 0x08, RT_CHANNEL_DOMAIN_5G_FCC5
-	{{36,40,44,48,52,56,60,64},8},																// 0x09, RT_CHANNEL_DOMAIN_5G_FCC6
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},20},					// 0x0A, RT_CHANNEL_DOMAIN_5G_FCC7_IC1
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,149,153,157,161,165},20},					// 0x0B, RT_CHANNEL_DOMAIN_5G_KCC1
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},						// 0x0C, RT_CHANNEL_DOMAIN_5G_MKK1
-	{{36,40,44,48,52,56,60,64},8},																// 0x0D, RT_CHANNEL_DOMAIN_5G_MKK2
-	{{100,104,108,112,116,120,124,128,132,136,140},11},											// 0x0E, RT_CHANNEL_DOMAIN_5G_MKK3
-	{{56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},15},								// 0x0F, RT_CHANNEL_DOMAIN_5G_NCC1
-	{{56,60,64,149,153,157,161,165},8},															// 0x10, RT_CHANNEL_DOMAIN_5G_NCC2
-
-	//===== Driver self defined for old channel plan Compatible ,Remember to modify if have new channel plan definition =====
-	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},21},				// 0x11, RT_CHANNEL_DOMAIN_5G_FCC
-	{{36,40,44,48},4},																			// 0x12, RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS
-	{{36,40,44,48,149,153,157,161},8},																// 0x13, RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS
+	{{},0},																					/*  0x00, RT_CHANNEL_DOMAIN_5G_NULL */
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},						/*  0x01, RT_CHANNEL_DOMAIN_5G_ETSI1 */
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165},24},	/*  0x02, RT_CHANNEL_DOMAIN_5G_ETSI2 */
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,149,153,157,161,165},22},			/*  0x03, RT_CHANNEL_DOMAIN_5G_ETSI3 */
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165},24},	/*  0x04, RT_CHANNEL_DOMAIN_5G_FCC1 */
+	{{36,40,44,48,149,153,157,161,165},9},														/*  0x05, RT_CHANNEL_DOMAIN_5G_FCC2 */
+	{{36,40,44,48,52,56,60,64,149,153,157,161,165},13},											/*  0x06, RT_CHANNEL_DOMAIN_5G_FCC3 */
+	{{36,40,44,48,52,56,60,64,149,153,157,161},12},												/*  0x07, RT_CHANNEL_DOMAIN_5G_FCC4 */
+	{{149,153,157,161,165},5},																	/*  0x08, RT_CHANNEL_DOMAIN_5G_FCC5 */
+	{{36,40,44,48,52,56,60,64},8},																/*  0x09, RT_CHANNEL_DOMAIN_5G_FCC6 */
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},20},					/*  0x0A, RT_CHANNEL_DOMAIN_5G_FCC7_IC1 */
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,149,153,157,161,165},20},					/*  0x0B, RT_CHANNEL_DOMAIN_5G_KCC1 */
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140},19},						/*  0x0C, RT_CHANNEL_DOMAIN_5G_MKK1 */
+	{{36,40,44,48,52,56,60,64},8},																/*  0x0D, RT_CHANNEL_DOMAIN_5G_MKK2 */
+	{{100,104,108,112,116,120,124,128,132,136,140},11},											/*  0x0E, RT_CHANNEL_DOMAIN_5G_MKK3 */
+	{{56,60,64,100,104,108,112,116,136,140,149,153,157,161,165},15},								/*  0x0F, RT_CHANNEL_DOMAIN_5G_NCC1 */
+	{{56,60,64,149,153,157,161,165},8},															/*  0x10, RT_CHANNEL_DOMAIN_5G_NCC2 */
+
+	/*  Driver self defined for old channel plan Compatible ,Remember to modify if have new channel plan definition ===== */
+	{{36,40,44,48,52,56,60,64,100,104,108,112,116,132,136,140,149,153,157,161,165},21},				/*  0x11, RT_CHANNEL_DOMAIN_5G_FCC */
+	{{36,40,44,48},4},																			/*  0x12, RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS */
+	{{36,40,44,48,149,153,157,161},8},																/*  0x13, RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS */
 };
 
 static struct rt_channel_plan_map RTW_ChannelPlanMap[RT_CHANNEL_DOMAIN_MAX] = {
-	//===== 0x00 ~ 0x1F , Old Define =====
-	{0x02,0x11},	//0x00, RT_CHANNEL_DOMAIN_FCC
-	{0x02,0x0A},	//0x01, RT_CHANNEL_DOMAIN_IC
-	{0x01,0x01},	//0x02, RT_CHANNEL_DOMAIN_ETSI
-	{0x01,0x00},	//0x03, RT_CHANNEL_DOMAIN_SPAIN
-	{0x01,0x00},	//0x04, RT_CHANNEL_DOMAIN_FRANCE
-	{0x03,0x00},	//0x05, RT_CHANNEL_DOMAIN_MKK
-	{0x03,0x00},	//0x06, RT_CHANNEL_DOMAIN_MKK1
-	{0x01,0x09},	//0x07, RT_CHANNEL_DOMAIN_ISRAEL
-	{0x03,0x09},	//0x08, RT_CHANNEL_DOMAIN_TELEC
-	{0x03,0x00},	//0x09, RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN
-	{0x00,0x00},	//0x0A, RT_CHANNEL_DOMAIN_WORLD_WIDE_13
-	{0x02,0x0F},	//0x0B, RT_CHANNEL_DOMAIN_TAIWAN
-	{0x01,0x08},	//0x0C, RT_CHANNEL_DOMAIN_CHINA
-	{0x02,0x06},	//0x0D, RT_CHANNEL_DOMAIN_SINGAPORE_INDIA_MEXICO
-	{0x02,0x0B},	//0x0E, RT_CHANNEL_DOMAIN_KOREA
-	{0x02,0x09},	//0x0F, RT_CHANNEL_DOMAIN_TURKEY
-	{0x01,0x01},	//0x10, RT_CHANNEL_DOMAIN_JAPAN
-	{0x02,0x05},	//0x11, RT_CHANNEL_DOMAIN_FCC_NO_DFS
-	{0x01,0x12},	//0x12, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS
-	{0x00,0x04},	//0x13, RT_CHANNEL_DOMAIN_WORLD_WIDE_5G
-	{0x02,0x10},	//0x14, RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS
-	{0x00,0x12},	//0x15, RT_CHANNEL_DOMAIN_ETSI_NO_DFS
-	{0x00,0x13},	//0x16, RT_CHANNEL_DOMAIN_KOREA_NO_DFS
-	{0x03,0x12},	//0x17, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS
-	{0x05,0x08},	//0x18, RT_CHANNEL_DOMAIN_PAKISTAN_NO_DFS
-	{0x02,0x08},	//0x19, RT_CHANNEL_DOMAIN_TAIWAN2_NO_DFS
-	{0x00,0x00},	//0x1A,
-	{0x00,0x00},	//0x1B,
-	{0x00,0x00},	//0x1C,
-	{0x00,0x00},	//0x1D,
-	{0x00,0x00},	//0x1E,
-	{0x05,0x04},	//0x1F, RT_CHANNEL_DOMAIN_WORLD_WIDE_ONLY_5G
-	//===== 0x20 ~ 0x7F ,New Define =====
-	{0x00,0x00},	//0x20, RT_CHANNEL_DOMAIN_WORLD_NULL
-	{0x01,0x00},	//0x21, RT_CHANNEL_DOMAIN_ETSI1_NULL
-	{0x02,0x00},	//0x22, RT_CHANNEL_DOMAIN_FCC1_NULL
-	{0x03,0x00},	//0x23, RT_CHANNEL_DOMAIN_MKK1_NULL
-	{0x04,0x00},	//0x24, RT_CHANNEL_DOMAIN_ETSI2_NULL
-	{0x02,0x04},	//0x25, RT_CHANNEL_DOMAIN_FCC1_FCC1
-	{0x00,0x01},	//0x26, RT_CHANNEL_DOMAIN_WORLD_ETSI1
-	{0x03,0x0C},	//0x27, RT_CHANNEL_DOMAIN_MKK1_MKK1
-	{0x00,0x0B},	//0x28, RT_CHANNEL_DOMAIN_WORLD_KCC1
-	{0x00,0x05},	//0x29, RT_CHANNEL_DOMAIN_WORLD_FCC2
-	{0x00,0x00},	//0x2A,
-	{0x00,0x00},	//0x2B,
-	{0x00,0x00},	//0x2C,
-	{0x00,0x00},	//0x2D,
-	{0x00,0x00},	//0x2E,
-	{0x00,0x00},	//0x2F,
-	{0x00,0x06},	//0x30, RT_CHANNEL_DOMAIN_WORLD_FCC3
-	{0x00,0x07},	//0x31, RT_CHANNEL_DOMAIN_WORLD_FCC4
-	{0x00,0x08},	//0x32, RT_CHANNEL_DOMAIN_WORLD_FCC5
-	{0x00,0x09},	//0x33, RT_CHANNEL_DOMAIN_WORLD_FCC6
-	{0x02,0x0A},	//0x34, RT_CHANNEL_DOMAIN_FCC1_FCC7
-	{0x00,0x02},	//0x35, RT_CHANNEL_DOMAIN_WORLD_ETSI2
-	{0x00,0x03},	//0x36, RT_CHANNEL_DOMAIN_WORLD_ETSI3
-	{0x03,0x0D},	//0x37, RT_CHANNEL_DOMAIN_MKK1_MKK2
-	{0x03,0x0E},	//0x38, RT_CHANNEL_DOMAIN_MKK1_MKK3
-	{0x02,0x0F},	//0x39, RT_CHANNEL_DOMAIN_FCC1_NCC1
-	{0x00,0x00},	//0x3A,
-	{0x00,0x00},	//0x3B,
-	{0x00,0x00},	//0x3C,
-	{0x00,0x00},	//0x3D,
-	{0x00,0x00},	//0x3E,
-	{0x00,0x00},	//0x3F,
-	{0x02,0x10},	//0x40, RT_CHANNEL_DOMAIN_FCC1_NCC2
+	/*  0x00 ~ 0x1F , Old Define ===== */
+	{0x02,0x11},	/* 0x00, RT_CHANNEL_DOMAIN_FCC */
+	{0x02,0x0A},	/* 0x01, RT_CHANNEL_DOMAIN_IC */
+	{0x01,0x01},	/* 0x02, RT_CHANNEL_DOMAIN_ETSI */
+	{0x01,0x00},	/* 0x03, RT_CHANNEL_DOMAIN_SPAIN */
+	{0x01,0x00},	/* 0x04, RT_CHANNEL_DOMAIN_FRANCE */
+	{0x03,0x00},	/* 0x05, RT_CHANNEL_DOMAIN_MKK */
+	{0x03,0x00},	/* 0x06, RT_CHANNEL_DOMAIN_MKK1 */
+	{0x01,0x09},	/* 0x07, RT_CHANNEL_DOMAIN_ISRAEL */
+	{0x03,0x09},	/* 0x08, RT_CHANNEL_DOMAIN_TELEC */
+	{0x03,0x00},	/* 0x09, RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN */
+	{0x00,0x00},	/* 0x0A, RT_CHANNEL_DOMAIN_WORLD_WIDE_13 */
+	{0x02,0x0F},	/* 0x0B, RT_CHANNEL_DOMAIN_TAIWAN */
+	{0x01,0x08},	/* 0x0C, RT_CHANNEL_DOMAIN_CHINA */
+	{0x02,0x06},	/* 0x0D, RT_CHANNEL_DOMAIN_SINGAPORE_INDIA_MEXICO */
+	{0x02,0x0B},	/* 0x0E, RT_CHANNEL_DOMAIN_KOREA */
+	{0x02,0x09},	/* 0x0F, RT_CHANNEL_DOMAIN_TURKEY */
+	{0x01,0x01},	/* 0x10, RT_CHANNEL_DOMAIN_JAPAN */
+	{0x02,0x05},	/* 0x11, RT_CHANNEL_DOMAIN_FCC_NO_DFS */
+	{0x01,0x12},	/* 0x12, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS */
+	{0x00,0x04},	/* 0x13, RT_CHANNEL_DOMAIN_WORLD_WIDE_5G */
+	{0x02,0x10},	/* 0x14, RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS */
+	{0x00,0x12},	/* 0x15, RT_CHANNEL_DOMAIN_ETSI_NO_DFS */
+	{0x00,0x13},	/* 0x16, RT_CHANNEL_DOMAIN_KOREA_NO_DFS */
+	{0x03,0x12},	/* 0x17, RT_CHANNEL_DOMAIN_JAPAN_NO_DFS */
+	{0x05,0x08},	/* 0x18, RT_CHANNEL_DOMAIN_PAKISTAN_NO_DFS */
+	{0x02,0x08},	/* 0x19, RT_CHANNEL_DOMAIN_TAIWAN2_NO_DFS */
+	{0x00,0x00},	/* 0x1A, */
+	{0x00,0x00},	/* 0x1B, */
+	{0x00,0x00},	/* 0x1C, */
+	{0x00,0x00},	/* 0x1D, */
+	{0x00,0x00},	/* 0x1E, */
+	{0x05,0x04},	/* 0x1F, RT_CHANNEL_DOMAIN_WORLD_WIDE_ONLY_5G */
+	/*  0x20 ~ 0x7F ,New Define ===== */
+	{0x00,0x00},	/* 0x20, RT_CHANNEL_DOMAIN_WORLD_NULL */
+	{0x01,0x00},	/* 0x21, RT_CHANNEL_DOMAIN_ETSI1_NULL */
+	{0x02,0x00},	/* 0x22, RT_CHANNEL_DOMAIN_FCC1_NULL */
+	{0x03,0x00},	/* 0x23, RT_CHANNEL_DOMAIN_MKK1_NULL */
+	{0x04,0x00},	/* 0x24, RT_CHANNEL_DOMAIN_ETSI2_NULL */
+	{0x02,0x04},	/* 0x25, RT_CHANNEL_DOMAIN_FCC1_FCC1 */
+	{0x00,0x01},	/* 0x26, RT_CHANNEL_DOMAIN_WORLD_ETSI1 */
+	{0x03,0x0C},	/* 0x27, RT_CHANNEL_DOMAIN_MKK1_MKK1 */
+	{0x00,0x0B},	/* 0x28, RT_CHANNEL_DOMAIN_WORLD_KCC1 */
+	{0x00,0x05},	/* 0x29, RT_CHANNEL_DOMAIN_WORLD_FCC2 */
+	{0x00,0x00},	/* 0x2A, */
+	{0x00,0x00},	/* 0x2B, */
+	{0x00,0x00},	/* 0x2C, */
+	{0x00,0x00},	/* 0x2D, */
+	{0x00,0x00},	/* 0x2E, */
+	{0x00,0x00},	/* 0x2F, */
+	{0x00,0x06},	/* 0x30, RT_CHANNEL_DOMAIN_WORLD_FCC3 */
+	{0x00,0x07},	/* 0x31, RT_CHANNEL_DOMAIN_WORLD_FCC4 */
+	{0x00,0x08},	/* 0x32, RT_CHANNEL_DOMAIN_WORLD_FCC5 */
+	{0x00,0x09},	/* 0x33, RT_CHANNEL_DOMAIN_WORLD_FCC6 */
+	{0x02,0x0A},	/* 0x34, RT_CHANNEL_DOMAIN_FCC1_FCC7 */
+	{0x00,0x02},	/* 0x35, RT_CHANNEL_DOMAIN_WORLD_ETSI2 */
+	{0x00,0x03},	/* 0x36, RT_CHANNEL_DOMAIN_WORLD_ETSI3 */
+	{0x03,0x0D},	/* 0x37, RT_CHANNEL_DOMAIN_MKK1_MKK2 */
+	{0x03,0x0E},	/* 0x38, RT_CHANNEL_DOMAIN_MKK1_MKK3 */
+	{0x02,0x0F},	/* 0x39, RT_CHANNEL_DOMAIN_FCC1_NCC1 */
+	{0x00,0x00},	/* 0x3A, */
+	{0x00,0x00},	/* 0x3B, */
+	{0x00,0x00},	/* 0x3C, */
+	{0x00,0x00},	/* 0x3D, */
+	{0x00,0x00},	/* 0x3E, */
+	{0x00,0x00},	/* 0x3F, */
+	{0x02,0x10},	/* 0x40, RT_CHANNEL_DOMAIN_FCC1_NCC2 */
 };
 
-static struct rt_channel_plan_map RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE = {0x03,0x02}; //use the conbination for max channel numbers
+static struct rt_channel_plan_map RTW_CHANNEL_PLAN_MAP_REALTEK_DEFINE = {0x03,0x02}; /* use the conbination for max channel numbers */
 
 /*
  * Search the @param channel_num in given @param channel_set
@@ -280,8 +257,6 @@ int init_hw_mlme_ext(struct rtw_adapter
 {
 	struct	mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
-	//set_opmode_cmd(padapter, infra_client_with_mlme);//removed
-
 	set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 
 	return _SUCCESS;
@@ -292,12 +267,11 @@ static void init_mlme_ext_priv_value(str
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	//unsigned char default_channel_set[MAX_CHANNEL_NUM] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 0};
 	unsigned char	mixed_datarate[NUMRATES] = {_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_,_9M_RATE_, _12M_RATE_, _18M_RATE_, _24M_RATE_, _36M_RATE_, _48M_RATE_, _54M_RATE_, 0xff};
 	unsigned char	mixed_basicrate[NUMRATES] ={_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_, _12M_RATE_, _24M_RATE_, 0xff,};
 
 	ATOMIC_SET(&pmlmeext->event_seq, 0);
-	pmlmeext->mgnt_seq = 0;//reset to zero when disconnect at client mode
+	pmlmeext->mgnt_seq = 0;/* reset to zero when disconnect at client mode */
 
 	pmlmeext->cur_channel = padapter->registrypriv.channel;
 	pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
@@ -307,8 +281,6 @@ static void init_mlme_ext_priv_value(str
 
 	pmlmeext->cur_wireless_mode = padapter->registrypriv.wireless_mode;
 
-	//memcpy(pmlmeext->channel_set, DefaultChannelPlan[padapter->mlmepriv.ChannelPlan].Channel, DefaultChannelPlan[padapter->mlmepriv.ChannelPlan].Len);
-	//memcpy(pmlmeext->channel_set, default_channel_set, MAX_CHANNEL_NUM);
 	memcpy(pmlmeext->datarate, mixed_datarate, NUMRATES);
 	memcpy(pmlmeext->basicrate, mixed_basicrate, NUMRATES);
 
@@ -447,7 +419,7 @@ static u8 init_channel_set(struct rtw_ad
 		{
 			channel_set[chanset_size].ChannelNum = RTW_ChannelPlan2G[Index2G].Channel[index];
 
-			if (RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN == ChannelPlan) //Channel 1~11 is active, and 12~14 is passive
+			if (RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN == ChannelPlan) /* Channel 1~11 is active, and 12~14 is passive */
 			{
 				if (channel_set[chanset_size].ChannelNum >= 1 && channel_set[chanset_size].ChannelNum <= 11)
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
@@ -456,7 +428,7 @@ static u8 init_channel_set(struct rtw_ad
 			}
 			else if (RT_CHANNEL_DOMAIN_WORLD_WIDE_13 == ChannelPlan ||
 				RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan ||
-				RT_CHANNEL_DOMAIN_2G_WORLD == Index2G)// channel 12~13, passive scan
+				RT_CHANNEL_DOMAIN_2G_WORLD == Index2G)/*  channel 12~13, passive scan */
 			{
 				if (channel_set[chanset_size].ChannelNum <= 11)
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
@@ -481,7 +453,7 @@ static u8 init_channel_set(struct rtw_ad
 			if (channel_set[chanset_size].ChannelNum <= 48
 				|| channel_set[chanset_size].ChannelNum >= 149)
 			{
-				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
+				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)/* passive scan for all 5G channels */
 					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
 				else
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
@@ -495,7 +467,7 @@ static u8 init_channel_set(struct rtw_ad
 			if (RTW_ChannelPlan5G[Index5G].Channel[index] <= 48
 				|| RTW_ChannelPlan5G[Index5G].Channel[index] >= 149) {
 				channel_set[chanset_size].ChannelNum = RTW_ChannelPlan5G[Index5G].Channel[index];
-				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
+				if (RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)/* passive scan for all 5G channels */
 					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
 				else
 					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
@@ -517,13 +489,8 @@ int	init_mlme_ext_priv(struct rtw_adapte
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
-	//memset((u8 *)pmlmeext, 0, sizeof(struct mlme_ext_priv));
-
 	pmlmeext->padapter = padapter;
 
-	//fill_fwpriv(padapter, &(pmlmeext->fwpriv));
-
 	init_mlme_ext_priv_value(padapter);
 	pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
 
@@ -558,12 +525,11 @@ void free_mlme_ext_priv (struct mlme_ext
 	{
 		_cancel_timer_ex(&pmlmeext->survey_timer);
 		_cancel_timer_ex(&pmlmeext->link_timer);
-		//_cancel_timer_ex(&pmlmeext->ADDBA_timer);
 	}
 }
 
 static u8 cmp_pkt_chnl_diff(struct rtw_adapter *padapter,u8* pframe,uint packet_len)
-{	// if the channel is same, return 0. else return channel differential
+{	/*  if the channel is same, return 0. else return channel differential */
 	uint len;
 	u8 channel;
 	u8 *p;
@@ -593,7 +559,7 @@ static void _mgt_dispatcher(struct rtw_a
 
 	  if (ptable->func)
         {
-	 //receive the frames that ra(a1) is my address or ra(a1) is bc address.
+	 /* receive the frames that ra(a1) is my address or ra(a1) is bc address. */
 		if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&
 			!_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))
 		{
@@ -610,7 +576,7 @@ void mgt_dispatcher(struct rtw_adapter *
 	struct mlme_handler *ptable;
 #ifdef CONFIG_AP_MODE
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-#endif //CONFIG_AP_MODE
+#endif /* CONFIG_AP_MODE */
 	u8 bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	struct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, GetAddr2Ptr(pframe));
@@ -625,7 +591,7 @@ void mgt_dispatcher(struct rtw_adapter *
 		return;
 	}
 
-	//receive the frames that ra(a1) is my address or ra(a1) is bc address.
+	/* receive the frames that ra(a1) is my address or ra(a1) is bc address. */
 	if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN) &&
 		!_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))
 	{
@@ -638,7 +604,7 @@ void mgt_dispatcher(struct rtw_adapter *
 
 #ifdef CONFIG_TDLS
 	if ((index << 4)==WIFI_ACTION) {
-		//category==RTW_WLAN_CATEGORY_PUBLIC, action==TDLS_DISCOVERY_RESPONSE
+		/* category==RTW_WLAN_CATEGORY_PUBLIC, action==TDLS_DISCOVERY_RESPONSE */
 		if (*(pframe + IEEE80211_MGMT_HDR_LEN) == RTW_WLAN_CATEGORY_PUBLIC
 			&& *(pframe + IEEE80211_MGMT_HDR_LEN + 1) == TDLS_DISCOVERY_RESPONSE)
 		{
@@ -646,7 +612,7 @@ void mgt_dispatcher(struct rtw_adapter *
 			On_TDLS_Dis_Rsp(padapter, precv_frame);
 		}
 	}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	if (index > 13)
 	{
@@ -677,7 +643,7 @@ void mgt_dispatcher(struct rtw_adapter *
 				ptable->func = &OnAuth;
 			else
 				ptable->func = &OnAuthClient;
-			//pass through
+			/* pass through */
 		case WIFI_ASSOCREQ:
 		case WIFI_REASSOCREQ:
 			_mgt_dispatcher(padapter, ptable, precv_frame);
@@ -702,7 +668,7 @@ void mgt_dispatcher(struct rtw_adapter *
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 			break;
 		case WIFI_ACTION:
-			//if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			/* if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) */
 			_mgt_dispatcher(padapter, ptable, precv_frame);
 			break;
 		default:
@@ -736,7 +702,7 @@ u32 p2p_listen_state_process(struct rtw_
 		response = false;
 	}
 #else
-	//	do nothing if the device name is empty
+	/* 	do nothing if the device name is empty */
 	if (!padapter->wdinfo.device_name_len)
 	{
 		response	= false;
@@ -748,7 +714,7 @@ u32 p2p_listen_state_process(struct rtw_
 
 	return _SUCCESS;
 }
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 
 /****************************************************************************
@@ -781,21 +747,21 @@ unsigned int OnProbeReq(struct rtw_adapt
 		!rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN)
 	  )
 	{
-		//	Commented by Albert 2011/03/17
-		//	mcs_rate = 0 -> CCK 1M rate
-		//	mcs_rate = 1 -> CCK 2M rate
-		//	mcs_rate = 2 -> CCK 5.5M rate
-		//	mcs_rate = 3 -> CCK 11M rate
-		//	In the P2P mode, the driver should not support the CCK rate
+		/* 	Commented by Albert 2011/03/17 */
+		/* 	mcs_rate = 0 -> CCK 1M rate */
+		/* 	mcs_rate = 1 -> CCK 2M rate */
+		/* 	mcs_rate = 2 -> CCK 5.5M rate */
+		/* 	mcs_rate = 3 -> CCK 11M rate */
+		/* 	In the P2P mode, the driver should not support the CCK rate */
 
-		//	Commented by Kurt 2012/10/16
-		//	IOT issue: Google Nexus7 use 1M rate to send p2p_probe_req after GO nego completed and Nexus7 is client
+		/* 	Commented by Kurt 2012/10/16 */
+		/* 	IOT issue: Google Nexus7 use 1M rate to send p2p_probe_req after GO nego completed and Nexus7 is client */
 #ifdef CONFIG_WIFI_TEST
 		if (pattrib->mcs_rate <= 3)
 		{
 			wifi_test_chk_rate = 0;
 		}
-#endif //CONFIG_WIFI_TEST
+#endif /* CONFIG_WIFI_TEST */
 
 		if (wifi_test_chk_rate == 1)
 		{
@@ -817,7 +783,7 @@ unsigned int OnProbeReq(struct rtw_adapt
 	}
 
 _continue:
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
 	{
@@ -830,14 +796,11 @@ _continue:
 		return _SUCCESS;
 	}
 
-
-	//DBG_8192D("+OnProbeReq\n");
-
 #ifdef CONFIG_CONCURRENT_MODE
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 		check_buddy_fwstate(padapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 	{
-		//don't process probe req
+		/* don't process probe req */
 		return _SUCCESS;
 	}
 #endif
@@ -846,7 +809,7 @@ _continue:
 			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
 
 
-	//check (wildcard) SSID
+	/* check (wildcard) SSID */
 	if (p != NULL)
 	{
 		if (is_valid_p2p_probereq == true)
@@ -866,7 +829,6 @@ _issue_probersp:
 		if (check_fwstate(pmlmepriv, _FW_LINKED) == true &&
 			pmlmepriv->cur_network.join_res == true)
 		{
-			//DBG_8192D("+issue_probersp during ap mode\n");
 			issue_probersp(padapter, get_sa(pframe), is_valid_p2p_probereq);
 		}
 
@@ -984,17 +946,17 @@ unsigned int OnBeacon(struct rtw_adapter
 	{
 		if (pmlmeinfo->state & WIFI_FW_AUTH_NULL)
 		{
-			//check the vendor of the assoc AP
+			/* check the vendor of the assoc AP */
 			pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct rtw_ieee80211_hdr_3addr), len-sizeof(struct rtw_ieee80211_hdr_3addr));
 #ifdef CONFIG_P2P_PS
-			// do P2P PS Before link ? , ToDo
-			//process_p2p_ps_ie(padapter, (pframe + WLAN_HDR_A3_LEN), (len - WLAN_HDR_A3_LEN));
-#endif // CONFIG_P2P_PS
+			/*  do P2P PS Before link ? , ToDo */
+			/* process_p2p_ps_ie(padapter, (pframe + WLAN_HDR_A3_LEN), (len - WLAN_HDR_A3_LEN)); */
+#endif /*  CONFIG_P2P_PS */
 
-			//update TSF Value
+			/* update TSF Value */
 			update_TSF(pmlmeext, pframe, len);
 
-			//start auth
+			/* start auth */
 			start_clnt_auth(padapter);
 
 			return _SUCCESS;
@@ -1005,58 +967,57 @@ unsigned int OnBeacon(struct rtw_adapter
 			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
 			{
 				#ifdef CONFIG_PATCH_JOIN_WRONG_CHANNEL
-				//Merge from 8712 FW code
+				/* Merge from 8712 FW code */
 				if (cmp_pkt_chnl_diff(padapter,pframe,len) != 0)
-				{            // join wrong channel, deauth and reconnect
+				{            /*  join wrong channel, deauth and reconnect */
 					issue_deauth(padapter, (&(pmlmeinfo->network))->MacAddress, WLAN_REASON_DEAUTH_LEAVING);
 
 					report_del_sta_event(padapter,(&(pmlmeinfo->network))->MacAddress, WLAN_REASON_JOIN_WRONG_CHANNEL);
 					pmlmeinfo->state &= (~WIFI_FW_ASSOC_SUCCESS);
 					return _SUCCESS;
 				}
-				#endif //CONFIG_PATCH_JOIN_WRONG_CHANNEL
+				#endif /* CONFIG_PATCH_JOIN_WRONG_CHANNEL */
 
-				//update WMM, ERP in the beacon
-				//todo: the timer is used instead of the number of the beacon received
+				/* update WMM, ERP in the beacon */
+				/* todo: the timer is used instead of the number of the beacon received */
 				if ((sta_rx_pkts(psta) & 0xf) == 0)
 				{
-					//DBG_8192D("update_bcn_info\n");
+					/* DBG_8192D("update_bcn_info\n"); */
 					update_beacon_info(padapter, pframe, len, psta);
 				}
 
 #ifdef CONFIG_DFS
-				process_csa_ie(padapter, pframe, len);	//channel switch announcement
-#endif //CONFIG_DFS
+				process_csa_ie(padapter, pframe, len);	/* channel switch announcement */
+#endif /* CONFIG_DFS */
 
 #ifdef CONFIG_P2P_PS
-				//if (psta->ieee8021x_blocked == false) // do not allow P2P PS during EAPOL handshake ?
 				process_p2p_ps_ie(padapter, (pframe + WLAN_HDR_A3_LEN), (len - WLAN_HDR_A3_LEN));
-#endif //CONFIG_P2P_PS
+#endif /* CONFIG_P2P_PS */
 
 			}
 		} else if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {
 			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL) {
-				//update WMM, ERP in the beacon
-				//todo: the timer is used instead of the number of the beacon received
+				/* update WMM, ERP in the beacon */
+				/* todo: the timer is used instead of the number of the beacon received */
 				if ((sta_rx_pkts(psta) & 0xf) == 0)
 					update_beacon_info(padapter, pframe, len, psta);
 
 			} else {
-				//allocate a new CAM entry for IBSS station
+				/* allocate a new CAM entry for IBSS station */
 				if ((cam_idx = allocate_fw_sta_entry(padapter)) == NUM_STA)
 					goto _END_ONBEACON_;
 
-				//get supported rate
+				/* get supported rate */
 				if (update_sta_support_rate(padapter, (pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_), (len - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_), cam_idx) == _FAIL)
 				{
 					pmlmeinfo->FW_sta_info[cam_idx].status = 0;
 					goto _END_ONBEACON_;
 				}
 
-				//update TSF Value
+				/* update TSF Value */
 				update_TSF(pmlmeext, pframe, len);
 
-				//report sta add event
+				/* report sta add event */
 				report_add_sta_event(padapter, GetAddr2Ptr(pframe), cam_idx);
 			}
 		}
@@ -1088,10 +1049,10 @@ unsigned int OnAuth(struct rtw_adapter *
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 		check_buddy_fwstate(padapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 	{
-		//don't process auth request;
+		/* don't process auth request; */
 		return _SUCCESS;
 	}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		return _FAIL;
@@ -1116,8 +1077,8 @@ unsigned int OnAuth(struct rtw_adapter *
 			psecuritypriv->dot11PrivacyAlgrthm != _WEP104_)
 		auth_mode = 0;
 
-	if ((algorithm > 0 && auth_mode == 0) ||	// rx a shared-key auth but shared not enabled
-		(algorithm == 0 && auth_mode == 1))	// rx a open-system auth but shared-key is enabled
+	if ((algorithm > 0 && auth_mode == 0) ||	/*  rx a shared-key auth but shared not enabled */
+		(algorithm == 0 && auth_mode == 1))	/*  rx a open-system auth but shared-key is enabled */
 	{
 		DBG_8192D("auth rejected due to bad alg [alg=%d, auth_mib=%d] %02X%02X%02X%02X%02X%02X\n",
 			algorithm, auth_mode, sa[0], sa[1], sa[2], sa[3], sa[4], sa[5]);
@@ -1134,7 +1095,7 @@ unsigned int OnAuth(struct rtw_adapter *
 
 	pstat = rtw_get_stainfo(pstapriv, sa);
 	if (pstat == NULL) {
-		// allocate a new one
+		/*  allocate a new one */
 		DBG_8192D("going to alloc stainfo for sa=%pM\n",  sa);
 		pstat = rtw_alloc_stainfo(pstapriv, sa);
 		if (pstat == NULL)
@@ -1153,13 +1114,13 @@ unsigned int OnAuth(struct rtw_adapter *
 			pstapriv->asoc_list_cnt--;
 			if (pstat->expire_to > 0)
 			{
-				//TODO: STA re_auth within expire_to
+				/* TODO: STA re_auth within expire_to */
 			}
 		}
 		spin_unlock_bh(&pstapriv->asoc_list_lock);
 
 		if (seq==1) {
-			//TODO: STA re_auth and auth timeout
+			/* TODO: STA re_auth and auth timeout */
 		}
 	}
 
@@ -1199,14 +1160,11 @@ unsigned int OnAuth(struct rtw_adapter *
 			goto auth_fail;
 		}
 	}
-	else // shared system or auto authentication
+	else /*  shared system or auto authentication */
 	{
 		if (seq == 1)
 		{
-			//prepare for the challenging txt...
-
-			//get_random_bytes((void *)pstat->chg_txt, 128);//TODO:
-
+			/* prepare for the challenging txt... */
 			pstat->state &= ~WIFI_FW_AUTH_NULL;
 			pstat->state |= WIFI_FW_AUTH_STATE;
 			pstat->authalg = algorithm;
@@ -1214,7 +1172,7 @@ unsigned int OnAuth(struct rtw_adapter *
 		}
 		else if (seq == 3)
 		{
-			//checking for challenging txt...
+			/* checking for challenging txt... */
 			DBG_8192D("checking for challenging txt...\n");
 
 			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + 4 + _AUTH_IE_OFFSET_ , _CHLGETXT_IE_, (int *)&ie_len,
@@ -1231,7 +1189,7 @@ unsigned int OnAuth(struct rtw_adapter *
 			{
 				pstat->state &= (~WIFI_FW_AUTH_STATE);
 				pstat->state |= WIFI_FW_AUTH_SUCCESS;
-				// challenging txt is correct...
+				/*  challenging txt is correct... */
 				pstat->expire_to =  pstapriv->assoc_to;
 			}
 			else
@@ -1251,7 +1209,7 @@ unsigned int OnAuth(struct rtw_adapter *
 	}
 
 
-	// Now, we are going to issue_auth...
+	/*  Now, we are going to issue_auth... */
 	pstat->auth_seq = seq + 1;
 
 #ifdef CONFIG_NATIVEAP_MLME
@@ -1294,7 +1252,7 @@ unsigned int OnAuthClient(struct rtw_ada
 
 	DBG_8192D("%s\n", __func__);
 
-	//check A1 matches or not
+	/* check A1 matches or not */
 	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))
 		return _SUCCESS;
 
@@ -1310,13 +1268,12 @@ unsigned int OnAuthClient(struct rtw_ada
 	if (status != 0)
 	{
 		DBG_8192D("clnt auth fail, status: %d\n", status);
-		if (status == 13)//&& pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto)
+		if (status == 13)/*  pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto) */
 		{
 			if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
 				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;
 			else
 				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;
-			//pmlmeinfo->reauth_count = 0;
 		}
 
 		set_link_timer(pmlmeext, 1);
@@ -1327,15 +1284,12 @@ unsigned int OnAuthClient(struct rtw_ada
 	{
 		if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
 		{
-			 // legendary shared system
+			 /*  legendary shared system */
 			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _AUTH_IE_OFFSET_, _CHLGETXT_IE_, (int *)&len,
 				pkt_len - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_);
 
 			if (p == NULL)
-			{
-				//DBG_8192D("marc: no challenge text?\n");
 				goto authclnt_fail;
-			}
 
 			memcpy((void *)(pmlmeinfo->chg_txt), (void *)(p + 2), len);
 			pmlmeinfo->auth_seq = 3;
@@ -1346,7 +1300,7 @@ unsigned int OnAuthClient(struct rtw_ada
 		}
 		else
 		{
-			// open system
+			/*  open system */
 			go2asoc = 1;
 		}
 	}
@@ -1363,8 +1317,7 @@ unsigned int OnAuthClient(struct rtw_ada
 	}
 	else
 	{
-		// this is also illegal
-		//DBG_8192D("marc: clnt auth failed due to illegal seq=%x\n", seq);
+		/*  this is also illegal */
 		goto authclnt_fail;
 	}
 
@@ -1376,8 +1329,6 @@ unsigned int OnAuthClient(struct rtw_ada
 
 authclnt_fail:
 
-	//pmlmeinfo->state &= ~(WIFI_FW_AUTH_STATE);
-
 	return _FAIL;
 }
 
@@ -1410,17 +1361,17 @@ unsigned int OnAssocReq(struct rtw_adapt
 #ifdef CONFIG_WFD
 	u8	wfd_ie[ 128 ] = { 0x00 };
 	u32	wfd_ielen = 0;
-#endif // CONFIG_WFD
-#endif //CONFIG_P2P
+#endif /*  CONFIG_WFD */
+#endif /* CONFIG_P2P */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 		check_buddy_fwstate(padapter, _FW_UNDER_LINKING|_FW_UNDER_SURVEY))
 	{
-		//don't process assoc request;
+		/* don't process assoc request; */
 		return _SUCCESS;
 	}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
 		return _FAIL;
@@ -1431,7 +1382,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 		reassoc = 0;
 		ie_offset = _ASOCREQ_IE_OFFSET_;
 	}
-	else // WIFI_REASSOCREQ
+	else /*  WIFI_REASSOCREQ */
 	{
 		reassoc = 1;
 		ie_offset = _REASOCREQ_IE_OFFSET_;
@@ -1452,8 +1403,6 @@ unsigned int OnAssocReq(struct rtw_adapt
 	}
 
 	capab_info = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN);
-	//capab_info = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
-	//listen_interval = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN+2));
 	listen_interval = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN+2);
 
 	left = pkt_len - (IEEE80211_3ADDR_LEN + ie_offset);
@@ -1462,7 +1411,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 	DBG_8192D("%s\n", __func__);
 
-	// check if this stat has been successfully authenticated/assocated
+	/*  check if this stat has been successfully authenticated/assocated */
 	if (!((pstat->state) & WIFI_FW_AUTH_SUCCESS))
 	{
 		if (!((pstat->state) & WIFI_FW_ASSOC_SUCCESS))
@@ -1484,7 +1433,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 	pstat->capability = capab_info;
 
-	//now parse all ieee802_11 ie to point to elems
+	/* now parse all ieee802_11 ie to point to elems */
 	if (rtw_ieee802_11_parse_elems(pos, left, &elems, 1) == PARSE_FAIL ||
 	    !elems.ssid) {
 		DBG_8192D("STA %pM sent invalid association request\n",
@@ -1494,8 +1443,8 @@ unsigned int OnAssocReq(struct rtw_adapt
 	}
 
 
-	// now we should check all the fields...
-	// checking SSID
+	/*  now we should check all the fields... */
+	/*  checking SSID */
 	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _SSID_IE_, &ie_len,
 		pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 	if (p == NULL)
@@ -1503,11 +1452,11 @@ unsigned int OnAssocReq(struct rtw_adapt
 		status = _STATS_FAILURE_;
 	}
 
-	if (ie_len == 0) // broadcast ssid, however it is not allowed in assocreq
+	if (ie_len == 0) /*  broadcast ssid, however it is not allowed in assocreq */
 		status = _STATS_FAILURE_;
 	else
 	{
-		// check if ssid match
+		/*  check if ssid match */
 		if (!_rtw_memcmp((void *)(p+2), cur->Ssid.Ssid, cur->Ssid.SsidLength))
 			status = _STATS_FAILURE_;
 
@@ -1518,13 +1467,13 @@ unsigned int OnAssocReq(struct rtw_adapt
 	if (_STATS_SUCCESSFUL_ != status)
 		goto OnAssocReqFail;
 
-	// check if the supported rate is ok
+	/*  check if the supported rate is ok */
 	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _SUPPORTEDRATES_IE_, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);
 	if (p == NULL) {
 		DBG_8192D("Rx a sta assoc-req which supported rate is empty!\n");
-		// use our own rate set as statoin used
-		//memcpy(supportRate, AP_BSSRATE, AP_BSSRATE_LEN);
-		//supportRateNum = AP_BSSRATE_LEN;
+		/*  use our own rate set as statoin used */
+		/* memcpy(supportRate, AP_BSSRATE, AP_BSSRATE_LEN); */
+		/* supportRateNum = AP_BSSRATE_LEN; */
 
 		status = _STATS_FAILURE_;
 		goto OnAssocReqFail;
@@ -1544,15 +1493,15 @@ unsigned int OnAssocReq(struct rtw_adapt
 		}
 	}
 
-	//todo: mask supportRate between AP & STA -> move to update raid
-	//get_matched_rate(pmlmeext, supportRate, &supportRateNum, 0);
+	/* todo: mask supportRate between AP & STA -> move to update raid */
+	/* get_matched_rate(pmlmeext, supportRate, &supportRateNum, 0); */
 
-	//update station supportRate
+	/* update station supportRate */
 	pstat->bssratelen = supportRateNum;
 	memcpy(pstat->bssrateset, supportRate, supportRateNum);
 
 
-	//check RSN/WPA/WPS
+	/* check RSN/WPA/WPS */
 	pstat->dot8021xalg = 0;
 	pstat->wpa_psk = 0;
 	pstat->wpa_group_cipher = 0;
@@ -1568,7 +1517,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 		if (rtw_parse_wpa2_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
-			pstat->dot8021xalg = 1;//psk,  todo:802.1x
+			pstat->dot8021xalg = 1;/* psk,  todo:802.1x */
 			pstat->wpa_psk |= BIT(1);
 
 			pstat->wpa2_group_cipher = group_cipher&psecuritypriv->wpa2_group_cipher;
@@ -1593,7 +1542,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 
 		if (rtw_parse_wpa_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher) == _SUCCESS)
 		{
-			pstat->dot8021xalg = 1;//psk,  todo:802.1x
+			pstat->dot8021xalg = 1;/* psk,  todo:802.1x */
 			pstat->wpa_psk |= BIT(0);
 
 			pstat->wpa_group_cipher = group_cipher&psecuritypriv->wpa_group_cipher;
@@ -1620,16 +1569,15 @@ unsigned int OnAssocReq(struct rtw_adapt
 		goto OnAssocReqFail;
 
 	pstat->flags &= ~(WLAN_STA_WPS | WLAN_STA_MAYBE_WPS);
-	//if (hapd->conf->wps_state && wpa_ie == NULL) { //todo: to check ap if supporting WPS
 	if (wpa_ie == NULL) {
 		if (elems.wps_ie) {
 			DBG_8192D("STA included WPS IE in "
 				   "(Re)Association Request - assume WPS is "
 				   "used\n");
 			pstat->flags |= WLAN_STA_WPS;
-			//wpabuf_free(sta->wps_ie);
-			//sta->wps_ie = wpabuf_alloc_copy(elems.wps_ie + 4,
-			//				elems.wps_ie_len - 4);
+			/* wpabuf_free(sta->wps_ie); */
+			/* sta->wps_ie = wpabuf_alloc_copy(elems.wps_ie + 4, */
+			/* 				elems.wps_ie_len - 4); */
 		} else {
 			DBG_8192D("STA did not include WPA/RSN IE "
 				   "in (Re)Association Request - possible WPS "
@@ -1638,8 +1586,8 @@ unsigned int OnAssocReq(struct rtw_adapt
 		}
 
 
-		// AP support WPA/RSN, and sta is going to do WPS, but AP is not ready
-		// that the selected registrar of AP is _FLASE
+		/*  AP support WPA/RSN, and sta is going to do WPS, but AP is not ready */
+		/*  that the selected registrar of AP is _FLASE */
 		if ((psecuritypriv->wpa_psk >0)
 			&& (pstat->flags & (WLAN_STA_WPS|WLAN_STA_MAYBE_WPS)))
 		{
@@ -1695,7 +1643,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 	}
 
 
-	// check if there is WMM IE & support WWM-PS
+	/*  check if there is WMM IE & support WWM-PS */
 	pstat->flags &= ~WLAN_STA_WME;
 	pstat->qos_option = 0;
 	pstat->qos_info = 0;
@@ -1788,13 +1736,11 @@ unsigned int OnAssocReq(struct rtw_adapt
 		DBG_8192D("HT: %pM tried to use TKIP with HT association\n",
 			 pstat->hwaddr);
 
-		//status = WLAN_STATUS_CIPHER_REJECTED_PER_POLICY;
-		//goto OnAssocReqFail;
+		/* status = WLAN_STATUS_CIPHER_REJECTED_PER_POLICY; */
+		/* goto OnAssocReqFail; */
 	}
 #endif /* CONFIG_80211N_HT */
 
-       //
-       //if (hapd->iface->current_mode->mode == HOSTAPD_MODE_IEEE80211G)//?
 	pstat->flags |= WLAN_STA_NONERP;
 	for (i = 0; i < pstat->bssratelen; i++) {
 		if ((pstat->bssrateset[i] & 0x7f) > 22) {
@@ -1844,13 +1790,13 @@ unsigned int OnAssocReq(struct rtw_adapt
 #endif
 	}
 	pstat->p2p_status_code = p2p_status_code;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
-	//TODO: identify_proprietary_vendor_ie();
-	// Realtek proprietary IE
-	// identify if this is Broadcom sta
-	// identify if this is ralink sta
-	// Customer proprietary IE
+	/* TODO: identify_proprietary_vendor_ie(); */
+	/*  Realtek proprietary IE */
+	/*  identify if this is Broadcom sta */
+	/*  identify if this is ralink sta */
+	/*  Customer proprietary IE */
 
 
 
@@ -1862,7 +1808,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 			if (pstapriv->sta_aid[pstat->aid - 1] == NULL)
 				break;
 
-		//if (pstat->aid > NUM_STA) {
+		/* if (pstat->aid > NUM_STA) { */
 		if (pstat->aid > pstapriv->max_num_sta) {
 			pstat->aid = 0;
 
@@ -1900,21 +1846,21 @@ unsigned int OnAssocReq(struct rtw_adapt
 	}
 	spin_unlock_bh(&pstapriv->asoc_list_lock);
 
-	// now the station is qualified to join our BSS...
+	/*  now the station is qualified to join our BSS... */
 	if (pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) && (_STATS_SUCCESSFUL_==status))
 	{
 #ifdef CONFIG_NATIVEAP_MLME
-		//.1 bss_cap_update & sta_info_update
+		/* 1 bss_cap_update & sta_info_update */
 		bss_cap_update_on_sta_join(padapter, pstat);
 		sta_info_update(padapter, pstat);
 
-		//issue assoc rsp before notify station join event.
+		/* issue assoc rsp before notify station join event. */
 		if (frame_type == WIFI_ASSOCREQ)
 			issue_asocrsp(padapter, status, pstat, WIFI_ASSOCRSP);
 		else
 			issue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);
 
-		//.2 - report to upper layer
+		/* 2 - report to upper layer */
 		DBG_8192D("indicate_sta_join_event to upper layer - hostapd\n");
 		#ifdef CONFIG_IOCTL_CFG80211
 		if (1) {
@@ -1922,7 +1868,7 @@ unsigned int OnAssocReq(struct rtw_adapt
 			rtw_cfg80211_indicate_sta_assoc(padapter, pframe, pkt_len);
 			#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
 			rtw_cfg80211_indicate_sta_assoc(padapter, pframe, pkt_len);
-			#else //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+			#else /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
 			spin_lock_bh(&pstat->lock);
 			kfree(pstat->passoc_req);
 			pstat->passoc_req = NULL;
@@ -1934,25 +1880,17 @@ unsigned int OnAssocReq(struct rtw_adapt
 				pstat->assoc_req_len = pkt_len;
 			}
 			spin_unlock_bh(&pstat->lock);
-			#endif //(LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER)
+			#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) && !defined(CONFIG_CFG80211_FORCE_COMPATIBLE_2_6_37_UNDER) */
 		}
 		else
-		#endif //CONFIG_IOCTL_CFG80211
+		#endif /* CONFIG_IOCTL_CFG80211 */
 		{
 			rtw_indicate_sta_assoc_event(padapter, pstat);
 		}
 
-		//.3-(1) report sta add event
+		/* 3-(1) report sta add event */
 		report_add_sta_event(padapter, pstat->hwaddr, pstat->aid);
 
-/*
-		//issue assoc rsp before notify station join event.
-		if (frame_type == WIFI_ASSOCREQ)
-			issue_asocrsp(padapter, status, pstat, WIFI_ASSOCRSP);
-		else
-			issue_asocrsp(padapter, status, pstat, WIFI_REASSOCRSP);
-*/
-
 #endif
 	}
 
@@ -1992,13 +1930,13 @@ unsigned int OnAssocRsp(struct rtw_adapt
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
-	//struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
+	/* struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network); */
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	uint pkt_len = precv_frame->u.hdr.len;
 
 	DBG_8192D("%s\n", __func__);
 
-	//check A1 matches or not
+	/* check A1 matches or not */
 	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))
 		return _SUCCESS;
 
@@ -2010,7 +1948,7 @@ unsigned int OnAssocRsp(struct rtw_adapt
 
 	_cancel_timer_ex(&pmlmeext->link_timer);
 
-	//status
+	/* status */
 	if ((status = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 2))) > 0)
 	{
 		DBG_8192D("assoc reject, status code: %d\n", status);
@@ -2019,18 +1957,18 @@ unsigned int OnAssocRsp(struct rtw_adapt
 		goto report_assoc_result;
 	}
 
-	//get capabilities
+	/* get capabilities */
 	pmlmeinfo->capability = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
 
-	//set slot time
+	/* set slot time */
 	pmlmeinfo->slotTime = (pmlmeinfo->capability & BIT(10))? 9: 20;
 
-	//AID
+	/* AID */
 	res = pmlmeinfo->aid = (int)(le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 4))&0x3fff);
 
-	//following are moved to join event callback function
-	//to handle HT, WMM, rate adaptive, update MAC reg
-	//for not to handle the synchronous IO in the tasklet
+	/* following are moved to join event callback function */
+	/* to handle HT, WMM, rate adaptive, update MAC reg */
+	/* for not to handle the synchronous IO in the tasklet */
 	for (i = (6 + WLAN_HDR_A3_LEN); i < pkt_len;)
 	{
 		pIE = (struct ndis_802_11_variable_ies *)(pframe + i);
@@ -2038,12 +1976,12 @@ unsigned int OnAssocRsp(struct rtw_adapt
 		switch (pIE->ElementID)
 		{
 			case _VENDOR_SPECIFIC_IE_:
-				if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6))	//WMM
+				if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6))	/* WMM */
 				{
 					WMM_param_handler(padapter, pIE);
 				}
 #if defined(CONFIG_P2P) && defined(CONFIG_WFD)
-				else if (_rtw_memcmp(pIE->data, WFD_OUI, 4))		//WFD
+				else if (_rtw_memcmp(pIE->data, WFD_OUI, 4))		/* WFD */
 				{
 					DBG_8192D("[%s] Found WFD IE\n", __func__);
 					WFD_info_handler(padapter, pIE);
@@ -2051,11 +1989,11 @@ unsigned int OnAssocRsp(struct rtw_adapt
 #endif
 				break;
 
-			case _HT_CAPABILITY_IE_:	//HT caps
+			case _HT_CAPABILITY_IE_:	/* HT caps */
 				HT_caps_handler(padapter, pIE);
 				break;
 
-			case _HT_EXTRA_INFO_IE_:	//HT info
+			case _HT_EXTRA_INFO_IE_:	/* HT info */
 				HT_info_handler(padapter, pIE);
 				break;
 
@@ -2072,7 +2010,7 @@ unsigned int OnAssocRsp(struct rtw_adapt
 	pmlmeinfo->state &= (~WIFI_FW_ASSOC_STATE);
 	pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
 
-	//Update Basic Rate Table for spec, 2010-12-28 , by thomas
+	/* Update Basic Rate Table for spec, 2010-12-28 , by thomas */
 	UpdateBrateTbl(padapter, pmlmeinfo->network.SupportedRates);
 
 report_assoc_result:
@@ -2096,9 +2034,9 @@ unsigned int OnDeAuth(struct rtw_adapter
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
-	//check A3
+	/* check A3 */
 	if (!(_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
 		return _SUCCESS;
 
@@ -2108,7 +2046,7 @@ unsigned int OnDeAuth(struct rtw_adapter
 		_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
 		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
 
@@ -2163,9 +2101,9 @@ unsigned int OnDisassoc(struct rtw_adapt
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
-	//check A3
+	/* check A3 */
 	if (!(_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
 		return _SUCCESS;
 
@@ -2175,7 +2113,7 @@ unsigned int OnDisassoc(struct rtw_adapt
 		_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
 		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
 
@@ -2349,15 +2287,10 @@ unsigned int OnAction_back(struct rtw_ad
 	u8 *pframe = precv_frame->u.hdr.rx_data;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	//check RA matches or not
-	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))//for if1, sta/ap mode
+	/* check RA matches or not */
+	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))/* for if1, sta/ap mode */
 		return _SUCCESS;
 
-/*
-	//check A1 matches or not
-	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), get_da(pframe), ETH_ALEN))
-		return _SUCCESS;
-*/
 	DBG_8192D("%s\n", __func__);
 
 	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
@@ -2373,17 +2306,17 @@ unsigned int OnAction_back(struct rtw_ad
 	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
 
 	category = frame_body[0];
-	if (category == RTW_WLAN_CATEGORY_BACK)// representing Block Ack
+	if (category == RTW_WLAN_CATEGORY_BACK)/*  representing Block Ack */
 	{
 #ifdef CONFIG_TDLS
 		if ((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
 			(psta->htpriv.ht_option==true) &&
 			(psta->htpriv.ampdu_enable==true))
 		{
-			//do nothing; just don't want to return _SUCCESS;
+			/* do nothing; just don't want to return _SUCCESS; */
 		}
 		else
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 		if (!pmlmeinfo->HT_enable)
 		{
 			return _SUCCESS;
@@ -2393,10 +2326,10 @@ unsigned int OnAction_back(struct rtw_ad
 		DBG_8192D("%s, action=%d\n", __func__, action);
 		switch (action)
 		{
-			case RTW_WLAN_ACTION_ADDBA_REQ: //ADDBA request
+			case RTW_WLAN_ACTION_ADDBA_REQ: /* ADDBA request */
 
 				memcpy(&(pmlmeinfo->ADDBA_req), &(frame_body[2]), sizeof(struct ADDBA_request));
-				//process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe));
+				/* process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe)); */
 				process_addba_req(padapter, (u8*)&(pmlmeinfo->ADDBA_req), addr);
 
 				if (pmlmeinfo->bAcceptAddbaReq == true)
@@ -2405,19 +2338,18 @@ unsigned int OnAction_back(struct rtw_ad
 				}
 				else
 				{
-					issue_action_BA(padapter, addr, RTW_WLAN_ACTION_ADDBA_RESP, 37);//reject ADDBA Req
+					issue_action_BA(padapter, addr, RTW_WLAN_ACTION_ADDBA_RESP, 37);/* reject ADDBA Req */
 				}
 
 				break;
 
-			case RTW_WLAN_ACTION_ADDBA_RESP: //ADDBA response
+			case RTW_WLAN_ACTION_ADDBA_RESP: /* ADDBA response */
 
-				//status = frame_body[3] | (frame_body[4] << 8); //endian issue
 				status = RTW_GET_LE16(&frame_body[3]);
 				tid = ((frame_body[5] >> 2) & 0x7);
 
 				if (status == 0)
-				{	//successful
+				{	/* successful */
 					DBG_8192D("agg_enable for TID=%d\n", tid);
 					psta->htpriv.agg_enable_bitmap |= 1 << tid;
 					psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
@@ -2427,16 +2359,16 @@ unsigned int OnAction_back(struct rtw_ad
 					psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
 				}
 
-				//DBG_8192D("marc: ADDBA RSP: %x\n", pmlmeinfo->agg_enable_bitmap);
+				/* DBG_8192D("marc: ADDBA RSP: %x\n", pmlmeinfo->agg_enable_bitmap); */
 				break;
 
-			case RTW_WLAN_ACTION_DELBA: //DELBA
+			case RTW_WLAN_ACTION_DELBA: /* DELBA */
 				if ((frame_body[3] & BIT(3)) == 0)
 				{
 					psta->htpriv.agg_enable_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));
 					psta->htpriv.candidate_tid_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));
 
-					//reason_code = frame_body[4] | (frame_body[5] << 8);
+					/* reason_code = frame_body[4] | (frame_body[5] << 8); */
 					reason_code = RTW_GET_LE16(&frame_body[4]);
 				}
 				else if ((frame_body[3] & BIT(3)) == BIT(3))
@@ -2453,7 +2385,7 @@ unsigned int OnAction_back(struct rtw_ad
 				}
 
 				DBG_8192D("%s(): DELBA: %x(%x)\n", __func__,pmlmeinfo->agg_enable_bitmap, reason_code);
-				//todo: how to notify the host while receiving DELETE BA
+				/* todo: how to notify the host while receiving DELETE BA */
 				break;
 
 			default:
@@ -2493,12 +2425,12 @@ static void get_channel_cnt_24g_5gl_5gh(
 		}
 		else if ((pmlmeext->channel_set[ i ].ChannelNum > 14) && (pmlmeext->channel_set[ i ].ChannelNum <= 48))
 		{
-			//	Just include the channel 36, 40, 44, 48 channels for 5G low
+			/* 	Just include the channel 36, 40, 44, 48 channels for 5G low */
 			(*p5gl_cnt)++;
 		}
 		else if ((pmlmeext->channel_set[ i ].ChannelNum >= 149) && (pmlmeext->channel_set[ i ].ChannelNum <= 161))
 		{
-			//	Just include the channel 149, 153, 157, 161 channels for 5G high
+			/* 	Just include the channel 149, 153, 157, 161 channels for 5G high */
 			(*p5gh_cnt)++;
 		}
 	}
@@ -2516,7 +2448,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	u16			len_channellist_attr = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
@@ -2535,7 +2467,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	}
 
 	DBG_8192D("[%s] In\n", __func__);
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -2562,39 +2494,39 @@ void issue_p2p_GO_request(struct rtw_ada
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pwdinfo->negotiation_dialog_token = 1;	//	Initialize the dialog value
+	pwdinfo->negotiation_dialog_token = 1;	/* 	Initialize the dialog value */
 	pframe = rtw_set_fixed_ie(pframe, 1, &pwdinfo->negotiation_dialog_token, &(pattrib->pktlen));
 
 
 
-	//	WPS Section
+	/* 	WPS Section */
 	wpsielen = 0;
-	//	WPS OUI
+	/* 	WPS OUI */
 	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
-	//	WPS version
-	//	Type:
+	/* 	WPS version */
+	/* 	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
-	//	Value:
-	wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+	/* 	Value: */
+	wpsie[wpsielen++] = WPS_VERSION_1;	/* 	Version 1.0 */
 
-	//	Device Password ID
-	//	Type:
+	/* 	Device Password ID */
+	/* 	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 	wpsielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
-	//	Value:
+	/* 	Value: */
 
 	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN)
 	{
@@ -2614,41 +2546,41 @@ void issue_p2p_GO_request(struct rtw_ada
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 
-	//	P2P IE Section.
+	/* 	P2P IE Section. */
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//	Commented by Albert 20110306
-	//	According to the P2P Specification, the group negoitation request frame should contain 9 P2P attributes
-	//	1. P2P Capability
-	//	2. Group Owner Intent
-	//	3. Configuration Timeout
-	//	4. Listen Channel
-	//	5. Extended Listen Timing
-	//	6. Intended P2P Interface Address
-	//	7. Channel List
-	//	8. P2P Device Info
-	//	9. Operating Channel
+	/* 	Commented by Albert 20110306 */
+	/* 	According to the P2P Specification, the group negoitation request frame should contain 9 P2P attributes */
+	/* 	1. P2P Capability */
+	/* 	2. Group Owner Intent */
+	/* 	3. Configuration Timeout */
+	/* 	4. Listen Channel */
+	/* 	5. Extended Listen Timing */
+	/* 	6. Intended P2P Interface Address */
+	/* 	7. Channel List */
+	/* 	8. P2P Device Info */
+	/* 	9. Operating Channel */
 
 
-	//	P2P Capability
-	//	Type:
+	/* 	P2P Capability */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	//	Device Capability Bitmap, 1 byte
+	/* 	Value: */
+	/* 	Device Capability Bitmap, 1 byte */
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
-	//	Group Capability Bitmap, 1 byte
+	/* 	Group Capability Bitmap, 1 byte */
 	if (pwdinfo->persistent_supported)
 	{
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
@@ -2659,94 +2591,94 @@ void issue_p2p_GO_request(struct rtw_ada
 	}
 
 
-	//	Group Owner Intent
-	//	Type:
+	/* 	Group Owner Intent */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_GO_INTENT;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
-	//	Value:
-	//	Todo the tie breaker bit.
+	/* 	Value: */
+	/* 	Todo the tie breaker bit. */
 	p2pie[ p2pielen++ ] = ((pwdinfo->intent << 1) | BIT(0));
 
-	//	Configuration Timeout
-	//	Type:
+	/* 	Configuration Timeout */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P GO
-	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P Client
+	/* 	Value: */
+	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P GO */
+	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P Client */
 
 
-	//	Listen Channel
-	//	Type:
+	/* 	Listen Channel */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_LISTEN_CH;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
-	//	Value:
-	//	Country String
+	/* 	Value: */
+	/* 	Country String */
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
 
-	//	The third byte should be set to 0x04.
-	//	Described in the "Operating Channel Attribute" section.
+	/* 	The third byte should be set to 0x04. */
+	/* 	Described in the "Operating Channel Attribute" section. */
 	p2pie[ p2pielen++ ] = 0x04;
 
-	//	Operating Class
-	p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
+	/* 	Operating Class */
+	p2pie[ p2pielen++ ] = 0x51;	/* 	Copy from SD7 */
 
-	//	Channel Number
-	p2pie[ p2pielen++ ] = pwdinfo->listen_channel;	//	listening channel number
+	/* 	Channel Number */
+	p2pie[ p2pielen++ ] = pwdinfo->listen_channel;	/* 	listening channel number */
 
 
-	//	Extended Listen Timing ATTR
-	//	Type:
+	/* 	Extended Listen Timing ATTR */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
 	p2pielen += 2;
 
-	//	Value:
-	//	Availability Period
+	/* 	Value: */
+	/* 	Availability Period */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 	p2pielen += 2;
 
-	//	Availability Interval
+	/* 	Availability Interval */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 	p2pielen += 2;
 
 
-	//	Intended P2P Interface Address
-	//	Type:
+	/* 	Intended P2P Interface Address */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_INTENTED_IF_ADDR;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
 
-	//	Channel List
-	//	Type:
+	/* 	Channel List */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
 
-	// Length:
-	// Country String(3)
-	// + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?)
-	// + number of channels in all classes
+	/*  Length: */
+	/*  Country String(3) */
+	/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
+	/*  + number of channels in all classes */
 	len_channellist_attr = 3
 	   + (1 + 1) * (u16)(pmlmeext->channel_list.reg_classes)
 	   + get_reg_classes_full_count(pmlmeext->channel_list);
@@ -2767,16 +2699,16 @@ void issue_p2p_GO_request(struct rtw_ada
 #endif
 	p2pielen += 2;
 
-	//	Value:
-	//	Country String
+	/* 	Value: */
+	/* 	Country String */
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
 
-	//	The third byte should be set to 0x04.
-	//	Described in the "Operating Channel Attribute" section.
+	/* 	The third byte should be set to 0x04. */
+	/* 	Described in the "Operating Channel Attribute" section. */
 	p2pie[ p2pielen++ ] = 0x04;
 
-	//	Channel Entry List
+	/* 	Channel Entry List */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_LINKED))
@@ -2784,7 +2716,7 @@ void issue_p2p_GO_request(struct rtw_ada
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-		//	Operating Class
+		/* 	Operating Class */
 		if (pbuddy_mlmeext->cur_channel > 14)
 		{
 			if (pbuddy_mlmeext->cur_channel >= 149)
@@ -2801,135 +2733,135 @@ void issue_p2p_GO_request(struct rtw_ada
 			p2pie[ p2pielen++ ] = 0x51;
 		}
 
-		//	Number of Channels
-		//	Just support 1 channel and this channel is AP's channel
+		/* 	Number of Channels */
+		/* 	Just support 1 channel and this channel is AP's channel */
 		p2pie[ p2pielen++ ] = 1;
 
-		//	Channel List
+		/* 	Channel List */
 		p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
 	}
 	else
 	{
 		int i,j;
 		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
 
-			//	Number of Channels
+			/* 	Number of Channels */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
 
-			//	Channel List
+			/* 	Channel List */
 			for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
 			}
 		}
 	}
-#else // CONFIG_CONCURRENT_MODE
+#else /*  CONFIG_CONCURRENT_MODE */
 	{
 		int i,j;
 		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
 
-			//	Number of Channels
+			/* 	Number of Channels */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
 
-			//	Channel List
+			/* 	Channel List */
 			for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
 			}
 		}
 	}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
-	//	Device Info
-	//	Type:
+	/* 	Device Info */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
-	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
+	/* 	Length: */
+	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
+	/* 	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
-	//	P2P Device Address
+	/* 	Value: */
+	/* 	P2P Device Address */
 	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
-	//	Config Method
-	//	This field should be big endian. Noted by P2P specification.
+	/* 	Config Method */
+	/* 	This field should be big endian. Noted by P2P specification. */
 
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 
 	p2pielen += 2;
 
-	//	Primary Device Type
-	//	Category ID
+	/* 	Primary Device Type */
+	/* 	Category ID */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
-	//	OUI
+	/* 	OUI */
 	*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
-	//	Sub Category ID
+	/* 	Sub Category ID */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
-	//	Number of Secondary Device Types
-	p2pie[ p2pielen++ ] = 0x00;	//	No Secondary Device Type List
+	/* 	Number of Secondary Device Types */
+	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
 
-	//	Device Name
-	//	Type:
+	/* 	Device Name */
+	/* 	Type: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
 
-	//	Operating Channel
-	//	Type:
+	/* 	Operating Channel */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
-	//	Value:
-	//	Country String
+	/* 	Value: */
+	/* 	Country String */
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
 
-	//	The third byte should be set to 0x04.
-	//	Described in the "Operating Channel Attribute" section.
+	/* 	The third byte should be set to 0x04. */
+	/* 	Described in the "Operating Channel Attribute" section. */
 	p2pie[ p2pielen++ ] = 0x04;
 
-	//	Operating Class
+	/* 	Operating Class */
 	if (pwdinfo->operating_channel <= 14)
 	{
-		//	Operating Class
+		/* 	Operating Class */
 		p2pie[ p2pielen++ ] = 0x51;
 	}
 	else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 	{
-		//	Operating Class
+		/* 	Operating Class */
 		p2pie[ p2pielen++ ] = 0x73;
 	}
 	else
 	{
-		//	Operating Class
+		/* 	Operating Class */
 		p2pie[ p2pielen++ ] = 0x7c;
 	}
 
-	//	Channel Number
-	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
+	/* 	Channel Number */
+	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	/* 	operating channel number */
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
@@ -2937,7 +2869,7 @@ void issue_p2p_GO_request(struct rtw_ada
 	wfdielen = build_nego_req_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -2973,7 +2905,7 @@ void issue_p2p_GO_response(struct rtw_ad
 
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
@@ -2981,7 +2913,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	}
 
 	DBG_8192D("[%s] In, result = %d\n", __func__,  result);
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -3008,12 +2940,12 @@ void issue_p2p_GO_response(struct rtw_ad
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
-	pwdinfo->negotiation_dialog_token = frame_body[7];	//	The Dialog Token of provisioning discovery request frame.
+	pwdinfo->negotiation_dialog_token = frame_body[7];	/* 	The Dialog Token of provisioning discovery request frame. */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(pwdinfo->negotiation_dialog_token), &(pattrib->pktlen));
 
-	//	Commented by Albert 20110328
-	//	Try to get the device password ID from the WPS IE of group negotiation request frame
-	//	WiFi Direct test plan 5.1.15
+	/* 	Commented by Albert 20110328 */
+	/* 	Try to get the device password ID from the WPS IE of group negotiation request frame */
+	/* 	WiFi Direct test plan 5.1.15 */
 	rtw_get_wps_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wpsie, &wpsielen);
 	rtw_get_wps_attr_content(wpsie, wpsielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
 	wps_devicepassword_id = be16_to_cpu(wps_devicepassword_id);
@@ -3021,34 +2953,34 @@ void issue_p2p_GO_response(struct rtw_ad
 	memset(wpsie, 0x00, 255);
 	wpsielen = 0;
 
-	//	WPS Section
+	/* 	WPS Section */
 	wpsielen = 0;
-	//	WPS OUI
+	/* 	WPS OUI */
 	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
-	//	WPS version
-	//	Type:
+	/* 	WPS version */
+	/* 	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
-	//	Value:
-	wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+	/* 	Value: */
+	wpsie[wpsielen++] = WPS_VERSION_1;	/* 	Version 1.0 */
 
-	//	Device Password ID
-	//	Type:
+	/* 	Device Password ID */
+	/* 	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 	wpsielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	if (wps_devicepassword_id == WPS_DPID_USER_SPEC)
 	{
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);
@@ -3063,9 +2995,9 @@ void issue_p2p_GO_response(struct rtw_ad
 	}
 	wpsielen += 2;
 
-	//	Commented by Kurt 20120113
-	//	If some device wants to do p2p handshake without sending prov_disc_req
-	//	We have to get peer_req_cm from here.
+	/* 	Commented by Kurt 20120113 */
+	/* 	If some device wants to do p2p handshake without sending prov_disc_req */
+	/* 	We have to get peer_req_cm from here. */
 	if (_rtw_memcmp(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3))
 	{
 		if (wps_devicepassword_id == WPS_DPID_USER_SPEC)
@@ -3085,66 +3017,66 @@ void issue_p2p_GO_response(struct rtw_ad
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
 
-	//	P2P IE Section.
+	/* 	P2P IE Section. */
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//	Commented by Albert 20100908
-	//	According to the P2P Specification, the group negoitation response frame should contain 9 P2P attributes
-	//	1. Status
-	//	2. P2P Capability
-	//	3. Group Owner Intent
-	//	4. Configuration Timeout
-	//	5. Operating Channel
-	//	6. Intended P2P Interface Address
-	//	7. Channel List
-	//	8. Device Info
-	//	9. Group ID	(Only GO)
+	/* 	Commented by Albert 20100908 */
+	/* 	According to the P2P Specification, the group negoitation response frame should contain 9 P2P attributes */
+	/* 	1. Status */
+	/* 	2. P2P Capability */
+	/* 	3. Group Owner Intent */
+	/* 	4. Configuration Timeout */
+	/* 	5. Operating Channel */
+	/* 	6. Intended P2P Interface Address */
+	/* 	7. Channel List */
+	/* 	8. Device Info */
+	/* 	9. Group ID	(Only GO) */
 
 
-	//	ToDo:
+	/* 	ToDo: */
 
-	//	P2P Status
-	//	Type:
+	/* 	P2P Status */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	p2pie[ p2pielen++ ] = result;
 
-	//	P2P Capability
-	//	Type:
+	/* 	P2P Capability */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	//	Device Capability Bitmap, 1 byte
+	/* 	Value: */
+	/* 	Device Capability Bitmap, 1 byte */
 
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 	{
-		//	Commented by Albert 2011/03/08
-		//	According to the P2P specification
-		//	if the sending device will be client, the P2P Capability should be reserved of group negotation response frame
+		/* 	Commented by Albert 2011/03/08 */
+		/* 	According to the P2P specification */
+		/* 	if the sending device will be client, the P2P Capability should be reserved of group negotation response frame */
 		p2pie[ p2pielen++ ] = 0;
 	}
 	else
 	{
-		//	Be group owner or meet the error case
+		/* 	Be group owner or meet the error case */
 		p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 	}
 
-	//	Group Capability Bitmap, 1 byte
+	/* 	Group Capability Bitmap, 1 byte */
 	if (pwdinfo->persistent_supported)
 	{
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
@@ -3154,95 +3086,95 @@ void issue_p2p_GO_response(struct rtw_ad
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN;
 	}
 
-	//	Group Owner Intent
-	//	Type:
+	/* 	Group Owner Intent */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_GO_INTENT;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	if (pwdinfo->peer_intent & 0x01)
 	{
-		//	Peer's tie breaker bit is 1, our tie breaker bit should be 0
+		/* 	Peer's tie breaker bit is 1, our tie breaker bit should be 0 */
 		p2pie[ p2pielen++ ] = (pwdinfo->intent << 1);
 	}
 	else
 	{
-		//	Peer's tie breaker bit is 0, our tie breaker bit should be 1
+		/* 	Peer's tie breaker bit is 0, our tie breaker bit should be 1 */
 		p2pie[ p2pielen++ ] = ((pwdinfo->intent << 1) | BIT(0));
 	}
 
 
-	//	Configuration Timeout
-	//	Type:
+	/* 	Configuration Timeout */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P GO
-	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P Client
+	/* 	Value: */
+	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P GO */
+	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P Client */
 
-	//	Operating Channel
-	//	Type:
+	/* 	Operating Channel */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
-	//	Value:
-	//	Country String
+	/* 	Value: */
+	/* 	Country String */
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
 
-	//	The third byte should be set to 0x04.
-	//	Described in the "Operating Channel Attribute" section.
+	/* 	The third byte should be set to 0x04. */
+	/* 	Described in the "Operating Channel Attribute" section. */
 	p2pie[ p2pielen++ ] = 0x04;
 
-	//	Operating Class
+	/* 	Operating Class */
 	if (pwdinfo->operating_channel <= 14)
 	{
-		//	Operating Class
+		/* 	Operating Class */
 		p2pie[ p2pielen++ ] = 0x51;
 	}
 	else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 	{
-		//	Operating Class
+		/* 	Operating Class */
 		p2pie[ p2pielen++ ] = 0x73;
 	}
 	else
 	{
-		//	Operating Class
+		/* 	Operating Class */
 		p2pie[ p2pielen++ ] = 0x7c;
 	}
 
-	//	Channel Number
-	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
+	/* 	Channel Number */
+	p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	/* 	operating channel number */
 
-	//	Intended P2P Interface Address
-	//	Type:
+	/* 	Intended P2P Interface Address */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_INTENTED_IF_ADDR;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
-	//	Channel List
-	//	Type:
+	/* 	Channel List */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
 
-	// Country String(3)
-	// + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?)
-	// + number of channels in all classes
+	/*  Country String(3) */
+	/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
+	/*  + number of channels in all classes */
 	len_channellist_attr = 3
 	   + (1 + 1) * (u16)pmlmeext->channel_list.reg_classes
 	   + get_reg_classes_full_count(pmlmeext->channel_list);
@@ -3263,16 +3195,16 @@ void issue_p2p_GO_response(struct rtw_ad
  #endif
 	p2pielen += 2;
 
-	//	Value:
-	//	Country String
+	/* 	Value: */
+	/* 	Country String */
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
 
-	//	The third byte should be set to 0x04.
-	//	Described in the "Operating Channel Attribute" section.
+	/* 	The third byte should be set to 0x04. */
+	/* 	Described in the "Operating Channel Attribute" section. */
 	p2pie[ p2pielen++ ] = 0x04;
 
-	//	Channel Entry List
+	/* 	Channel Entry List */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_LINKED))
@@ -3280,7 +3212,7 @@ void issue_p2p_GO_response(struct rtw_ad
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-		//	Operating Class
+		/* 	Operating Class */
 		if (pbuddy_mlmeext->cur_channel > 14)
 		{
 			if (pbuddy_mlmeext->cur_channel >= 149)
@@ -3297,114 +3229,114 @@ void issue_p2p_GO_response(struct rtw_ad
 			p2pie[ p2pielen++ ] = 0x51;
 		}
 
-		//	Number of Channels
-		//	Just support 1 channel and this channel is AP's channel
+		/* 	Number of Channels */
+		/* 	Just support 1 channel and this channel is AP's channel */
 		p2pie[ p2pielen++ ] = 1;
 
-		//	Channel List
+		/* 	Channel List */
 		p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
 	}
 	else
 	{
 		int i, j;
 		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
 
-			//	Number of Channels
+			/* 	Number of Channels */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
 
-			//	Channel List
+			/* 	Channel List */
 			for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
 			}
 		}
 	}
-#else // CONFIG_CONCURRENT_MODE
+#else /*  CONFIG_CONCURRENT_MODE */
 	{
 		int i, j;
 		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
 
-			//	Number of Channels
+			/* 	Number of Channels */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
 
-			//	Channel List
+			/* 	Channel List */
 			for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
 			}
 		}
 	}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
-	//	Device Info
-	//	Type:
+	/* 	Device Info */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
-	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
+	/* 	Length: */
+	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
+	/* 	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
-	//	P2P Device Address
+	/* 	Value: */
+	/* 	P2P Device Address */
 	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
-	//	Config Method
-	//	This field should be big endian. Noted by P2P specification.
+	/* 	Config Method */
+	/* 	This field should be big endian. Noted by P2P specification. */
 
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 
 	p2pielen += 2;
 
-	//	Primary Device Type
-	//	Category ID
+	/* 	Primary Device Type */
+	/* 	Category ID */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
-	//	OUI
+	/* 	OUI */
 	*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
-	//	Sub Category ID
+	/* 	Sub Category ID */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
-	//	Number of Secondary Device Types
-	p2pie[ p2pielen++ ] = 0x00;	//	No Secondary Device Type List
+	/* 	Number of Secondary Device Types */
+	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
 
-	//	Device Name
-	//	Type:
+	/* 	Device Name */
+	/* 	Type: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2pie + p2pielen, pwdinfo->device_name , pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
-		//	Group ID Attribute
-		//	Type:
+		/* 	Group ID Attribute */
+		/* 	Type: */
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
 		p2pielen += 2;
 
-		//	Value:
-		//	p2P Device Address
+		/* 	Value: */
+		/* 	p2P Device Address */
 		memcpy(p2pie + p2pielen , pwdinfo->device_addr, ETH_ALEN);
 		p2pielen += ETH_ALEN;
 
-		//	SSID
+		/* 	SSID */
 		memcpy(p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
 		p2pielen += pwdinfo->nego_ssidlen;
 
@@ -3416,7 +3348,7 @@ void issue_p2p_GO_response(struct rtw_ad
 	wfdielen = build_nego_resp_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -3445,7 +3377,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
@@ -3453,7 +3385,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	}
 
 	DBG_8192D("[%s] In\n", __func__);
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -3484,47 +3416,47 @@ void issue_p2p_GO_confirm(struct rtw_ada
 
 
 
-	//	P2P IE Section.
+	/* 	P2P IE Section. */
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//	Commented by Albert 20110306
-	//	According to the P2P Specification, the group negoitation request frame should contain 5 P2P attributes
-	//	1. Status
-	//	2. P2P Capability
-	//	3. Operating Channel
-	//	4. Channel List
-	//	5. Group ID	(if this WiFi is GO)
+	/* 	Commented by Albert 20110306 */
+	/* 	According to the P2P Specification, the group negoitation request frame should contain 5 P2P attributes */
+	/* 	1. Status */
+	/* 	2. P2P Capability */
+	/* 	3. Operating Channel */
+	/* 	4. Channel List */
+	/* 	5. Group ID	(if this WiFi is GO) */
 
-	//	P2P Status
-	//	Type:
+	/* 	P2P Status */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	p2pie[ p2pielen++ ] = result;
 
-	//	P2P Capability
-	//	Type:
+	/* 	P2P Capability */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	//	Device Capability Bitmap, 1 byte
+	/* 	Value: */
+	/* 	Device Capability Bitmap, 1 byte */
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
-	//	Group Capability Bitmap, 1 byte
+	/* 	Group Capability Bitmap, 1 byte */
 	if (pwdinfo->persistent_supported)
 	{
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_CROSS_CONN | P2P_GRPCAP_PERSISTENT_GROUP;
@@ -3535,21 +3467,21 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	}
 
 
-	//	Operating Channel
-	//	Type:
+	/* 	Operating Channel */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
-	//	Value:
-	//	Country String
+	/* 	Value: */
+	/* 	Country String */
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
 
-	//	The third byte should be set to 0x04.
-	//	Described in the "Operating Channel Attribute" section.
+	/* 	The third byte should be set to 0x04. */
+	/* 	Described in the "Operating Channel Attribute" section. */
 	p2pie[ p2pielen++ ] = 0x04;
 
 
@@ -3557,17 +3489,17 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	{
 		if (pwdinfo->peer_operating_ch <= 14)
 		{
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[ p2pielen++ ] = 0x51;
 		}
 		else if ((pwdinfo->peer_operating_ch >= 36) && (pwdinfo->peer_operating_ch <= 48))
 		{
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[ p2pielen++ ] = 0x73;
 		}
 		else
 		{
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[ p2pielen++ ] = 0x7c;
 		}
 
@@ -3577,53 +3509,53 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	{
 		if (pwdinfo->operating_channel <= 14)
 		{
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[ p2pielen++ ] = 0x51;
 		}
 		else if ((pwdinfo->operating_channel >= 36) && (pwdinfo->operating_channel <= 48))
 		{
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[ p2pielen++ ] = 0x73;
 		}
 		else
 		{
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[ p2pielen++ ] = 0x7c;
 		}
 
-		//	Channel Number
-		p2pie[ p2pielen++ ] = pwdinfo->operating_channel;		//	Use the listen channel as the operating channel
+		/* 	Channel Number */
+		p2pie[ p2pielen++ ] = pwdinfo->operating_channel;		/* 	Use the listen channel as the operating channel */
 	}
 
 
-	//	Channel List
-	//	Type:
+	/* 	Channel List */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(pwdinfo->channel_list_attr_len);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2pie + p2pielen, pwdinfo->channel_list_attr, pwdinfo->channel_list_attr_len);
 	p2pielen += pwdinfo->channel_list_attr_len;
 
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
-		//	Group ID Attribute
-		//	Type:
+		/* 	Group ID Attribute */
+		/* 	Type: */
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + pwdinfo->nego_ssidlen);
 		p2pielen += 2;
 
-		//	Value:
-		//	p2P Device Address
+		/* 	Value: */
+		/* 	p2P Device Address */
 		memcpy(p2pie + p2pielen , pwdinfo->device_addr, ETH_ALEN);
 		p2pielen += ETH_ALEN;
 
-		//	SSID
+		/* 	SSID */
 		memcpy(p2pie + p2pielen, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
 		p2pielen += pwdinfo->nego_ssidlen;
 	}
@@ -3634,7 +3566,7 @@ void issue_p2p_GO_confirm(struct rtw_ada
 	wfdielen = build_nego_confirm_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -3656,7 +3588,7 @@ void issue_p2p_invitation_request(struct
 	u16			len_channellist_attr = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 	struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
@@ -3680,7 +3612,7 @@ void issue_p2p_invitation_request(struct
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -3709,67 +3641,67 @@ void issue_p2p_invitation_request(struct
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
-	//	P2P IE Section.
+	/* 	P2P IE Section. */
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//	Commented by Albert 20101011
-	//	According to the P2P Specification, the P2P Invitation request frame should contain 7 P2P attributes
-	//	1. Configuration Timeout
-	//	2. Invitation Flags
-	//	3. Operating Channel	(Only GO)
-	//	4. P2P Group BSSID	(Should be included if I am the GO)
-	//	5. Channel List
-	//	6. P2P Group ID
-	//	7. P2P Device Info
+	/* 	Commented by Albert 20101011 */
+	/* 	According to the P2P Specification, the P2P Invitation request frame should contain 7 P2P attributes */
+	/* 	1. Configuration Timeout */
+	/* 	2. Invitation Flags */
+	/* 	3. Operating Channel	(Only GO) */
+	/* 	4. P2P Group BSSID	(Should be included if I am the GO) */
+	/* 	5. Channel List */
+	/* 	6. P2P Group ID */
+	/* 	7. P2P Device Info */
 
-	//	Configuration Timeout
-	//	Type:
+	/* 	Configuration Timeout */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P GO
-	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P Client
+	/* 	Value: */
+	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P GO */
+	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P Client */
 
-	//	Invitation Flags
-	//	Type:
+	/* 	Invitation Flags */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_INVITATION_FLAGS;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	p2pie[ p2pielen++ ] = P2P_INVITATION_FLAGS_PERSISTENT;
 
 
-	//	Operating Channel
-	//	Type:
+	/* 	Operating Channel */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 	p2pielen += 2;
 
-	//	Value:
-	//	Country String
+	/* 	Value: */
+	/* 	Country String */
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
 
-	//	The third byte should be set to 0x04.
-	//	Described in the "Operating Channel Attribute" section.
+	/* 	The third byte should be set to 0x04. */
+	/* 	Described in the "Operating Channel Attribute" section. */
 	p2pie[ p2pielen++ ] = 0x04;
 
-	//	Operating Class
+	/* 	Operating Class */
 	if (pwdinfo->invitereq_info.operating_ch <= 14)
 		p2pie[ p2pielen++ ] = 0x51;
 	else if ((pwdinfo->invitereq_info.operating_ch >= 36) && (pwdinfo->invitereq_info.operating_ch <= 48))
@@ -3777,34 +3709,34 @@ void issue_p2p_invitation_request(struct
 	else
 		p2pie[ p2pielen++ ] = 0x7c;
 
-	//	Channel Number
-	p2pie[ p2pielen++ ] = pwdinfo->invitereq_info.operating_ch;	//	operating channel number
+	/* 	Channel Number */
+	p2pie[ p2pielen++ ] = pwdinfo->invitereq_info.operating_ch;	/* 	operating channel number */
 
 	if (_rtw_memcmp(myid(&padapter->eeprompriv), pwdinfo->invitereq_info.go_bssid, ETH_ALEN))
 	{
-		//	P2P Group BSSID
-		//	Type:
+		/* 	P2P Group BSSID */
+		/* 	Type: */
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_BSSID;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 		p2pielen += 2;
 
-		//	Value:
-		//	P2P Device Address for GO
+		/* 	Value: */
+		/* 	P2P Device Address for GO */
 		memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid, ETH_ALEN);
 		p2pielen += ETH_ALEN;
 	}
 
-	//	Channel List
-	//	Type:
+	/* 	Channel List */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
 
 
-	//	Length:
-	// Country String(3)
-	// + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?)
-	// + number of channels in all classes
+	/* 	Length: */
+	/*  Country String(3) */
+	/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
+	/*  + number of channels in all classes */
 	len_channellist_attr = 3
 	   + (1 + 1) * (u16)pmlmeext->channel_list.reg_classes
 	   + get_reg_classes_full_count(pmlmeext->channel_list);
@@ -3825,23 +3757,23 @@ void issue_p2p_invitation_request(struct
  #endif
 	p2pielen += 2;
 
-	//	Value:
-	//	Country String
+	/* 	Value: */
+	/* 	Country String */
 	p2pie[ p2pielen++ ] = 'X';
 	p2pie[ p2pielen++ ] = 'X';
 
-	//	The third byte should be set to 0x04.
-	//	Described in the "Operating Channel Attribute" section.
+	/* 	The third byte should be set to 0x04. */
+	/* 	Described in the "Operating Channel Attribute" section. */
 	p2pie[ p2pielen++ ] = 0x04;
 
-	//	Channel Entry List
+	/* 	Channel Entry List */
 #ifdef CONFIG_CONCURRENT_MODE
 	if (check_buddy_fwstate(padapter, _FW_LINKED))
 	{
 		struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 		struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-		//	Operating Class
+		/* 	Operating Class */
 		if (pbuddy_mlmeext->cur_channel > 14)
 		{
 			if (pbuddy_mlmeext->cur_channel >= 149)
@@ -3858,112 +3790,112 @@ void issue_p2p_invitation_request(struct
 			p2pie[ p2pielen++ ] = 0x51;
 		}
 
-		//	Number of Channels
-		//	Just support 1 channel and this channel is AP's channel
+		/* 	Number of Channels */
+		/* 	Just support 1 channel and this channel is AP's channel */
 		p2pie[ p2pielen++ ] = 1;
 
-		//	Channel List
+		/* 	Channel List */
 		p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
 	}
 	else
 	{
 		int i, j;
 		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
 
-			//	Number of Channels
+			/* 	Number of Channels */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
 
-			//	Channel List
+			/* 	Channel List */
 			for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
 			}
 		}
 	}
-#else // CONFIG_CONCURRENT_MODE
+#else /*  CONFIG_CONCURRENT_MODE */
 	{
 		int i, j;
 		for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-			//	Operating Class
+			/* 	Operating Class */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
 
-			//	Number of Channels
+			/* 	Number of Channels */
 			p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
 
-			//	Channel List
+			/* 	Channel List */
 			for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
 			}
 		}
 	}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 
-	//	P2P Group ID
-	//	Type:
+	/* 	P2P Group ID */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(6 + pwdinfo->invitereq_info.ssidlen);
 	p2pielen += 2;
 
-	//	Value:
-	//	P2P Device Address for GO
+	/* 	Value: */
+	/* 	P2P Device Address for GO */
 	memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_bssid, ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
-	//	SSID
+	/* 	SSID */
 	memcpy(p2pie + p2pielen, pwdinfo->invitereq_info.go_ssid, pwdinfo->invitereq_info.ssidlen);
 	p2pielen += pwdinfo->invitereq_info.ssidlen;
 
 
-	//	Device Info
-	//	Type:
+	/* 	Device Info */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
-	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
+	/* 	Length: */
+	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
+	/* 	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
-	//	P2P Device Address
+	/* 	Value: */
+	/* 	P2P Device Address */
 	memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
-	//	Config Method
-	//	This field should be big endian. Noted by P2P specification.
+	/* 	Config Method */
+	/* 	This field should be big endian. Noted by P2P specification. */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
 	p2pielen += 2;
 
-	//	Primary Device Type
-	//	Category ID
+	/* 	Primary Device Type */
+	/* 	Category ID */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
-	//	OUI
+	/* 	OUI */
 	*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 	p2pielen += 4;
 
-	//	Sub Category ID
+	/* 	Sub Category ID */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
-	//	Number of Secondary Device Types
-	p2pie[ p2pielen++ ] = 0x00;	//	No Secondary Device Type List
+	/* 	Number of Secondary Device Types */
+	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
 
-	//	Device Name
-	//	Type:
+	/* 	Device Name */
+	/* 	Type: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
@@ -3973,7 +3905,7 @@ void issue_p2p_invitation_request(struct
 	wfdielen = build_invitation_req_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -4000,7 +3932,7 @@ void issue_p2p_invitation_response(struc
 #endif
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
@@ -4018,7 +3950,7 @@ void issue_p2p_invitation_response(struc
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -4047,108 +3979,108 @@ void issue_p2p_invitation_response(struc
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
-	//	P2P IE Section.
+	/* 	P2P IE Section. */
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//	Commented by Albert 20101005
-	//	According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes
-	//	1. Status
-	//	2. Configuration Timeout
-	//	3. Operating Channel	(Only GO)
-	//	4. P2P Group BSSID	(Only GO)
-	//	5. Channel List
+	/* 	Commented by Albert 20101005 */
+	/* 	According to the P2P Specification, the P2P Invitation response frame should contain 5 P2P attributes */
+	/* 	1. Status */
+	/* 	2. Configuration Timeout */
+	/* 	3. Operating Channel	(Only GO) */
+	/* 	4. P2P Group BSSID	(Only GO) */
+	/* 	5. Channel List */
 
-	//	P2P Status
-	//	Type:
+	/* 	P2P Status */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_STATUS;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0001);
 	p2pielen += 2;
 
-	//	Value:
-	//	When status code is P2P_STATUS_FAIL_INFO_UNAVAILABLE.
-	//	Sent the event receiving the P2P Invitation Req frame to DMP UI.
-	//	DMP had to compare the MAC address to find out the profile.
-	//	So, the WiFi driver will send the P2P_STATUS_FAIL_INFO_UNAVAILABLE to NB.
-	//	If the UI found the corresponding profile, the WiFi driver sends the P2P Invitation Req
-	//	to NB to rebuild the persistent group.
+	/* 	Value: */
+	/* 	When status code is P2P_STATUS_FAIL_INFO_UNAVAILABLE. */
+	/* 	Sent the event receiving the P2P Invitation Req frame to DMP UI. */
+	/* 	DMP had to compare the MAC address to find out the profile. */
+	/* 	So, the WiFi driver will send the P2P_STATUS_FAIL_INFO_UNAVAILABLE to NB. */
+	/* 	If the UI found the corresponding profile, the WiFi driver sends the P2P Invitation Req */
+	/* 	to NB to rebuild the persistent group. */
 	p2pie[ p2pielen++ ] = status_code;
 
-	//	Configuration Timeout
-	//	Type:
+	/* 	Configuration Timeout */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CONF_TIMEOUT;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P GO
-	p2pie[ p2pielen++ ] = 200;	//	2 seconds needed to be the P2P Client
+	/* 	Value: */
+	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P GO */
+	p2pie[ p2pielen++ ] = 200;	/* 	2 seconds needed to be the P2P Client */
 
 	if (status_code == P2P_STATUS_SUCCESS)
 	{
 		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		{
-			//	The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO
-			//	In this case, the P2P Invitation response frame should carry the two more P2P attributes.
-			//	First one is operating channel attribute.
-			//	Second one is P2P Group BSSID attribute.
+			/* 	The P2P Invitation request frame asks this Wi-Fi device to be the P2P GO */
+			/* 	In this case, the P2P Invitation response frame should carry the two more P2P attributes. */
+			/* 	First one is operating channel attribute. */
+			/* 	Second one is P2P Group BSSID attribute. */
 
-			//	Operating Channel
-			//	Type:
+			/* 	Operating Channel */
+			/* 	Type: */
 			p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 			p2pielen += 2;
 
-			//	Value:
-			//	Country String
+			/* 	Value: */
+			/* 	Country String */
 			p2pie[ p2pielen++ ] = 'X';
 			p2pie[ p2pielen++ ] = 'X';
 
-			//	The third byte should be set to 0x04.
-			//	Described in the "Operating Channel Attribute" section.
+			/* 	The third byte should be set to 0x04. */
+			/* 	Described in the "Operating Channel Attribute" section. */
 			p2pie[ p2pielen++ ] = 0x04;
 
-			//	Operating Class
-			p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
+			/* 	Operating Class */
+			p2pie[ p2pielen++ ] = 0x51;	/* 	Copy from SD7 */
 
-			//	Channel Number
-			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
+			/* 	Channel Number */
+			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	/* 	operating channel number */
 
 
-			//	P2P Group BSSID
-			//	Type:
+			/* 	P2P Group BSSID */
+			/* 	Type: */
 			p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_BSSID;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN);
 			p2pielen += 2;
 
-			//	Value:
-			//	P2P Device Address for GO
+			/* 	Value: */
+			/* 	P2P Device Address for GO */
 			memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 			p2pielen += ETH_ALEN;
 
 		}
 
-		//	Channel List
-		//	Type:
+		/* 	Channel List */
+		/* 	Type: */
 		p2pie[ p2pielen++ ] = P2P_ATTR_CH_LIST;
 
-		//	Length:
-		// Country String(3)
-		// + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?)
-		// + number of channels in all classes
+		/* 	Length: */
+		/*  Country String(3) */
+		/*  + (Operating Class (1) + Number of Channels(1)) * Operation Classes (?) */
+		/*  + number of channels in all classes */
 		len_channellist_attr = 3
 			+ (1 + 1) * (u16)pmlmeext->channel_list.reg_classes
 			+ get_reg_classes_full_count(pmlmeext->channel_list);
@@ -4169,23 +4101,23 @@ void issue_p2p_invitation_response(struc
 #endif
 		p2pielen += 2;
 
-		//	Value:
-		//	Country String
+		/* 	Value: */
+		/* 	Country String */
 		p2pie[ p2pielen++ ] = 'X';
 		p2pie[ p2pielen++ ] = 'X';
 
-		//	The third byte should be set to 0x04.
-		//	Described in the "Operating Channel Attribute" section.
+		/* 	The third byte should be set to 0x04. */
+		/* 	Described in the "Operating Channel Attribute" section. */
 		p2pie[ p2pielen++ ] = 0x04;
 
-		//	Channel Entry List
+		/* 	Channel Entry List */
 #ifdef CONFIG_CONCURRENT_MODE
 		if (check_buddy_fwstate(padapter, _FW_LINKED))
 		{
 			struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
 			struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-			//	Operating Class
+			/* 	Operating Class */
 			if (pbuddy_mlmeext->cur_channel > 14)
 			{
 				if (pbuddy_mlmeext->cur_channel >= 149)
@@ -4202,46 +4134,46 @@ void issue_p2p_invitation_response(struc
 				p2pie[ p2pielen++ ] = 0x51;
 			}
 
-			//	Number of Channels
-			//	Just support 1 channel and this channel is AP's channel
+			/* 	Number of Channels */
+			/* 	Just support 1 channel and this channel is AP's channel */
 			p2pie[ p2pielen++ ] = 1;
 
-			//	Channel List
+			/* 	Channel List */
 			p2pie[ p2pielen++ ] = pbuddy_mlmeext->cur_channel;
 		}
 		else
 		{
 			int i, j;
 			for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-				//	Operating Class
+				/* 	Operating Class */
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
 
-				//	Number of Channels
+				/* 	Number of Channels */
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
 
-				//	Channel List
+				/* 	Channel List */
 				for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
 					p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
 				}
 			}
 		}
-#else // CONFIG_CONCURRENT_MODE
+#else /*  CONFIG_CONCURRENT_MODE */
 		{
 			int i, j;
 			for (j = 0; j < pmlmeext->channel_list.reg_classes; j++) {
-				//	Operating Class
+				/* 	Operating Class */
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].reg_class;
 
-				//	Number of Channels
+				/* 	Number of Channels */
 				p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channels;
 
-				//	Channel List
+				/* 	Channel List */
 				for (i = 0; i < pmlmeext->channel_list.reg_class[j].channels; i++) {
 					p2pie[p2pielen++] = pmlmeext->channel_list.reg_class[j].channel[i];
 				}
 			}
 		}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 	}
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
@@ -4250,7 +4182,7 @@ void issue_p2p_invitation_response(struc
 	wfdielen = build_invitation_resp_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -4271,7 +4203,7 @@ void issue_p2p_provision_request(struct
 	u32			p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
@@ -4290,7 +4222,7 @@ void issue_p2p_provision_request(struct
 	}
 
 	DBG_8192D("[%s] In\n", __func__);
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -4325,32 +4257,32 @@ void issue_p2p_provision_request(struct
 	pattrib->pktlen += p2pielen;
 
 	wpsielen = 0;
-	//	WPS OUI
+	/* 	WPS OUI */
 	*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 	wpsielen += 4;
 
-	//	WPS version
-	//	Type:
+	/* 	WPS version */
+	/* 	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 	wpsielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 	wpsielen += 2;
 
-	//	Value:
-	wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+	/* 	Value: */
+	wpsie[wpsielen++] = WPS_VERSION_1;	/* 	Version 1.0 */
 
-	//	Config Method
-	//	Type:
+	/* 	Config Method */
+	/* 	Type: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 	wpsielen += 2;
 
-	//	Length:
+	/* 	Length: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 	wpsielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->tx_prov_disc_info.wps_config_method_request);
 	wpsielen += 2;
 
@@ -4361,7 +4293,7 @@ void issue_p2p_provision_request(struct
 	wfdielen = build_provdisc_req_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -4405,7 +4337,7 @@ void issue_probersp_p2p(struct rtw_adapt
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-	//struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
+	/* struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network); */
 	u16					beacon_interval = 100;
 	u16					capInfo = 0;
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
@@ -4413,24 +4345,24 @@ void issue_probersp_p2p(struct rtw_adapt
 	u32					wpsielen = 0, p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 #ifdef CONFIG_IOCTL_CFG80211
 	struct cfg80211_wifidirect_info *pcfg80211_wdinfo = &padapter->cfg80211_wdinfo;
 	struct ieee80211_channel *ieee_ch = &pcfg80211_wdinfo->remain_on_ch_channel;
 	u8 listen_channel = (u8) ieee80211_frequency_to_channel(ieee_ch->center_freq);
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 #ifdef CONFIG_INTEL_WIDI
 	u8 zero_array_check[L2SDTA_SERVICE_VE_LEN] = { 0x00 };
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 
-	//DBG_8192D("%s\n", __func__);
+	/* DBG_8192D("%s\n", __func__); */
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -4446,7 +4378,7 @@ void issue_probersp_p2p(struct rtw_adapt
 	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
 	memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
 
-	//	Use the device address for BSSID field.
+	/* 	Use the device address for BSSID field. */
 	memcpy(pwlanhdr->addr3, mac, ETH_ALEN);
 
 	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
@@ -4457,17 +4389,17 @@ void issue_probersp_p2p(struct rtw_adapt
 	pattrib->pktlen = pattrib->hdrlen;
 	pframe += pattrib->hdrlen;
 
-	//timestamp will be inserted by hardware
+	/* timestamp will be inserted by hardware */
 	pframe += 8;
 	pattrib->pktlen += 8;
 
-	// beacon interval: 2 bytes
+	/*  beacon interval: 2 bytes */
 	memcpy(pframe, (unsigned char *) &beacon_interval, 2);
 	pframe += 2;
 	pattrib->pktlen += 2;
 
-	//	capability info: 2 bytes
-	//	ESS and IBSS bits must be 0 (defined in the 3.1.2.1.1 of WiFi Direct Spec)
+	/* 	capability info: 2 bytes */
+	/* 	ESS and IBSS bits must be 0 (defined in the 3.1.2.1.1 of WiFi Direct Spec) */
 	capInfo |= cap_ShortPremble;
 	capInfo |= cap_ShortSlot;
 
@@ -4476,21 +4408,21 @@ void issue_probersp_p2p(struct rtw_adapt
 	pattrib->pktlen += 2;
 
 
-	// SSID
+	/*  SSID */
 	pframe = rtw_set_ie(pframe, _SSID_IE_, 7, pwdinfo->p2p_wildcard_ssid, &pattrib->pktlen);
 
-	// supported rates...
-	//	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54)
+	/*  supported rates... */
+	/* 	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54) */
 	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate, &pattrib->pktlen);
 
-	// DS parameter set
+	/*  DS parameter set */
 #ifdef CONFIG_IOCTL_CFG80211
 	if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled && listen_channel !=0)
 	{
 		pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&listen_channel, &pattrib->pktlen);
 	}
 	else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	{
 		pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&pwdinfo->listen_channel, &pattrib->pktlen);
 	}
@@ -4501,205 +4433,205 @@ void issue_probersp_p2p(struct rtw_adapt
 	{
 		if (pmlmepriv->wps_probe_resp_ie != NULL && pmlmepriv->p2p_probe_resp_ie != NULL)
 		{
-			//WPS IE
+			/* WPS IE */
 			memcpy(pframe, pmlmepriv->wps_probe_resp_ie, pmlmepriv->wps_probe_resp_ie_len);
 			pattrib->pktlen += pmlmepriv->wps_probe_resp_ie_len;
 			pframe += pmlmepriv->wps_probe_resp_ie_len;
 
-			//P2P IE
+			/* P2P IE */
 			memcpy(pframe, pmlmepriv->p2p_probe_resp_ie, pmlmepriv->p2p_probe_resp_ie_len);
 			pattrib->pktlen += pmlmepriv->p2p_probe_resp_ie_len;
 			pframe += pmlmepriv->p2p_probe_resp_ie_len;
 		}
 	}
 	else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	{
-		//	Todo: WPS IE
-		//	Noted by Albert 20100907
-		//	According to the WPS specification, all the WPS attribute is presented by Big Endian.
+		/* 	Todo: WPS IE */
+		/* 	Noted by Albert 20100907 */
+		/* 	According to the WPS specification, all the WPS attribute is presented by Big Endian. */
 
 		wpsielen = 0;
-		//	WPS OUI
+		/* 	WPS OUI */
 		*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
-		//	WPS version
-		//	Type:
+		/* 	WPS version */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
-		//	Value:
-		wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+		/* 	Value: */
+		wpsie[wpsielen++] = WPS_VERSION_1;	/* 	Version 1.0 */
 
 #ifdef CONFIG_INTEL_WIDI
-		//	Commented by Kurt
-		//	Appended WiDi info. only if we did issued_probereq_widi(), and then we saved ven. ext. in pmlmepriv->sa_ext.
+		/* 	Commented by Kurt */
+		/* 	Appended WiDi info. only if we did issued_probereq_widi(), and then we saved ven. ext. in pmlmepriv->sa_ext. */
 		if ( _rtw_memcmp(pmlmepriv->sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false)
 		{
-			//Sec dev type
+			/* Sec dev type */
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_SEC_DEV_TYPE_LIST);
 			wpsielen += 2;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0008);
 			wpsielen += 2;
 
-			//	Value:
-			//	Category ID
+			/* 	Value: */
+			/* 	Category ID */
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_DISPLAYS);
 			wpsielen += 2;
 
-			//	OUI
+			/* 	OUI */
 			*(u32*) (wpsie + wpsielen) = cpu_to_be32(INTEL_DEV_TYPE_OUI);
 			wpsielen += 4;
 
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_WIDI_CONSUMER_SINK);
 			wpsielen += 2;
 
-			//	Vendor Extension
+			/* 	Vendor Extension */
 			memcpy(wpsie + wpsielen, pmlmepriv->sa_ext, L2SDTA_SERVICE_VE_LEN);
 			wpsielen += L2SDTA_SERVICE_VE_LEN;
 		}
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 
-		//	WiFi Simple Config State
-		//	Type:
+		/* 	WiFi Simple Config State */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_SIMPLE_CONF_STATE);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
-		//	Value:
-		wpsie[wpsielen++] = WPS_WSC_STATE_NOT_CONFIG;	//	Not Configured.
+		/* 	Value: */
+		wpsie[wpsielen++] = WPS_WSC_STATE_NOT_CONFIG;	/* 	Not Configured. */
 
-		//	Response Type
-		//	Type:
+		/* 	Response Type */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_RESP_TYPE);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		wpsie[wpsielen++] = WPS_RESPONSE_TYPE_8021X;
 
-		//	UUID-E
-		//	Type:
+		/* 	UUID-E */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_UUID_E);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0010);
 		wpsielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		memcpy(wpsie + wpsielen, myid(&padapter->eeprompriv), ETH_ALEN);
 		wpsielen += 0x10;
 
-		//	Manufacturer
-		//	Type:
+		/* 	Manufacturer */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MANUFACTURER);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0007);
 		wpsielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		memcpy(wpsie + wpsielen, "Realtek", 7);
 		wpsielen += 7;
 
-		//	Model Name
-		//	Type:
+		/* 	Model Name */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MODEL_NAME);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0006);
 		wpsielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		memcpy(wpsie + wpsielen, "8192CU", 6);
 		wpsielen += 6;
 
-		//	Model Number
-		//	Type:
+		/* 	Model Number */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_MODEL_NUMBER);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
-		//	Value:
-		wpsie[ wpsielen++ ] = 0x31;		//	character 1
+		/* 	Value: */
+		wpsie[ wpsielen++ ] = 0x31;		/* 	character 1 */
 
-		//	Serial Number
-		//	Type:
+		/* 	Serial Number */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_SERIAL_NUMBER);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(ETH_ALEN);
 		wpsielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		memcpy(wpsie + wpsielen, "123456" , ETH_ALEN);
 		wpsielen += ETH_ALEN;
 
-		//	Primary Device Type
-		//	Type:
+		/* 	Primary Device Type */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0008);
 		wpsielen += 2;
 
-		//	Value:
-		//	Category ID
+		/* 	Value: */
+		/* 	Category ID */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_RTK_WIDI);
 		wpsielen += 2;
 
-		//	OUI
+		/* 	OUI */
 		*(u32*) (wpsie + wpsielen) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
-		//	Sub Category ID
+		/* 	Sub Category ID */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_RTK_DMP);
 		wpsielen += 2;
 
-		//	Device Name
-		//	Type:
+		/* 	Device Name */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->device_name_len);
 		wpsielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		memcpy(wpsie + wpsielen, pwdinfo->device_name, pwdinfo->device_name_len);
 		wpsielen += pwdinfo->device_name_len;
 
-		//	Config Method
-		//	Type:
+		/* 	Config Method */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 		wpsielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 		wpsielen += 2;
 
@@ -4715,7 +4647,7 @@ void issue_probersp_p2p(struct rtw_adapt
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
 	if (true == pwdinfo->wfd_info->wfd_enable)
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	{
 		wfdielen = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
 		pframe += wfdielen;
@@ -4724,13 +4656,13 @@ void issue_probersp_p2p(struct rtw_adapt
 #ifdef CONFIG_IOCTL_CFG80211
 	else if (pmlmepriv->wfd_probe_resp_ie != NULL && pmlmepriv->wfd_probe_resp_ie_len>0)
 	{
-		//WFD IE
+		/* WFD IE */
 		memcpy(pframe, pmlmepriv->wfd_probe_resp_ie, pmlmepriv->wfd_probe_resp_ie_len);
 		pattrib->pktlen += pmlmepriv->wfd_probe_resp_ie_len;
 		pframe += pmlmepriv->wfd_probe_resp_ie_len;
 	}
-#endif //CONFIG_IOCTL_CFG80211
-#endif //CONFIG_WFD
+#endif /* CONFIG_IOCTL_CFG80211 */
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -4760,7 +4692,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 	u16					wpsielen = 0, p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
@@ -4770,7 +4702,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 		goto exit;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -4791,13 +4723,13 @@ int _issue_probereq_p2p(struct rtw_adapt
 	} else {
 		if ((pwdinfo->p2p_info.scan_op_ch_only) || (pwdinfo->rx_invitereq_info.scan_op_ch_only))
 		{
-			//	This two flags will be set when this is only the P2P client mode.
+			/* 	This two flags will be set when this is only the P2P client mode. */
 			memcpy(pwlanhdr->addr1, pwdinfo->p2p_peer_interface_addr, ETH_ALEN);
 			memcpy(pwlanhdr->addr3, pwdinfo->p2p_peer_interface_addr, ETH_ALEN);
 		}
 		else
 		{
-			//	broadcast probe request frame
+			/* 	broadcast probe request frame */
 			memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
 			memcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);
 		}
@@ -4819,7 +4751,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 	{
 		pframe = rtw_set_ie(pframe, _SSID_IE_, P2P_WILDCARD_SSID_LEN, pwdinfo->p2p_wildcard_ssid, &(pattrib->pktlen));
 	}
-	//	Use the OFDM rate in the P2P probe request frame. (6(B), 9(B), 12(B), 24(B), 36, 48, 54)
+	/* 	Use the OFDM rate in the P2P probe request frame. (6(B), 9(B), 12(B), 24(B), 36, 48, 54) */
 	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pwdinfo->support_rate, &pattrib->pktlen);
 
 #ifdef CONFIG_IOCTL_CFG80211
@@ -4827,218 +4759,218 @@ int _issue_probereq_p2p(struct rtw_adapt
 	{
 		if (pmlmepriv->wps_probe_req_ie != NULL && pmlmepriv->p2p_probe_req_ie != NULL)
 		{
-			//WPS IE
+			/* WPS IE */
 			memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
 			pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
 			pframe += pmlmepriv->wps_probe_req_ie_len;
 
-			//P2P IE
+			/* P2P IE */
 			memcpy(pframe, pmlmepriv->p2p_probe_req_ie, pmlmepriv->p2p_probe_req_ie_len);
 			pattrib->pktlen += pmlmepriv->p2p_probe_req_ie_len;
 			pframe += pmlmepriv->p2p_probe_req_ie_len;
 		}
 	}
 	else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	{
-		//	WPS IE
-		//	Noted by Albert 20110221
-		//	According to the WPS specification, all the WPS attribute is presented by Big Endian.
+		/* 	WPS IE */
+		/* 	Noted by Albert 20110221 */
+		/* 	According to the WPS specification, all the WPS attribute is presented by Big Endian. */
 
 		wpsielen = 0;
-		//	WPS OUI
+		/* 	WPS OUI */
 		*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
-		//	WPS version
-		//	Type:
+		/* 	WPS version */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_VER1);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0001);
 		wpsielen += 2;
 
-		//	Value:
-		wpsie[wpsielen++] = WPS_VERSION_1;	//	Version 1.0
+		/* 	Value: */
+		wpsie[wpsielen++] = WPS_VERSION_1;	/* 	Version 1.0 */
 
 		if (pmlmepriv->wps_probe_req_ie == NULL)
 		{
-			//	UUID-E
-			//	Type:
+			/* 	UUID-E */
+			/* 	Type: */
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_UUID_E);
 			wpsielen += 2;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0010);
 			wpsielen += 2;
 
-			//	Value:
+			/* 	Value: */
 			memcpy(wpsie + wpsielen, myid(&padapter->eeprompriv), ETH_ALEN);
 			wpsielen += 0x10;
 
-			//	Config Method
-			//	Type:
+			/* 	Config Method */
+			/* 	Type: */
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
 			wpsielen += 2;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 			wpsielen += 2;
 
-			//	Value:
+			/* 	Value: */
 			*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
 			wpsielen += 2;
 		}
 
-		//	Device Name
-		//	Type:
+		/* 	Device Name */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(pwdinfo->device_name_len);
 		wpsielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		memcpy(wpsie + wpsielen, pwdinfo->device_name, pwdinfo->device_name_len);
 		wpsielen += pwdinfo->device_name_len;
 
-		//	Primary Device Type
-		//	Type:
+		/* 	Primary Device Type */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0008);
 		wpsielen += 2;
 
-		//	Value:
-		//	Category ID
+		/* 	Value: */
+		/* 	Category ID */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 		wpsielen += 2;
 
-		//	OUI
+		/* 	OUI */
 		*(u32*) (wpsie + wpsielen) = cpu_to_be32(WPSOUI);
 		wpsielen += 4;
 
-		//	Sub Category ID
+		/* 	Sub Category ID */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 		wpsielen += 2;
 
-		//	Device Password ID
-		//	Type:
+		/* 	Device Password ID */
+		/* 	Type: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_DEVICE_PWID);
 		wpsielen += 2;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
 		wpsielen += 2;
 
-		//	Value:
-		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);	//	Registrar-specified
+		/* 	Value: */
+		*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_DPID_REGISTRAR_SPEC);	/* 	Registrar-specified */
 		wpsielen += 2;
 
 		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wpsielen, (unsigned char *) wpsie, &pattrib->pktlen);
 
-		//	P2P OUI
+		/* 	P2P OUI */
 		p2pielen = 0;
 		p2pie[ p2pielen++ ] = 0x50;
 		p2pie[ p2pielen++ ] = 0x6F;
 		p2pie[ p2pielen++ ] = 0x9A;
-		p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+		p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-		//	Commented by Albert 20110221
-		//	According to the P2P Specification, the probe request frame should contain 5 P2P attributes
-		//	1. P2P Capability
-		//	2. P2P Device ID if this probe request wants to find the specific P2P device
-		//	3. Listen Channel
-		//	4. Extended Listen Timing
-		//	5. Operating Channel if this WiFi is working as the group owner now
+		/* 	Commented by Albert 20110221 */
+		/* 	According to the P2P Specification, the probe request frame should contain 5 P2P attributes */
+		/* 	1. P2P Capability */
+		/* 	2. P2P Device ID if this probe request wants to find the specific P2P device */
+		/* 	3. Listen Channel */
+		/* 	4. Extended Listen Timing */
+		/* 	5. Operating Channel if this WiFi is working as the group owner now */
 
-		//	P2P Capability
-		//	Type:
+		/* 	P2P Capability */
+		/* 	Type: */
 		p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 		p2pielen += 2;
 
-		//	Value:
-		//	Device Capability Bitmap, 1 byte
+		/* 	Value: */
+		/* 	Device Capability Bitmap, 1 byte */
 		p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
-		//	Group Capability Bitmap, 1 byte
+		/* 	Group Capability Bitmap, 1 byte */
 		if (pwdinfo->persistent_supported)
 			p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 		else
 			p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
 
-		//	Listen Channel
-		//	Type:
+		/* 	Listen Channel */
+		/* 	Type: */
 		p2pie[ p2pielen++ ] = P2P_ATTR_LISTEN_CH;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 		p2pielen += 2;
 
-		//	Value:
-		//	Country String
+		/* 	Value: */
+		/* 	Country String */
 		p2pie[ p2pielen++ ] = 'X';
 		p2pie[ p2pielen++ ] = 'X';
 
-		//	The third byte should be set to 0x04.
-		//	Described in the "Operating Channel Attribute" section.
+		/* 	The third byte should be set to 0x04. */
+		/* 	Described in the "Operating Channel Attribute" section. */
 		p2pie[ p2pielen++ ] = 0x04;
 
-		//	Operating Class
-		p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
+		/* 	Operating Class */
+		p2pie[ p2pielen++ ] = 0x51;	/* 	Copy from SD7 */
 
-		//	Channel Number
-		p2pie[ p2pielen++ ] = pwdinfo->listen_channel;	//	listen channel
+		/* 	Channel Number */
+		p2pie[ p2pielen++ ] = pwdinfo->listen_channel;	/* 	listen channel */
 
 
-		//	Extended Listen Timing
-		//	Type:
+		/* 	Extended Listen Timing */
+		/* 	Type: */
 		p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
 
-		//	Length:
+		/* 	Length: */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
 		p2pielen += 2;
 
-		//	Value:
-		//	Availability Period
+		/* 	Value: */
+		/* 	Availability Period */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 		p2pielen += 2;
 
-		//	Availability Interval
+		/* 	Availability Interval */
 		*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 		p2pielen += 2;
 
 		if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 		{
-			//	Operating Channel (if this WiFi is working as the group owner now)
-			//	Type:
+			/* 	Operating Channel (if this WiFi is working as the group owner now) */
+			/* 	Type: */
 			p2pie[ p2pielen++ ] = P2P_ATTR_OPERATING_CH;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0005);
 			p2pielen += 2;
 
-			//	Value:
-			//	Country String
+			/* 	Value: */
+			/* 	Country String */
 			p2pie[ p2pielen++ ] = 'X';
 			p2pie[ p2pielen++ ] = 'X';
 
-			//	The third byte should be set to 0x04.
-			//	Described in the "Operating Channel Attribute" section.
+			/* 	The third byte should be set to 0x04. */
+			/* 	Described in the "Operating Channel Attribute" section. */
 			p2pie[ p2pielen++ ] = 0x04;
 
-			//	Operating Class
-			p2pie[ p2pielen++ ] = 0x51;	//	Copy from SD7
+			/* 	Operating Class */
+			p2pie[ p2pielen++ ] = 0x51;	/* 	Copy from SD7 */
 
-			//	Channel Number
-			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	//	operating channel number
+			/* 	Channel Number */
+			p2pie[ p2pielen++ ] = pwdinfo->operating_channel;	/* 	operating channel number */
 
 		}
 
@@ -5046,7 +4978,7 @@ int _issue_probereq_p2p(struct rtw_adapt
 
 		if (pmlmepriv->wps_probe_req_ie != NULL)
 		{
-			//WPS IE
+			/* WPS IE */
 			memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
 			pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
 			pframe += pmlmepriv->wps_probe_req_ie_len;
@@ -5065,13 +4997,13 @@ int _issue_probereq_p2p(struct rtw_adapt
 #ifdef CONFIG_IOCTL_CFG80211
 	else if (pmlmepriv->wfd_probe_req_ie != NULL && pmlmepriv->wfd_probe_req_ie_len>0)
 	{
-		//WFD IE
+		/* WFD IE */
 		memcpy(pframe, pmlmepriv->wfd_probe_req_ie, pmlmepriv->wfd_probe_req_ie_len);
 		pattrib->pktlen += pmlmepriv->wfd_probe_req_ie_len;
 		pframe += pmlmepriv->wfd_probe_req_ie_len;
 	}
-#endif //CONFIG_IOCTL_CFG80211
-#endif //CONFIG_WFD
+#endif /* CONFIG_IOCTL_CFG80211 */
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -5134,7 +5066,7 @@ exit:
 	return ret;
 }
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 s32 rtw_action_public_decache(union recv_frame *recv_frame, s32 token)
 {
@@ -5183,7 +5115,7 @@ unsigned int on_action_public_p2p(union
 	struct	wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 	u8	result = P2P_STATUS_SUCCESS;
 	u8	empty_addr[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
 
@@ -5200,15 +5132,15 @@ unsigned int on_action_public_p2p(union
 		rtw_cfg80211_rx_p2p_action_public(padapter, pframe, len);
 	}
 	else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	{
-		//	Do nothing if the driver doesn't enable the P2P function.
+		/* 	Do nothing if the driver doesn't enable the P2P function. */
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 			return _SUCCESS;
 
 		len -= sizeof(struct rtw_ieee80211_hdr_3addr);
 
-		switch (frame_body[ 6 ])//OUI Subtype
+		switch (frame_body[ 6 ])/* OUI Subtype */
 		{
 			case P2P_GO_NEGO_REQ:
 			{
@@ -5222,10 +5154,10 @@ unsigned int on_action_public_p2p(union
 
 				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
 				{
-					//	Commented by Albert 20110526
-					//	In this case, this means the previous nego fail doesn't be reset yet.
+					/* 	Commented by Albert 20110526 */
+					/* 	In this case, this means the previous nego fail doesn't be reset yet. */
 					_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
-					//	Restore the previous p2p state
+					/* 	Restore the previous p2p state */
 					rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 					DBG_8192D("[%s] Restore the previous p2p state to %d\n", __func__, rtw_p2p_state(pwdinfo));
 				}
@@ -5234,15 +5166,15 @@ unsigned int on_action_public_p2p(union
 				{
 					_cancel_timer_ex(&pwdinfo->ap_p2p_switch_timer);
 				}
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 
-				//	Commented by Kurt 20110902
-				//Add if statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered.
+				/* 	Commented by Kurt 20110902 */
+				/* Add if statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered. */
 				if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 					rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 
-				//	Commented by Kurt 20120113
-				//	Get peer_dev_addr here if peer doesn't issue prov_disc frame.
+				/* 	Commented by Kurt 20120113 */
+				/* 	Get peer_dev_addr here if peer doesn't issue prov_disc frame. */
 				if (_rtw_memcmp(pwdinfo->rx_prov_disc_info.peerDevAddr, empty_addr, ETH_ALEN));
 					memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN);
 
@@ -5254,16 +5186,16 @@ unsigned int on_action_public_p2p(union
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
 				}
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 
-				//	Commented by Albert 20110718
-				//	No matter negotiating or negotiation failure, the driver should set up the restore P2P state timer.
+				/* 	Commented by Albert 20110718 */
+				/* 	No matter negotiating or negotiation failure, the driver should set up the restore P2P state timer. */
 #ifdef CONFIG_CONCURRENT_MODE
-				//	Commented by Albert 20120107
+				/* 	Commented by Albert 20120107 */
 				_set_timer(&pwdinfo->restore_p2p_state_timer, 3000);
-#else // CONFIG_CONCURRENT_MODE
+#else /*  CONFIG_CONCURRENT_MODE */
 				_set_timer(&pwdinfo->restore_p2p_state_timer, 5000);
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_CONCURRENT_MODE */
 				break;
 			}
 			case P2P_GO_NEGO_RESP:
@@ -5272,8 +5204,8 @@ unsigned int on_action_public_p2p(union
 
 				if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
 				{
-					//	Commented by Albert 20110425
-					//	The restore timer is enabled when issuing the nego request frame of rtw_p2p_connect function.
+					/* 	Commented by Albert 20110425 */
+					/* 	The restore timer is enabled when issuing the nego request frame of rtw_p2p_connect function. */
 					_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 					pwdinfo->nego_req_info.benable = false;
 					result = process_p2p_group_negotation_resp(pwdinfo, frame_body, len);
@@ -5288,7 +5220,7 @@ unsigned int on_action_public_p2p(union
 						}
 					}
 
-					//	Reset the dialog token for group negotiation frames.
+					/* 	Reset the dialog token for group negotiation frames. */
 					pwdinfo->negotiation_dialog_token = 1;
 
 					if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_FAIL))
@@ -5320,14 +5252,14 @@ unsigned int on_action_public_p2p(union
 			}
 			case P2P_INVIT_REQ:
 			{
-				//	Added by Albert 2010/10/05
-				//	Received the P2P Invite Request frame.
+				/* 	Added by Albert 2010/10/05 */
+				/* 	Received the P2P Invite Request frame. */
 
 				DBG_8192D("[%s] Got invite request frame!\n", __func__);
 				if ((p2p_ie=rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen)))
 				{
-					//	Parse the necessary information from the P2P Invitation Request frame.
-					//	For example: The MAC address of sending this P2P Invitation Request frame.
+					/* 	Parse the necessary information from the P2P Invitation Request frame. */
+					/* 	For example: The MAC address of sending this P2P Invitation Request frame. */
 					u32	attr_contentlen = 0;
 					u8	status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
 					struct group_id_info group_id;
@@ -5337,11 +5269,11 @@ unsigned int on_action_public_p2p(union
 					if (attr_contentlen)
 					{
 						rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_BSSID, pwdinfo->p2p_peer_interface_addr, &attr_contentlen);
-						//	Commented by Albert 20120510
-						//	Copy to the pwdinfo->p2p_peer_interface_addr.
-						//	So that the WFD UI (or Sigma) can get the peer interface address by using the following command.
-						//	#> iwpriv wlan0 p2p_get peer_ifa
-						//	After having the peer interface address, the sigma can find the correct conf file for wpa_supplicant.
+						/* 	Commented by Albert 20120510 */
+						/* 	Copy to the pwdinfo->p2p_peer_interface_addr. */
+						/* 	So that the WFD UI (or Sigma) can get the peer interface address by using the following command. */
+						/* 	#> iwpriv wlan0 p2p_get peer_ifa */
+						/* 	After having the peer interface address, the sigma can find the correct conf file for wpa_supplicant. */
 
 						if (attr_contentlen)
 						{
@@ -5353,7 +5285,7 @@ unsigned int on_action_public_p2p(union
 
 						if (invitation_flag & P2P_INVITATION_FLAGS_PERSISTENT)
 						{
-							//	Re-invoke the persistent group.
+							/* 	Re-invoke the persistent group. */
 
 							memset(&group_id, 0x00, sizeof(struct group_id_info));
 							rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, (u8*) &group_id, &attr_contentlen);
@@ -5361,14 +5293,14 @@ unsigned int on_action_public_p2p(union
 							{
 								if (_rtw_memcmp(group_id.go_device_addr, myid(&padapter->eeprompriv), ETH_ALEN))
 								{
-									//	The p2p device sending this p2p invitation request wants this Wi-Fi device to be the persistent GO.
+									/* 	The p2p device sending this p2p invitation request wants this Wi-Fi device to be the persistent GO. */
 									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_GO);
 									rtw_p2p_set_role(pwdinfo, P2P_ROLE_GO);
 									status_code = P2P_STATUS_SUCCESS;
 								}
 								else
 								{
-									//	The p2p device sending this p2p invitation request wants to be the persistent GO.
+									/* 	The p2p device sending this p2p invitation request wants to be the persistent GO. */
 									if (is_matched_in_profilelist(pwdinfo->p2p_peer_interface_addr, &pwdinfo->profileinfo[ 0 ]))
 									{
 										u8 operatingch_info[5] = { 0x00 };
@@ -5376,7 +5308,7 @@ unsigned int on_action_public_p2p(union
 										{
 											if (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, (u32)operatingch_info[4]))
 											{
-												//	The operating channel is acceptable for this device.
+												/* 	The operating channel is acceptable for this device. */
 												pwdinfo->rx_invitereq_info.operation_ch[0]= operatingch_info[4];
 												pwdinfo->rx_invitereq_info.scan_op_ch_only = 1;
 												_set_timer(&pwdinfo->reset_ch_sitesurvey, P2P_RESET_SCAN_CH);
@@ -5386,7 +5318,7 @@ unsigned int on_action_public_p2p(union
 												}
 											else
 											{
-												//	The operating channel isn't supported by this device.
+												/* 	The operating channel isn't supported by this device. */
 												rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
 												rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
 												status_code = P2P_STATUS_FAIL_NO_COMMON_CH;
@@ -5395,9 +5327,9 @@ unsigned int on_action_public_p2p(union
 										}
 										else
 										{
-											//	Commented by Albert 20121130
-											//	Intel will use the different P2P IE to store the operating channel information
-											//	Workaround for Intel WiDi 3.5
+											/* 	Commented by Albert 20121130 */
+											/* 	Intel will use the different P2P IE to store the operating channel information */
+											/* 	Workaround for Intel WiDi 3.5 */
 											rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_MATCH);
 											rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 											status_code = P2P_STATUS_SUCCESS;
@@ -5409,7 +5341,7 @@ unsigned int on_action_public_p2p(union
 										#ifdef CONFIG_INTEL_WIDI
 										memcpy(pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN);
 										rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
-										#endif //CONFIG_INTEL_WIDI
+										#endif /* CONFIG_INTEL_WIDI */
 
 										status_code = P2P_STATUS_FAIL_UNKNOWN_P2PGROUP;
 									}
@@ -5423,7 +5355,7 @@ unsigned int on_action_public_p2p(union
 						}
 						else
 						{
-							//	Received the invitation to join a P2P group.
+							/* 	Received the invitation to join a P2P group. */
 
 							memset(&group_id, 0x00, sizeof(struct group_id_info));
 							rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, (u8*) &group_id, &attr_contentlen);
@@ -5431,18 +5363,18 @@ unsigned int on_action_public_p2p(union
 							{
 								if (_rtw_memcmp(group_id.go_device_addr, myid(&padapter->eeprompriv), ETH_ALEN))
 								{
-									//	In this case, the GO can't be myself.
+									/* 	In this case, the GO can't be myself. */
 									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_DISMATCH);
 									status_code = P2P_STATUS_FAIL_INFO_UNAVAILABLE;
 								}
 								else
 								{
-									//	The p2p device sending this p2p invitation request wants to join an existing P2P group
-									//	Commented by Albert 2012/06/28
-									//	In this case, this Wi-Fi device should use the iwpriv command to get the peer device address.
-									//	The peer device address should be the destination address for the provisioning discovery request.
-									//	Then, this Wi-Fi device should use the iwpriv command to get the peer interface address.
-									//	The peer interface address should be the address for WPS mac address
+									/* 	The p2p device sending this p2p invitation request wants to join an existing P2P group */
+									/* 	Commented by Albert 2012/06/28 */
+									/* 	In this case, this Wi-Fi device should use the iwpriv command to get the peer device address. */
+									/* 	The peer device address should be the destination address for the provisioning discovery request. */
+									/* 	Then, this Wi-Fi device should use the iwpriv command to get the peer interface address. */
+									/* 	The peer interface address should be the address for WPS mac address */
 									memcpy(pwdinfo->p2p_peer_device_addr, group_id.go_device_addr , ETH_ALEN);
 									rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
 									rtw_p2p_set_state(pwdinfo, P2P_STATE_RECV_INVITE_REQ_JOIN);
@@ -5473,7 +5405,7 @@ unsigned int on_action_public_p2p(union
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
 				}
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 				break;
 			}
 			case P2P_INVIT_RESP:
@@ -5545,8 +5477,8 @@ unsigned int on_action_public_p2p(union
 				process_p2p_provdisc_req(pwdinfo, pframe, len);
 				memcpy(pwdinfo->rx_prov_disc_info.peerDevAddr, GetAddr2Ptr(pframe), ETH_ALEN);
 
-				//20110902 Kurt
-				//Add the following statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered.
+				/* 20110902 Kurt */
+				/* Add the following statement to avoid receiving duplicate prov disc req. such that pre_p2p_state would be covered. */
 				if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
 					rtw_p2p_set_pre_state(pwdinfo, rtw_p2p_state(pwdinfo));
 
@@ -5558,15 +5490,15 @@ unsigned int on_action_public_p2p(union
 					padapter->mlmepriv.widi_state = INTEL_WIDI_STATE_WFD_CONNECTION;
 					intel_widi_wk_cmd(padapter, INTEL_WIDI_LISTEN_STOP_WK, NULL);
 				}
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 				break;
 
 			case P2P_PROVISION_DISC_RESP:
-				//	Commented by Albert 20110707
-				//	Should we check the pwdinfo->tx_prov_disc_info.bsent flag here??
+				/* 	Commented by Albert 20110707 */
+				/* 	Should we check the pwdinfo->tx_prov_disc_info.bsent flag here?? */
 				DBG_8192D("[%s] Got Provisioning Discovery Response Frame\n", __func__);
-				//	Commented by Albert 20110426
-				//	The restore timer is enabled when issuing the provisioing request frame in rtw_p2p_prov_disc function.
+				/* 	Commented by Albert 20110426 */
+				/* 	The restore timer is enabled when issuing the provisioing request frame in rtw_p2p_prov_disc function. */
 				_cancel_timer_ex(&pwdinfo->restore_p2p_state_timer);
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_RSP);
 				process_p2p_provdisc_resp(pwdinfo, pframe);
@@ -5575,7 +5507,7 @@ unsigned int on_action_public_p2p(union
 
 		}
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	return _SUCCESS;
 }
@@ -5673,8 +5605,8 @@ unsigned int OnAction_p2p(struct rtw_ada
 
 	DBG_8192D("%s\n", __func__);
 
-	//check RA matches or not
-	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))//for if1, sta/ap mode
+	/* check RA matches or not */
+	if (!_rtw_memcmp(myid(&(padapter->eeprompriv)), GetAddr1Ptr(pframe), ETH_ALEN))/* for if1, sta/ap mode */
 		return _SUCCESS;
 
 	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
@@ -5693,7 +5625,7 @@ unsigned int OnAction_p2p(struct rtw_ada
 		return _SUCCESS;
 	}
 	else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	{
 		len -= sizeof(struct rtw_ieee80211_hdr_3addr);
 		OUI_Subtype = frame_body[5];
@@ -5724,7 +5656,7 @@ unsigned int OnAction_p2p(struct rtw_ada
 
 		}
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	return _SUCCESS;
 }
@@ -5755,7 +5687,7 @@ unsigned int OnAction(struct rtw_adapter
 
 unsigned int DoReserved(struct rtw_adapter *padapter, union recv_frame *precv_frame)
 {
-	//DBG_8192D("rcvd mgt frame(%x, %x)\n", (GetFrameSubType(pframe) >> 4), *(unsigned int *)GetAddr1Ptr(pframe));
+	/* DBG_8192D("rcvd mgt frame(%x, %x)\n", (GetFrameSubType(pframe) >> 4), *(unsigned int *)GetAddr1Ptr(pframe)); */
 	return _SUCCESS;
 }
 
@@ -5801,7 +5733,7 @@ void update_mgnt_tx_rate(struct rtw_adap
 
 	pmlmeext->tx_rate = rate;
 
-	//DBG_8192D("%s(): rate = %x\n",__func__, rate);
+	/* DBG_8192D("%s(): rate = %x\n",__func__, rate); */
 }
 
 void update_mgntframe_attrib(struct rtw_adapter *padapter, struct pkt_attrib *pattrib)
@@ -5819,9 +5751,9 @@ void update_mgntframe_attrib(struct rtw_
 	pattrib->pktlen = 0;
 
 	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
-		pattrib->raid = 6;//b mode
+		pattrib->raid = 6;/* b mode */
 	else
-		pattrib->raid = 5;//a/g mode
+		pattrib->raid = 5;/* a/g mode */
 
 	pattrib->encrypt = _NO_PRIVACY_;
 	pattrib->bswenc = false;
@@ -5871,7 +5803,7 @@ s32 dump_mgntframe_and_wait_ack(struct r
 {
 #ifdef CONFIG_XMIT_ACK
 	s32 ret = _FAIL;
-	u32 timeout_ms = 500;//  500ms
+	u32 timeout_ms = 500;/*   500ms */
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 	#ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->pbuddy_adapter && !padapter->isprimary)
@@ -5894,11 +5826,11 @@ s32 dump_mgntframe_and_wait_ack(struct r
 	_exit_critical_mutex(&pxmitpriv->ack_tx_mutex);
 
 	 return ret;
-#else //!CONFIG_XMIT_ACK
+#else /* CONFIG_XMIT_ACK */
 	dump_mgntframe(padapter, pmgntframe);
 	rtw_msleep_os(50);
 	return _SUCCESS;
-#endif //!CONFIG_XMIT_ACK
+#endif /* CONFIG_XMIT_ACK */
 }
 
 int update_hidden_ssid(u8 *ies, u32 ies_len, u8 hidden_ssid_mode)
@@ -5909,7 +5841,7 @@ int update_hidden_ssid(u8 *ies, u32 ies_
 
 	ssid_ie = rtw_get_ie(ies,  WLAN_EID_SSID, &ssid_len_ori, ies_len);
 
-	//DBG_8192D("%s hidden_ssid_mode:%u, ssid_ie:%p, ssid_len_ori:%d\n", __func__, hidden_ssid_mode, ssid_ie, ssid_len_ori);
+	/* DBG_8192D("%s hidden_ssid_mode:%u, ssid_ie:%p, ssid_len_ori:%d\n", __func__, hidden_ssid_mode, ssid_ie, ssid_len_ori); */
 
 	if (ssid_ie && ssid_len_ori>0)
 	{
@@ -5950,17 +5882,17 @@ void issue_beacon(struct rtw_adapter *pa
 	struct xmit_priv	*pxmitpriv = &(padapter->xmitpriv);
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+#endif /* if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
 	u8	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 
-	//DBG_8192D("%s\n", __func__);
+	/* DBG_8192D("%s\n", __func__); */
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
@@ -5969,9 +5901,9 @@ void issue_beacon(struct rtw_adapter *pa
 	}
 #if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
 	spin_lock_bh(&pmlmepriv->bcn_update_lock);
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+#endif /* if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 	pattrib->qsel = 0x10;
@@ -5990,7 +5922,7 @@ void issue_beacon(struct rtw_adapter *pa
 	memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
 
 	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
-	//pmlmeext->mgnt_seq++;
+	/* pmlmeext->mgnt_seq++; */
 	SetFrameSubType(pframe, WIFI_BEACON);
 
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
@@ -5998,9 +5930,9 @@ void issue_beacon(struct rtw_adapter *pa
 
 	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
 	{
-		//DBG_8192D("ie len=%d\n", cur_network->IELength);
+		/* DBG_8192D("ie len=%d\n", cur_network->IELength); */
 #ifdef CONFIG_P2P
-		// for P2P : Primary Device Type & Device Name
+		/*  for P2P : Primary Device Type & Device Name */
 		u32 wpsielen=0, insert_len=0;
 		u8 *wpsie=NULL;
 		wpsie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wpsielen);
@@ -6029,7 +5961,7 @@ void issue_beacon(struct rtw_adapter *pa
 					pframe += pmlmepriv->wps_beacon_ie_len;
 					pattrib->pktlen += pmlmepriv->wps_beacon_ie_len;
 
-					//copy remainder_ie to pframe
+					/* copy remainder_ie to pframe */
 					memcpy(pframe, premainder_ie, remainder_ielen);
 					pframe += remainder_ielen;
 					pattrib->pktlen += remainder_ielen;
@@ -6042,66 +5974,66 @@ void issue_beacon(struct rtw_adapter *pa
 				}
 			}
 			else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 			{
 				pframe_wscie = pframe + wps_offset;
 				memcpy(pframe, cur_network->IEs, wps_offset+wpsielen);
 				pframe += (wps_offset + wpsielen);
 				pattrib->pktlen += (wps_offset + wpsielen);
 
-				//now pframe is end of wsc ie, insert Primary Device Type & Device Name
-				//	Primary Device Type
-				//	Type:
+				/* now pframe is end of wsc ie, insert Primary Device Type & Device Name */
+				/* 	Primary Device Type */
+				/* 	Type: */
 				*(u16*) (pframe + insert_len) = cpu_to_be16(WPS_ATTR_PRIMARY_DEV_TYPE);
 				insert_len += 2;
 
-				//	Length:
+				/* 	Length: */
 				*(u16*) (pframe + insert_len) = cpu_to_be16(0x0008);
 				insert_len += 2;
 
-				//	Value:
-				//	Category ID
+				/* 	Value: */
+				/* 	Category ID */
 				*(u16*) (pframe + insert_len) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 				insert_len += 2;
 
-				//	OUI
+				/* 	OUI */
 				*(u32*) (pframe + insert_len) = cpu_to_be32(WPSOUI);
 				insert_len += 4;
 
-				//	Sub Category ID
+				/* 	Sub Category ID */
 				*(u16*) (pframe + insert_len) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 				insert_len += 2;
 
 
-				//	Device Name
-				//	Type:
+				/* 	Device Name */
+				/* 	Type: */
 				*(u16*) (pframe + insert_len) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 				insert_len += 2;
 
-				//	Length:
+				/* 	Length: */
 				*(u16*) (pframe + insert_len) = cpu_to_be16(pwdinfo->device_name_len);
 				insert_len += 2;
 
-				//	Value:
+				/* 	Value: */
 				memcpy(pframe + insert_len, pwdinfo->device_name, pwdinfo->device_name_len);
 				insert_len += pwdinfo->device_name_len;
 
 
-				//update wsc ie length
+				/* update wsc ie length */
 				*(pframe_wscie+1) = (wpsielen -2) + insert_len;
 
-				//pframe move to end
+				/* pframe move to end */
 				pframe+=insert_len;
 				pattrib->pktlen += insert_len;
 
-				//copy remainder_ie to pframe
+				/* copy remainder_ie to pframe */
 				memcpy(pframe, premainder_ie, remainder_ielen);
 				pframe += remainder_ielen;
 				pattrib->pktlen += remainder_ielen;
 			}
 		}
 		else
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 		{
 			int len_diff;
 			memcpy(pframe, cur_network->IEs, cur_network->IELength);
@@ -6141,7 +6073,7 @@ void issue_beacon(struct rtw_adapter *pa
 					memcpy(pframe, pmlmepriv->p2p_beacon_ie, len);
 			}
 			else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 			{
 				len = build_beacon_p2p_ie(pwdinfo, pframe);
 			}
@@ -6151,7 +6083,7 @@ void issue_beacon(struct rtw_adapter *pa
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
 			if (true == pwdinfo->wfd_info->wfd_enable)
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 			{
 			len = build_beacon_wfd_ie(pwdinfo, pframe);
 			}
@@ -6165,69 +6097,69 @@ void issue_beacon(struct rtw_adapter *pa
 					memcpy(pframe, pmlmepriv->wfd_beacon_ie, len);
 			}
 			}
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 			pframe += len;
 			pattrib->pktlen += len;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 		}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 		goto _issue_bcn;
 
 	}
 
-	//below for ad-hoc mode
+	/* below for ad-hoc mode */
 
-	//timestamp will be inserted by hardware
+	/* timestamp will be inserted by hardware */
 	pframe += 8;
 	pattrib->pktlen += 8;
 
-	// beacon interval: 2 bytes
+	/*  beacon interval: 2 bytes */
 
 	memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
 
 	pframe += 2;
 	pattrib->pktlen += 2;
 
-	// capability info: 2 bytes
+	/*  capability info: 2 bytes */
 
 	memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
 
 	pframe += 2;
 	pattrib->pktlen += 2;
 
-	// SSID
+	/*  SSID */
 	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pattrib->pktlen);
 
-	// supported rates...
+	/*  supported rates... */
 	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
 	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pattrib->pktlen);
 
-	// DS parameter set
+	/*  DS parameter set */
 	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
 
-	//if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	/* if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) */
 	{
 		u8 erpinfo=0;
 		u32 ATIMWindow;
-		// IBSS Parameter Set...
-		//ATIMWindow = cur->Configuration.ATIMWindow;
+		/*  IBSS Parameter Set... */
+		/* ATIMWindow = cur->Configuration.ATIMWindow; */
 		ATIMWindow = 0;
 		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);
 
-		//ERP IE
+		/* ERP IE */
 		pframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pattrib->pktlen);
 	}
 
 
-	// EXTERNDED SUPPORTED RATE
+	/*  EXTERNDED SUPPORTED RATE */
 	if (rate_len > 8)
 	{
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pattrib->pktlen);
 	}
 
 
-	//todo:HT for adhoc
+	/* todo:HT for adhoc */
 
 _issue_bcn:
 
@@ -6235,7 +6167,7 @@ _issue_bcn:
 	pmlmepriv->update_bcn = false;
 
 	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+#endif /* if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */
 
 	if ((pattrib->pktlen + TXDESC_SIZE) > 512)
 	{
@@ -6245,7 +6177,7 @@ _issue_bcn:
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
-	//DBG_8192D("issue bcn_sz=%d\n", pattrib->last_txcmdsz);
+	/* DBG_8192D("issue bcn_sz=%d\n", pattrib->last_txcmdsz); */
 
 	dump_mgntframe(padapter, pmgntframe);
 }
@@ -6263,7 +6195,7 @@ void issue_probersp(struct rtw_adapter *
 	u8 *pwps_ie;
 	uint wps_ielen;
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-#endif //#if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME)
+#endif /* if defined (CONFIG_AP_MODE) && defined (CONFIG_NATIVEAP_MLME) */
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
@@ -6272,10 +6204,10 @@ void issue_probersp(struct rtw_adapter *
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
-#endif //CONFIG_P2P
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_P2P */
 
-	//DBG_8192D("%s\n", __func__);
+	/* DBG_8192D("%s\n", __func__); */
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
@@ -6284,7 +6216,7 @@ void issue_probersp(struct rtw_adapter *
 	}
 
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -6319,7 +6251,7 @@ void issue_probersp(struct rtw_adapter *
 	{
 		pwps_ie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
 
-		//inerset & update wps_probe_resp_ie
+		/* inerset & update wps_probe_resp_ie */
 		if ((pmlmepriv->wps_probe_resp_ie!=NULL) && pwps_ie && (wps_ielen>0))
 		{
 			uint wps_offset, remainder_ielen;
@@ -6335,7 +6267,7 @@ void issue_probersp(struct rtw_adapter *
 			pframe += wps_offset;
 			pattrib->pktlen += wps_offset;
 
-			wps_ielen = (uint)pmlmepriv->wps_probe_resp_ie[1];//to get ie data len
+			wps_ielen = (uint)pmlmepriv->wps_probe_resp_ie[1];/* to get ie data len */
 			if ((wps_offset+wps_ielen+2)<=MAX_IE_SZ)
 			{
 				memcpy(pframe, pmlmepriv->wps_probe_resp_ie, wps_ielen+2);
@@ -6394,58 +6326,58 @@ void issue_probersp(struct rtw_adapter *
 	else
 #endif
 	{
-		//timestamp will be inserted by hardware
+		/* timestamp will be inserted by hardware */
 		pframe += 8;
 		pattrib->pktlen += 8;
 
-		// beacon interval: 2 bytes
+		/*  beacon interval: 2 bytes */
 
 		memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
 
 		pframe += 2;
 		pattrib->pktlen += 2;
 
-		// capability info: 2 bytes
+		/*  capability info: 2 bytes */
 
 		memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
 
 		pframe += 2;
 		pattrib->pktlen += 2;
 
-		//below for ad-hoc mode
+		/* below for ad-hoc mode */
 
-		// SSID
+		/*  SSID */
 		pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pattrib->pktlen);
 
-		// supported rates...
+		/*  supported rates... */
 		rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
 		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pattrib->pktlen);
 
-		// DS parameter set
+		/*  DS parameter set */
 		pframe =rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
 
 		if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 		{
 			u8 erpinfo=0;
 			u32 ATIMWindow;
-			// IBSS Parameter Set...
-			//ATIMWindow = cur->Configuration.ATIMWindow;
+			/*  IBSS Parameter Set... */
+			/* ATIMWindow = cur->Configuration.ATIMWindow; */
 			ATIMWindow = 0;
 			pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);
 
-			//ERP IE
+			/* ERP IE */
 			pframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pattrib->pktlen);
 		}
 
 
-		// EXTERNDED SUPPORTED RATE
+		/*  EXTERNDED SUPPORTED RATE */
 		if (rate_len > 8)
 		{
 			pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pattrib->pktlen);
 		}
 
 
-		//todo:HT for adhoc
+		/* todo:HT for adhoc */
 
 	}
 
@@ -6456,13 +6388,13 @@ void issue_probersp(struct rtw_adapter *
 #ifdef CONFIG_IOCTL_CFG80211
 		if (wdev_to_priv(padapter->rtw_wdev)->p2p_enabled)
 		{
-			//if pwdinfo->role == P2P_ROLE_DEVICE will call issue_probersp_p2p()
+			/* if pwdinfo->role == P2P_ROLE_DEVICE will call issue_probersp_p2p() */
 			len = pmlmepriv->p2p_go_probe_resp_ie_len;
 			if (pmlmepriv->p2p_go_probe_resp_ie && len>0)
 				memcpy(pframe, pmlmepriv->p2p_go_probe_resp_ie, len);
 		}
 		else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 		{
 			len = build_probe_resp_p2p_ie(pwdinfo, pframe);
 		}
@@ -6473,7 +6405,7 @@ void issue_probersp(struct rtw_adapter *
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
 		if (true == pwdinfo->wfd_info->wfd_enable)
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 		{
 			len = build_probe_resp_wfd_ie(pwdinfo, pframe, 0);
 		}
@@ -6487,13 +6419,13 @@ void issue_probersp(struct rtw_adapter *
 				memcpy(pframe, pmlmepriv->wfd_probe_resp_ie, len);
 			}
 		}
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 		pframe += len;
 		pattrib->pktlen += len;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
@@ -6528,7 +6460,7 @@ int _issue_probereq(struct rtw_adapter *
 		goto exit;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -6545,13 +6477,13 @@ int _issue_probereq(struct rtw_adapter *
 
 	if (da)
 	{
-		//	unicast probe request frame
+		/* 	unicast probe request frame */
 		memcpy(pwlanhdr->addr1, da, ETH_ALEN);
 		memcpy(pwlanhdr->addr3, da, ETH_ALEN);
 	}
 	else
 	{
-		//	broadcast probe request frame
+		/* 	broadcast probe request frame */
 		memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
 		memcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);
 	}
@@ -6582,13 +6514,12 @@ int _issue_probereq(struct rtw_adapter *
 		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
 	}
 
-	//add wps_ie for wps2.0
+	/* add wps_ie for wps2.0 */
 	if (pmlmepriv->wps_probe_req_ie_len>0 && pmlmepriv->wps_probe_req_ie)
 	{
 		memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
 		pframe += pmlmepriv->wps_probe_req_ie_len;
 		pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
-		//pmlmepriv->wps_probe_req_ie_len = 0 ;//reset to zero
 	}
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
@@ -6653,7 +6584,7 @@ exit:
 	return ret;
 }
 
-// if psta == NULL, indiate we are station(client) now...
+/*  if psta == NULL, indiate we are station(client) now... */
 void issue_auth(struct rtw_adapter *padapter, struct sta_info *psta, unsigned short status)
 {
 	struct xmit_frame			*pmgntframe;
@@ -6673,7 +6604,7 @@ void issue_auth(struct rtw_adapter *pada
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -6693,7 +6624,7 @@ void issue_auth(struct rtw_adapter *pada
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
 
-	if (psta)// for AP mode
+	if (psta)/*  for AP mode */
 	{
 #ifdef CONFIG_NATIVEAP_MLME
 
@@ -6702,7 +6633,7 @@ void issue_auth(struct rtw_adapter *pada
 		memcpy(pwlanhdr->addr3, myid(&(padapter->eeprompriv)), ETH_ALEN);
 
 
-		// setting auth algo number
+		/*  setting auth algo number */
 		val16 = (u16)psta->authalg;
 
 		if (status != _STATS_SUCCESSFUL_)
@@ -6715,17 +6646,17 @@ void issue_auth(struct rtw_adapter *pada
 
 		pframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
 
-		// setting auth seq number
+		/*  setting auth seq number */
 		val16 =(u16)psta->auth_seq;
 		val16 = cpu_to_le16(val16);
 		pframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
 
-		// setting status code...
+		/*  setting status code... */
 		val16 = status;
 		val16 = cpu_to_le16(val16);
 		pframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&val16, &(pattrib->pktlen));
 
-		// added challenging text...
+		/*  added challenging text... */
 		if ((psta->auth_seq == 2) && (psta->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
 		{
 			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, psta->chg_txt, &(pattrib->pktlen));
@@ -6738,18 +6669,18 @@ void issue_auth(struct rtw_adapter *pada
 		memcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);
 		memcpy(pwlanhdr->addr3, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);
 
-		// setting auth algo number
-		val16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)? 1: 0;// 0:OPEN System, 1:Shared key
+		/*  setting auth algo number */
+		val16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)? 1: 0;/*  0:OPEN System, 1:Shared key */
 		if (val16)	{
 			val16 = cpu_to_le16(val16);
 			use_shared_key = 1;
 		}
-		//DBG_8192D("%s auth_algo= %s auth_seq=%d\n",__func__,(pmlmeinfo->auth_algo==0)?"OPEN":"SHARED",pmlmeinfo->auth_seq);
+		/* DBG_8192D("%s auth_algo= %s auth_seq=%d\n",__func__,(pmlmeinfo->auth_algo==0)?"OPEN":"SHARED",pmlmeinfo->auth_seq); */
 
-		//setting IV for auth seq #3
+		/* setting IV for auth seq #3 */
 		if ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
 		{
-			//DBG_8192D("==> iv(%d),key_index(%d)\n",pmlmeinfo->iv,pmlmeinfo->key_index);
+			/* DBG_8192D("==> iv(%d),key_index(%d)\n",pmlmeinfo->iv,pmlmeinfo->key_index); */
 			val32 = ((pmlmeinfo->iv++) | (pmlmeinfo->key_index << 30));
 			val32 = cpu_to_le32(val32);
 			pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *)&val32, &(pattrib->pktlen));
@@ -6759,18 +6690,18 @@ void issue_auth(struct rtw_adapter *pada
 
 		pframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
 
-		// setting auth seq number
+		/*  setting auth seq number */
 		val16 = pmlmeinfo->auth_seq;
 		val16 = cpu_to_le16(val16);
 		pframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
 
 
-		// setting status code...
+		/*  setting status code... */
 		val16 = status;
 		val16 = cpu_to_le16(val16);
 		pframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&val16, &(pattrib->pktlen));
 
-		// then checking to see if sending challenging text...
+		/*  then checking to see if sending challenging text... */
 		if ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
 		{
 			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, pmlmeinfo->chg_txt, &(pattrib->pktlen));
@@ -6818,8 +6749,8 @@ void issue_asocrsp(struct rtw_adapter *p
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
-#endif //CONFIG_P2P
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_P2P */
 
 	DBG_8192D("%s\n", __func__);
 
@@ -6828,7 +6759,7 @@ void issue_asocrsp(struct rtw_adapter *p
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -6857,7 +6788,7 @@ void issue_asocrsp(struct rtw_adapter *p
 	pattrib->pktlen += pattrib->hdrlen;
 	pframe += pattrib->hdrlen;
 
-	//capability
+	/* capability */
 	val = *(unsigned short *)rtw_get_capability_from_ie(ie);
 
 	pframe = rtw_set_fixed_ie(pframe, _CAPABILITY_ , (unsigned char *)&val, &(pattrib->pktlen));
@@ -6883,8 +6814,8 @@ void issue_asocrsp(struct rtw_adapter *p
 	{
 		uint ie_len=0;
 
-		//FILL HT CAP INFO IE
-		//p = hostapd_eid_ht_capabilities_info(hapd, p);
+		/* FILL HT CAP INFO IE */
+		/* p = hostapd_eid_ht_capabilities_info(hapd, p); */
 		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
 		if (pbuf && ie_len>0)
 		{
@@ -6893,8 +6824,8 @@ void issue_asocrsp(struct rtw_adapter *p
 			pattrib->pktlen +=(ie_len+2);
 		}
 
-		//FILL HT ADD INFO IE
-		//p = hostapd_eid_ht_operation(hapd, p);
+		/* FILL HT ADD INFO IE */
+		/* p = hostapd_eid_ht_operation(hapd, p); */
 		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
 		if (pbuf && ie_len>0)
 		{
@@ -6906,7 +6837,7 @@ void issue_asocrsp(struct rtw_adapter *p
 	}
 #endif
 
-	//FILL WMM IE
+	/* FILL WMM IE */
 	if ((pstat->flags & WLAN_STA_WME) && (pmlmepriv->qospriv.qos_option))
 	{
 		uint ie_len=0;
@@ -6938,7 +6869,7 @@ void issue_asocrsp(struct rtw_adapter *p
 		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6 , REALTEK_96B_IE, &(pattrib->pktlen));
 	}
 
-	//add WPS IE ie for wps 2.0
+	/* add WPS IE ie for wps 2.0 */
 	if (pmlmepriv->wps_assoc_resp_ie && pmlmepriv->wps_assoc_resp_ie_len>0)
 	{
 		memcpy(pframe, pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
@@ -6958,20 +6889,20 @@ void issue_asocrsp(struct rtw_adapter *p
 		pframe += len;
 		pattrib->pktlen += len;
 	}
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 #ifdef CONFIG_WFD
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO)
 #ifdef CONFIG_IOCTL_CFG80211
 		&& (true == pwdinfo->wfd_info->wfd_enable)
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	)
 	{
 		wfdielen = build_assoc_resp_wfd_ie(pwdinfo, pframe);
 		pframe += wfdielen;
 		pattrib->pktlen += wfdielen;
 	}
-#endif //CONFIG_WFD
-#endif //CONFIG_P2P
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_P2P */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -7005,19 +6936,19 @@ void issue_assocreq(struct rtw_adapter *
 	u16					p2pielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
-#endif //CONFIG_P2P
+#endif /* CONFIG_WFD */
+#endif /* CONFIG_P2P */
 
 #ifdef CONFIG_DFS
 	u16	cap;
 	u8 pow_cap_ele[2] = { 0x00 };
-	u8 sup_ch[ 30 * 2 ] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	//For supported channel
-#endif //CONFIG_DFS
+	u8 sup_ch[ 30 * 2 ] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
+#endif /* CONFIG_DFS */
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 		goto exit;
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -7040,43 +6971,43 @@ void issue_assocreq(struct rtw_adapter *
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
-	//caps
+	/* caps */
 
 #ifdef CONFIG_DFS
 	memcpy(&cap, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
 	if (pmlmeext->cur_channel > 14)
-		cap |= BIT(8); //Spectrum Mgmt. Enabled
+		cap |= BIT(8); /* Spectrum Mgmt. Enabled */
 	memcpy(pframe, &cap, 2);
 #else
 	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
-#endif //CONFIG_DFS
+#endif /* CONFIG_DFS */
 
 	pframe += 2;
 	pattrib->pktlen += 2;
 
-	//listen interval
-	//todo: listen interval for power saving
+	/* listen interval */
+	/* todo: listen interval for power saving */
 	val16 = cpu_to_le16(3);
 	memcpy(pframe ,(unsigned char *)&val16, 2);
 	pframe += 2;
 	pattrib->pktlen += 2;
 
-	//SSID
+	/* SSID */
 	pframe = rtw_set_ie(pframe, _SSID_IE_,  pmlmeinfo->network.Ssid.SsidLength, pmlmeinfo->network.Ssid.Ssid, &(pattrib->pktlen));
 
-	//supported rate & extended supported rate
+	/* supported rate & extended supported rate */
 
 	get_rate_set(padapter, sta_bssrate, &sta_bssrate_len);
 
-	if (pmlmeext->cur_channel == 14)// for JAPAN, channel 14 can only uses B Mode(CCK)
+	if (pmlmeext->cur_channel == 14)/*  for JAPAN, channel 14 can only uses B Mode(CCK) */
 	{
 		sta_bssrate_len = 4;
 	}
 
 
-	//for (i = 0; i < sta_bssrate_len; i++) {
-	//	DBG_8192D("sta_bssrate[%d]=%02X\n", i, sta_bssrate[i]);
-	//}
+	/* for (i = 0; i < sta_bssrate_len; i++) { */
+	/* 	DBG_8192D("sta_bssrate[%d]=%02X\n", i, sta_bssrate[i]); */
+	/*  */
 
 	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
 		if (pmlmeinfo->network.SupportedRates[i] == 0) break;
@@ -7088,23 +7019,23 @@ void issue_assocreq(struct rtw_adapter *
 		if (pmlmeinfo->network.SupportedRates[i] == 0) break;
 
 
-		// Check if the AP's supported rates are also supported by STA.
+		/*  Check if the AP's supported rates are also supported by STA. */
 		for (j=0; j < sta_bssrate_len; j++) {
-			 // Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP
+			 /*  Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP */
 			if ((pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK)
 					== (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK)) {
-				//DBG_8192D("match i = %d, j=%d\n", i, j);
+				/* DBG_8192D("match i = %d, j=%d\n", i, j); */
 				break;
 			} else {
-				//DBG_8192D("not match: %02X != %02X\n", (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK), (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK));
+				/* DBG_8192D("not match: %02X != %02X\n", (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK), (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK)); */
 			}
 		}
 
 		if (j == sta_bssrate_len) {
-			// the rate is not supported by STA
+			/*  the rate is not supported by STA */
 			DBG_8192D("%s(): the rate[%d]=%02X is not supported by STA!\n",__func__, i, pmlmeinfo->network.SupportedRates[i]);
 		} else {
-			// the rate is supported by STA
+			/*  the rate is supported by STA */
 			bssrate[index++] = pmlmeinfo->network.SupportedRates[i];
 		}
 	}
@@ -7115,7 +7046,7 @@ void issue_assocreq(struct rtw_adapter *
 	if (bssrate_len == 0) {
 		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
 		rtw_free_xmitframe(pxmitpriv, pmgntframe);
-		goto exit; //don't connect to AP if no joint supported rate
+		goto exit; /* don't connect to AP if no joint supported rate */
 	}
 
 
@@ -7132,16 +7063,16 @@ void issue_assocreq(struct rtw_adapter *
 #ifdef CONFIG_DFS
 	if (pmlmeext->cur_channel > 14)
 	{
-		pow_cap_ele[0] = 13;	// Minimum transmit power capability
-		pow_cap_ele[1] = 21;	// Maximum transmit power capability
+		pow_cap_ele[0] = 13;	/*  Minimum transmit power capability */
+		pow_cap_ele[1] = 21;	/*  Maximum transmit power capability */
 		pframe = rtw_set_ie(pframe, _POW_CAP_IE_, 2, pow_cap_ele, &(pattrib->pktlen));
 
-		//supported channels
+		/* supported channels */
 		do{
 			if (pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14)
 			{
-				sup_ch[0] = 1;	//First channel number
-				sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	//Number of channel
+				sup_ch[0] = 1;	/* First channel number */
+				sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	/* Number of channel */
 			}
 			else
 			{
@@ -7153,9 +7084,9 @@ void issue_assocreq(struct rtw_adapter *
 		while (pmlmeext->channel_set[sup_ch_idx].ChannelNum != 0);
 		pframe = rtw_set_ie(pframe, _SUPPORTED_CH_IE_, idx_5g, sup_ch, &(pattrib->pktlen));
 	}
-#endif //CONFIG_DFS
+#endif /* CONFIG_DFS */
 
-	//RSN
+	/* RSN */
 	p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(struct ndis_802_11_fixed_ies)), _RSN_IE_2_, &ie_len, (pmlmeinfo->network.IELength - sizeof(struct ndis_802_11_fixed_ies)));
 	if (p != NULL)
 	{
@@ -7163,7 +7094,7 @@ void issue_assocreq(struct rtw_adapter *
 	}
 
 #ifdef CONFIG_80211N_HT
-	//HT caps
+	/* HT caps */
 	if (padapter->mlmepriv.htpriv.ht_option==true)
 	{
 		p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(struct ndis_802_11_fixed_ies)), _HT_CAPABILITY_IE_, &ie_len, (pmlmeinfo->network.IELength - sizeof(struct ndis_802_11_fixed_ies)));
@@ -7171,7 +7102,7 @@ void issue_assocreq(struct rtw_adapter *
 		{
 			memcpy(&(pmlmeinfo->HT_caps), (p + 2), sizeof(struct HT_caps_element));
 
-			//to disable 40M Hz support while gd_bw_40MHz_en = 0
+			/* to disable 40M Hz support while gd_bw_40MHz_en = 0 */
 			if (pmlmeext->cur_channel > 14)
 			{
 				if (pregpriv->cbw40_enable & BIT(1))
@@ -7190,7 +7121,7 @@ void issue_assocreq(struct rtw_adapter *
 				pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= BIT(1);
 			}
 
-			//todo: disable SM power save mode
+			/* todo: disable SM power save mode */
 			pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= 0x000c;
 
 			rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
@@ -7208,31 +7139,31 @@ void issue_assocreq(struct rtw_adapter *
 			default:
 				if (pregpriv->special_rf_path) {
 					if (pregpriv->rx_stbc)
-						pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);//RX STBC One spatial stream
+						pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);/* RX STBC One spatial stream */
 					memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
 					break;
 				}
 
-				if ((pregpriv->rx_stbc == 0x3) ||//enable for 2.4/5 GHz
-				    ((pmlmeext->cur_wireless_mode & WIRELESS_11_24N) && (pregpriv->rx_stbc == 0x1)) || //enable for 2.4GHz
-				    ((pmlmeext->cur_wireless_mode & WIRELESS_11_5N) && (pregpriv->rx_stbc == 0x2)) || //enable for 5GHz
+				if ((pregpriv->rx_stbc == 0x3) ||/* enable for 2.4/5 GHz */
+				    ((pmlmeext->cur_wireless_mode & WIRELESS_11_24N) && (pregpriv->rx_stbc == 0x1)) || /* enable for 2.4GHz */
+				    ((pmlmeext->cur_wireless_mode & WIRELESS_11_5N) && (pregpriv->rx_stbc == 0x2)) || /* enable for 5GHz */
 				    (pregpriv->wifi_spec==1)) {
 					DBG_8192D("declare supporting RX STBC\n");
-					pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0200);//RX STBC two spatial stream
+					pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0200);/* RX STBC two spatial stream */
 				}
 				#ifdef CONFIG_DISABLE_MCS13TO15
 				if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40 && (pregpriv->wifi_spec!=1))
 					memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R_MCS13TO15_OFF, 16);
 				else
 					memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R, 16);
-				#else //CONFIG_DISABLE_MCS13TO15
+				#else /* CONFIG_DISABLE_MCS13TO15 */
 				memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R, 16);
-				#endif //CONFIG_DISABLE_MCS13TO15
+				#endif /* CONFIG_DISABLE_MCS13TO15 */
 				break;
 			}
 #ifdef RTL8192C_RECONFIG_TO_1T1R
 			if (pregpriv->rx_stbc)
-				pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);//RX STBC One spatial stream
+				pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);/* RX STBC One spatial stream */
 
 			memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
 #endif
@@ -7243,7 +7174,7 @@ void issue_assocreq(struct rtw_adapter *
 	}
 #endif
 
-	//vendor specific IE, such as WPA, WMM, WPS
+	/* vendor specific IE, such as WPA, WMM, WPS */
 	for (i = sizeof(struct ndis_802_11_fixed_ies); i < pmlmeinfo->network.IELength;)
 	{
 		pIE = (struct ndis_802_11_variable_ies *)(pmlmeinfo->network.IEs + i);
@@ -7257,9 +7188,9 @@ void issue_assocreq(struct rtw_adapter *
 				{
 					if (!padapter->registrypriv.wifi_spec)
 					{
-						//Commented by Kurt 20110629
-						//In some older APs, WPS handshake
-						//would be fail if we append vender extensions informations to AP
+						/* Commented by Kurt 20110629 */
+						/* In some older APs, WPS handshake */
+						/* would be fail if we append vender extensions informations to AP */
 						if (_rtw_memcmp(pIE->data, WPS_OUI, 4)) {
 							pIE->Length=14;
 						}
@@ -7293,79 +7224,79 @@ void issue_assocreq(struct rtw_adapter *
 		}
 	}
 	else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	{
 		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) && !rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 		{
-			//	Should add the P2P IE in the association request frame.
-			//	P2P OUI
+			/* 	Should add the P2P IE in the association request frame. */
+			/* 	P2P OUI */
 
 			p2pielen = 0;
 			p2pie[ p2pielen++ ] = 0x50;
 			p2pie[ p2pielen++ ] = 0x6F;
 			p2pie[ p2pielen++ ] = 0x9A;
-			p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+			p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-			//	Commented by Albert 20101109
-			//	According to the P2P Specification, the association request frame should contain 3 P2P attributes
-			//	1. P2P Capability
-			//	2. Extended Listen Timing
-			//	3. Device Info
-			//	Commented by Albert 20110516
-			//	4. P2P Interface
+			/* 	Commented by Albert 20101109 */
+			/* 	According to the P2P Specification, the association request frame should contain 3 P2P attributes */
+			/* 	1. P2P Capability */
+			/* 	2. Extended Listen Timing */
+			/* 	3. Device Info */
+			/* 	Commented by Albert 20110516 */
+			/* 	4. P2P Interface */
 
-			//	P2P Capability
-			//	Type:
+			/* 	P2P Capability */
+			/* 	Type: */
 			p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
 			p2pielen += 2;
 
-			//	Value:
-			//	Device Capability Bitmap, 1 byte
+			/* 	Value: */
+			/* 	Device Capability Bitmap, 1 byte */
 			p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
-			//	Group Capability Bitmap, 1 byte
+			/* 	Group Capability Bitmap, 1 byte */
 			if (pwdinfo->persistent_supported)
 				p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 			else
 				p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
 
-			//	Extended Listen Timing
-			//	Type:
+			/* 	Extended Listen Timing */
+			/* 	Type: */
 			p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
 			p2pielen += 2;
 
-			//	Value:
-			//	Availability Period
+			/* 	Value: */
+			/* 	Availability Period */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 			p2pielen += 2;
 
-			//	Availability Interval
+			/* 	Availability Interval */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
 			p2pielen += 2;
 
-			//	Device Info
-			//	Type:
+			/* 	Device Info */
+			/* 	Type: */
 			p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
-			//	Length:
-			//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
-			//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
+			/* 	Length: */
+			/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
+			/* 	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
 			p2pielen += 2;
 
-			//	Value:
-			//	P2P Device Address
+			/* 	Value: */
+			/* 	P2P Device Address */
 			memcpy(p2pie + p2pielen, myid(&padapter->eeprompriv), ETH_ALEN);
 			p2pielen += ETH_ALEN;
 
-			//	Config Method
-			//	This field should be big endian. Noted by P2P specification.
+			/* 	Config Method */
+			/* 	This field should be big endian. Noted by P2P specification. */
 			if ((pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PEER_DISPLAY_PIN) ||
 				(pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_SELF_DISPLAY_PIN))
 			{
@@ -7378,68 +7309,68 @@ void issue_assocreq(struct rtw_adapter *
 
 			p2pielen += 2;
 
-			//	Primary Device Type
-			//	Category ID
+			/* 	Primary Device Type */
+			/* 	Category ID */
 			*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
 			p2pielen += 2;
 
-			//	OUI
+			/* 	OUI */
 			*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
 			p2pielen += 4;
 
-			//	Sub Category ID
+			/* 	Sub Category ID */
 			*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
 			p2pielen += 2;
 
-			//	Number of Secondary Device Types
-			p2pie[ p2pielen++ ] = 0x00;	//	No Secondary Device Type List
+			/* 	Number of Secondary Device Types */
+			p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
 
-			//	Device Name
-			//	Type:
+			/* 	Device Name */
+			/* 	Type: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 			p2pielen += 2;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
 			p2pielen += 2;
 
-			//	Value:
+			/* 	Value: */
 			memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
 			p2pielen += pwdinfo->device_name_len;
 
-			//	P2P Interface
-			//	Type:
+			/* 	P2P Interface */
+			/* 	Type: */
 			p2pie[ p2pielen++ ] = P2P_ATTR_INTERFACE;
 
-			//	Length:
+			/* 	Length: */
 			*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x000D);
 			p2pielen += 2;
 
-			//	Value:
-			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	//	P2P Device Address
+			/* 	Value: */
+			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	/* 	P2P Device Address */
 			p2pielen += ETH_ALEN;
 
-			p2pie[ p2pielen++ ] = 1;	//	P2P Interface Address Count
+			p2pie[ p2pielen++ ] = 1;	/* 	P2P Interface Address Count */
 
-			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	//	P2P Interface Address List
+			memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);	/* 	P2P Interface Address List */
 			p2pielen += ETH_ALEN;
 
 			pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &pattrib->pktlen);
 
 #ifdef CONFIG_WFD
-			//wfdielen = build_assoc_req_wfd_ie(pwdinfo, pframe);
-			//pframe += wfdielen;
-			//pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+			/* wfdielen = build_assoc_req_wfd_ie(pwdinfo, pframe); */
+			/* pframe += wfdielen; */
+			/* pattrib->pktlen += wfdielen; */
+#endif /* CONFIG_WFD */
 		}
 	}
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 #ifdef CONFIG_WFD
 #ifdef CONFIG_IOCTL_CFG80211
 	if (true == pwdinfo->wfd_info->wfd_enable)
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	{
 		wfdielen = build_assoc_req_wfd_ie(pwdinfo, pframe);
 		pframe += wfdielen;
@@ -7448,13 +7379,13 @@ void issue_assocreq(struct rtw_adapter *
 #ifdef CONFIG_IOCTL_CFG80211
 	else if (pmlmepriv->wfd_assoc_req_ie != NULL && pmlmepriv->wfd_assoc_req_ie_len>0)
 	{
-		//WFD IE
+		/* WFD IE */
 		memcpy(pframe, pmlmepriv->wfd_assoc_req_ie, pmlmepriv->wfd_assoc_req_ie_len);
 		pattrib->pktlen += pmlmepriv->wfd_assoc_req_ie_len;
 		pframe += pmlmepriv->wfd_assoc_req_ie_len;
 	}
-#endif //CONFIG_IOCTL_CFG80211
-#endif //CONFIG_WFD
+#endif /* CONFIG_IOCTL_CFG80211 */
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 	dump_mgntframe(padapter, pmgntframe);
@@ -7470,7 +7401,7 @@ exit:
 	return;
 }
 
-//when wait_ack is ture, this function shoule be called at process context
+/* when wait_ack is ture, this function shoule be called at process context */
 static int _issue_nulldata(struct rtw_adapter *padapter, unsigned char *da, unsigned int power_mode, int wait_ack)
 {
 	int ret = _FAIL;
@@ -7483,7 +7414,7 @@ static int _issue_nulldata(struct rtw_ad
 	struct mlme_ext_priv	*pmlmeext;
 	struct mlme_ext_info	*pmlmeinfo;
 
-	//DBG_8192D("%s:%d\n", __func__, power_mode);
+	/* DBG_8192D("%s:%d\n", __func__, power_mode); */
 
 	if (!padapter)
 		goto exit;
@@ -7497,7 +7428,7 @@ static int _issue_nulldata(struct rtw_ad
 		goto exit;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 	pattrib->retry_ctrl = false;
@@ -7552,8 +7483,8 @@ exit:
 }
 
 
-//when wait_ms >0 , this function shoule be called at process context
-//da == NULL for station mode
+/* when wait_ms >0 , this function shoule be called at process context */
+/* da == NULL for station mode */
 int issue_nulldata(struct rtw_adapter *padapter, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms)
 {
 	int ret;
@@ -7601,7 +7532,7 @@ exit:
 	return ret;
 }
 
-//when wait_ack is ture, this function shoule be called at process context
+/* when wait_ack is ture, this function shoule be called at process context */
 static int _issue_qos_nulldata(struct rtw_adapter *padapter, unsigned char *da, u16 tid, int wait_ack)
 {
 	int ret = _FAIL;
@@ -7621,7 +7552,7 @@ static int _issue_qos_nulldata(struct rt
 		goto exit;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -7686,8 +7617,8 @@ exit:
 	return ret;
 }
 
-//when wait_ms >0 , this function shoule be called at process context
-//da == NULL for station mode
+/* when wait_ms >0 , this function shoule be called at process context */
+/* da == NULL for station mode */
 int issue_qos_nulldata(struct rtw_adapter *padapter, unsigned char *da, u16 tid, int try_cnt, int wait_ms)
 {
 	int ret;
@@ -7748,7 +7679,7 @@ static int _issue_deauth(struct rtw_adap
 	int ret = _FAIL;
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 #ifdef CONFIG_P2P
 	if (!(rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE)) && (pwdinfo->rx_invitereq_info.scan_op_ch_only))
@@ -7756,14 +7687,14 @@ static int _issue_deauth(struct rtw_adap
 		_cancel_timer_ex(&pwdinfo->reset_ch_sitesurvey);
 		_set_timer(&pwdinfo->reset_ch_sitesurvey, 10);
 	}
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 	{
 		goto exit;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 	pattrib->retry_ctrl = false;
@@ -7875,7 +7806,7 @@ void issue_action_spct_ch_switch (struct
 	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
 		return;
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -7945,7 +7876,7 @@ void issue_action_BA(struct rtw_adapter
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -7957,7 +7888,7 @@ void issue_action_BA(struct rtw_adapter
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 
-	//memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	/* memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN); */
 	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
 	memcpy(pwlanhdr->addr2, myid(&(padapter->eeprompriv)), ETH_ALEN);
 	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
@@ -7979,25 +7910,21 @@ void issue_action_BA(struct rtw_adapter
 	{
 		switch (action)
 		{
-			case 0: //ADDBA req
+			case 0: /* ADDBA req */
 				do {
 					pmlmeinfo->dialogToken++;
 				} while (pmlmeinfo->dialogToken == 0);
 				pframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->dialogToken), &(pattrib->pktlen));
 
-				BA_para_set = (0x1002 | ((status & 0xf) << 2)); //immediate ack & 64 buffer size
-				//sys_mib.BA_para_set = 0x0802; //immediate ack & 32 buffer size
+				BA_para_set = (0x1002 | ((status & 0xf) << 2)); /* immediate ack & 64 buffer size */
 				BA_para_set = cpu_to_le16(BA_para_set);
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
 
-				//BA_timeout_value = 0xffff;//max: 65535 TUs(~ 65 ms)
-				BA_timeout_value = 5000;//~ 5ms
+				BA_timeout_value = 5000;/*  5ms */
 				BA_timeout_value = cpu_to_le16(BA_timeout_value);
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_timeout_value)), &(pattrib->pktlen));
 
-				//if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)) != NULL)
-				if ((psta = rtw_get_stainfo(pstapriv, raddr)) != NULL)
-				{
+				if ((psta = rtw_get_stainfo(pstapriv, raddr)) != NULL) {
 					start_seq = (psta->sta_xmitpriv.txseq_tid[status & 0x07]&0xfff) + 1;
 
 					DBG_8192D("BA_starting_seqctrl = %d for TID=%d\n", start_seq, status & 0x07);
@@ -8011,29 +7938,28 @@ void issue_action_BA(struct rtw_adapter
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_starting_seqctrl)), &(pattrib->pktlen));
 				break;
 
-			case 1: //ADDBA rsp
+			case 1: /* ADDBA rsp */
 				pframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->ADDBA_req.dialog_token), &(pattrib->pktlen));
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&status), &(pattrib->pktlen));
 
-				//BA_para_set = cpu_to_le16((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
-				BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
+				BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); /* 64 buffer size */
 
-				if (pregpriv->ampdu_amsdu==0)//disabled
+				if (pregpriv->ampdu_amsdu==0)/* disabled */
 					BA_para_set = cpu_to_le16(BA_para_set & ~BIT(0));
-				else if (pregpriv->ampdu_amsdu==1)//enabled
+				else if (pregpriv->ampdu_amsdu==1)/* enabled */
 					BA_para_set = cpu_to_le16(BA_para_set | BIT(0));
-				else //auto
+				else /* auto */
 					BA_para_set = cpu_to_le16(BA_para_set);
 
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(pmlmeinfo->ADDBA_req.BA_timeout_value)), &(pattrib->pktlen));
 				break;
-			case 2://DELBA
+			case 2:/* DELBA */
 				BA_para_set = (status & 0x1F) << 3;
 				BA_para_set = cpu_to_le16(BA_para_set);
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
 
-				reason_code = 37;//Requested from peer STA as it does not want to use the mechanism
+				reason_code = 37;/* Requested from peer STA as it does not want to use the mechanism */
 				reason_code = cpu_to_le16(reason_code);
 				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(reason_code)), &(pattrib->pktlen));
 				break;
@@ -8083,7 +8009,7 @@ static void issue_action_BSSCoexistPacke
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -8110,19 +8036,19 @@ static void issue_action_BSSCoexistPacke
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 
 
-	//
+	/*  */
 	if (pmlmepriv->num_FortyMHzIntolerant>0)
 	{
 		u8 iedata=0;
 
-		iedata |= BIT(2);//20 MHz BSS Width Request
+		iedata |= BIT(2);/* 20 MHz BSS Width Request */
 
 		pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
 
 	}
 
 
-	//
+	/*  */
 	memset(ICS, 0, sizeof(ICS));
 	if (pmlmepriv->num_sta_no_ht>0)
 	{
@@ -8149,7 +8075,7 @@ static void issue_action_BSSCoexistPacke
 			pbss_network = (struct wlan_bssid_ex *)&pnetwork->network;
 
 			p = rtw_get_ie(pbss_network->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, pbss_network->IELength - _FIXED_IE_LENGTH_);
-			if ((p==NULL) || (len==0))//non-HT
+			if ((p==NULL) || (len==0))/* non-HT */
 			{
 				if ((pbss_network->Configuration.DSConfig<=0) || (pbss_network->Configuration.DSConfig>14))
 					continue;
@@ -8172,7 +8098,7 @@ static void issue_action_BSSCoexistPacke
 				int j, k = 0;
 
 				InfoContent[k] = i;
-				//SET_BSS_INTOLERANT_ELE_REG_CLASS(InfoContent,i);
+				/* SET_BSS_INTOLERANT_ELE_REG_CLASS(InfoContent,i); */
 				k++;
 
 				for (j=1;j<=14;j++)
@@ -8181,8 +8107,8 @@ static void issue_action_BSSCoexistPacke
 					{
 						if (k<16)
 						{
-							InfoContent[k] = j; //channel number
-							//SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j);
+							InfoContent[k] = j; /* channel number */
+							/* SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j); */
 							k++;
 						}
 					}
@@ -8207,7 +8133,7 @@ unsigned int send_delba(struct rtw_adapt
 {
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info *psta = NULL;
-	//struct recv_reorder_ctrl *preorder_ctrl;
+	/* struct recv_reorder_ctrl *preorder_ctrl; */
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	u16 tid;
@@ -8220,9 +8146,9 @@ unsigned int send_delba(struct rtw_adapt
 	if (psta==NULL)
 		return _SUCCESS;
 
-	//DBG_8192D("%s:%s\n", __func__, (initiator==0)?"RX_DIR":"TX_DIR");
+	/* DBG_8192D("%s:%s\n", __func__, (initiator==0)?"RX_DIR":"TX_DIR"); */
 
-	if (initiator==0) // recipient
+	if (initiator==0) /*  recipient */
 	{
 		for (tid = 0;tid<MAXTID;tid++)
 		{
@@ -8239,9 +8165,9 @@ unsigned int send_delba(struct rtw_adapt
 			}
 		}
 	}
-	else if (initiator == 1)// originator
+	else if (initiator == 1)/*  originator */
 	{
-		//DBG_8192D("tx agg_enable_bitmap(0x%08x)\n", psta->htpriv.agg_enable_bitmap);
+		/* DBG_8192D("tx agg_enable_bitmap(0x%08x)\n", psta->htpriv.agg_enable_bitmap); */
 		for (tid = 0;tid<MAXTID;tid++)
 		{
 			if (psta->htpriv.agg_enable_bitmap & BIT(tid))
@@ -8327,13 +8253,13 @@ void site_survey(struct rtw_adapter *pad
 
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 	u8 stay_buddy_ch = 0;
-#endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
 
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 	struct mlme_ext_priv *pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
 
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 	static unsigned char  prev_survey_channel = 0;
 	static unsigned int p2p_scan_count = 0;
@@ -8353,8 +8279,8 @@ void site_survey(struct rtw_adapter *pad
 	}
 	else if (rtw_p2p_findphase_ex_is_social(pwdinfo))
 	{
-		//	Commented by Albert 2011/06/03
-		//	The driver is in the find phase, it should go through the social channel.
+		/* 	Commented by Albert 2011/06/03 */
+		/* 	The driver is in the find phase, it should go through the social channel. */
 		int ch_set_idx;
 		survey_channel = pwdinfo->social_chan[pmlmeext->sitesurvey_res.channel_idx];
 		ch_set_idx = rtw_ch_set_search_ch(pmlmeext->channel_set, survey_channel);
@@ -8364,7 +8290,7 @@ void site_survey(struct rtw_adapter *pad
 			ScanType = SCAN_ACTIVE;
 	}
 	else
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 	{
 		struct rtw_ieee80211_channel *ch;
 		if (pmlmeext->sitesurvey_res.channel_idx < pmlmeext->sitesurvey_res.ch_num) {
@@ -8375,7 +8301,7 @@ void site_survey(struct rtw_adapter *pad
 	}
 
 	if (survey_channel != 0) {
-		//PAUSE 4-AC Queue when site_survey
+		/* PAUSE 4-AC Queue when site_survey */
 #ifdef CONFIG_CONCURRENT_MODE
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 		if ((padapter->pbuddy_adapter->mlmeextpriv.mlmext_info.state&0x03) == WIFI_FW_AP_STATE)
@@ -8394,8 +8320,8 @@ void site_survey(struct rtw_adapter *pad
 				pmlmeinfo->scan_cnt++;
 			}
 		}
-#endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
+#endif /* CONFIG_CONCURRENT_MODE */
 		if (pmlmeext->sitesurvey_res.channel_idx == 0)
 		{
 			set_channel_bwmode(padapter, survey_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
@@ -8408,7 +8334,7 @@ void site_survey(struct rtw_adapter *pad
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 		if (stay_buddy_ch == 1)
 		{
-			val8 = 0; //survey done
+			val8 = 0; /* survey done */
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 
 			if (check_buddy_mlmeinfo_state(padapter, WIFI_FW_AP_STATE) &&
@@ -8419,12 +8345,12 @@ void site_survey(struct rtw_adapter *pad
 		}
 		else if (stay_buddy_ch == 2)
 		{
-			val8 = 1; //under site survey
+			val8 = 1; /* under site survey */
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 		}
-#endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
 
-		if (ScanType == SCAN_ACTIVE) //obey the channel plan setting...
+		if (ScanType == SCAN_ACTIVE) /* obey the channel plan setting... */
 		{
 			#ifdef CONFIG_P2P
 			if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_SCAN) ||
@@ -8436,14 +8362,14 @@ void site_survey(struct rtw_adapter *pad
 				issue_probereq_p2p(padapter, NULL);
 			}
 			else
-			#endif //CONFIG_P2P
+			#endif /* CONFIG_P2P */
 			{
 				int i;
 				for (i=0;i<RTW_SSID_SCAN_AMOUNT;i++) {
 					if (pmlmeext->sitesurvey_res.ssid[i].SsidLength) {
-						//todo: to issue two probe req???
+						/* todo: to issue two probe req??? */
 						issue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
-						//rtw_msleep_os(SURVEY_TO>>1);
+						/* rtw_msleep_os(SURVEY_TO>>1); */
 						issue_probereq(padapter, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
 					} else {
 						break;
@@ -8451,9 +8377,9 @@ void site_survey(struct rtw_adapter *pad
 				}
 
 				if (pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) {
-					//todo: to issue two probe req???
+					/* todo: to issue two probe req??? */
 					issue_probereq(padapter, NULL, NULL);
-					//rtw_msleep_os(SURVEY_TO>>1);
+					/* rtw_msleep_os(SURVEY_TO>>1); */
 					issue_probereq(padapter, NULL, NULL);
 				}
 			}
@@ -8463,13 +8389,13 @@ void site_survey(struct rtw_adapter *pad
 		if (stay_buddy_ch == 1)
 			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time * RTW_STAY_AP_CH_MILLISECOND);
 		else
-#endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
 			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
 
 	}
 	else
 	{
-		//	channel number is 0 or this channel is not valid.
+		/* 	channel number is 0 or this channel is not valid. */
 
 #ifdef CONFIG_CONCURRENT_MODE
 		u8 cur_channel;
@@ -8482,8 +8408,8 @@ void site_survey(struct rtw_adapter *pad
 			cur_bwmode = pmlmeext->cur_bwmode;
 			cur_ch_offset = pmlmeext->cur_ch_offset;
 		}
-		//else if ((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
-		else if (check_buddy_fwstate(padapter, _FW_LINKED)) // for AP or STA
+		/* else if ((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) */
+		else if (check_buddy_fwstate(padapter, _FW_LINKED)) /*  for AP or STA */
 		{
 			cur_channel = pbuddy_mlmeext->cur_channel;
 			cur_bwmode = pbuddy_mlmeext->cur_bwmode;
@@ -8503,8 +8429,8 @@ void site_survey(struct rtw_adapter *pad
 		{
 			if ((pwdinfo->rx_invitereq_info.scan_op_ch_only) || (pwdinfo->p2p_info.scan_op_ch_only))
 			{
-				//	Set the find_phase_state_exchange_cnt to P2P_FINDPHASE_EX_CNT.
-				//	This will let the following flow to run the scanning end.
+				/* 	Set the find_phase_state_exchange_cnt to P2P_FINDPHASE_EX_CNT. */
+				/* 	This will let the following flow to run the scanning end. */
 				rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_MAX);
 			}
 			#ifdef CONFIG_DBG_P2P
@@ -8514,30 +8440,30 @@ void site_survey(struct rtw_adapter *pad
 
 		if (rtw_p2p_findphase_ex_is_needed(pwdinfo))
 		{
-			//	Set the P2P State to the listen state of find phase and set the current channel to the listen channel
+			/* 	Set the P2P State to the listen state of find phase and set the current channel to the listen channel */
 			set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 			rtw_p2p_set_state(pwdinfo, P2P_STATE_FIND_PHASE_LISTEN);
 			pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
 
-			initialgain = 0xff; //restore RX GAIN
+			initialgain = 0xff; /* restore RX GAIN */
 			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
-			//turn on dynamic functions
+			/* turn on dynamic functions */
 			Restore_DM_Func_Flag(padapter);
-			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
+			/* Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true); */
 
 			_set_timer(&pwdinfo->find_phase_timer, (u32) ((u32) (pwdinfo->listen_dwell) * 100));
 		}
 		else
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 		{
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 			pmlmeinfo->scan_cnt = 0;
-#endif //CONFIG_DMP_STA_NODE_SCAN_UNDER_AP_MODE
+#endif /* CONFIG_DMP_STA_NODE_SCAN_UNDER_AP_MODE */
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
-			// 20100721:Interrupt scan operation here.
-			// For SW antenna diversity before link, it needs to switch to another antenna and scan again.
-			// It compares the scan result and select beter one to do connection.
+			/*  20100721:Interrupt scan operation here. */
+			/*  For SW antenna diversity before link, it needs to switch to another antenna and scan again. */
+			/*  It compares the scan result and select beter one to do connection. */
 			if (rtw_hal_antdiv_before_linked(padapter))
 			{
 				pmlmeext->sitesurvey_res.bss_cnt = 0;
@@ -8557,19 +8483,19 @@ void site_survey(struct rtw_adapter *pad
 				{
 					_set_timer(&pwdinfo->ap_p2p_switch_timer, 500);
 				}
-				#endif //CONFIG_IOCTL_CFG80211
+				#endif /* CONFIG_IOCTL_CFG80211 */
 				rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 			#else
 				rtw_p2p_set_state(pwdinfo, rtw_p2p_pre_state(pwdinfo));
 			#endif
 			}
 			rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 
 			pmlmeext->sitesurvey_res.state = SCAN_COMPLETE;
 
-			//switch back to the original channel
-			//SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
+			/* switch back to the original channel */
+			/* SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset); */
 
 			{
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -8581,30 +8507,30 @@ void site_survey(struct rtw_adapter *pad
 					set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 				}
 				else
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 #ifdef CONFIG_CONCURRENT_MODE
 					set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 #else
 					set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 #endif
-#endif //CONFIG_DUALMAC_CONCURRENT
+#endif /* CONFIG_DUALMAC_CONCURRENT */
 			}
 
-			//flush 4-AC Queue after site_survey
-			//val8 = 0;
-			//rtw_hal_set_hwreg(padapter, HW_VAR_TXPAUSE, (u8 *)(&val8));
+			/* flush 4-AC Queue after site_survey */
+			/* val8 = 0; */
+			/* rtw_hal_set_hwreg(padapter, HW_VAR_TXPAUSE, (u8 *)(&val8)); */
 
-			val8 = 0; //survey done
+			val8 = 0; /* survey done */
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 
-			//config MSR
+			/* config MSR */
 			Set_MSR(padapter, (pmlmeinfo->state & 0x3));
 
-			initialgain = 0xff; //restore RX GAIN
+			initialgain = 0xff; /* restore RX GAIN */
 			rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
-			//turn on dynamic functions
+			/* turn on dynamic functions */
 			Restore_DM_Func_Flag(padapter);
-			//Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
+			/* Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true); */
 
 			if (is_client_associated_to_ap(padapter) == true)
 			{
@@ -8654,7 +8580,7 @@ void site_survey(struct rtw_adapter *pad
 	return;
 }
 
-//collect bss info from Beacon and Probe response frames.
+/* collect bss info from Beacon and Probe response frames. */
 u8 collect_bss_info(struct rtw_adapter *padapter, union recv_frame *precv_frame, struct wlan_bssid_ex *bssid)
 {
 	int	i;
@@ -8671,7 +8597,7 @@ u8 collect_bss_info(struct rtw_adapter *
 
 	if (len > MAX_IE_SZ)
 	{
-		//DBG_8192D("IE too long for survey event\n");
+		/* DBG_8192D("IE too long for survey event\n"); */
 		return _FAIL;
 	}
 
@@ -8686,21 +8612,21 @@ u8 collect_bss_info(struct rtw_adapter *
 
 	bssid->Length = sizeof(struct wlan_bssid_ex) - MAX_IE_SZ + len;
 
-	//below is to copy the information element
+	/* below is to copy the information element */
 	bssid->IELength = len;
 	memcpy(bssid->IEs, (pframe + sizeof(struct rtw_ieee80211_hdr_3addr)), bssid->IELength);
 
-	//get the signal strength
-	bssid->PhyInfo.SignalQuality = precv_frame->u.hdr.attrib.signal_qual;//in percentage
-	bssid->PhyInfo.SignalStrength = precv_frame->u.hdr.attrib.signal_strength;//in percentage
-	bssid->Rssi = precv_frame->u.hdr.attrib.RecvSignalPower; // in dBM.raw data
+	/* get the signal strength */
+	bssid->PhyInfo.SignalQuality = precv_frame->u.hdr.attrib.signal_qual;/* in percentage */
+	bssid->PhyInfo.SignalStrength = precv_frame->u.hdr.attrib.signal_strength;/* in percentage */
+	bssid->Rssi = precv_frame->u.hdr.attrib.RecvSignalPower; /*  in dBM.raw data */
 
 #ifdef CONFIG_ANTENNA_DIVERSITY
-	//rtw_hal_get_hwreg(padapter, HW_VAR_CURRENT_ANTENNA, (u8 *)(&bssid->PhyInfo.Optimum_antenna));
+	/* rtw_hal_get_hwreg(padapter, HW_VAR_CURRENT_ANTENNA, (u8 *)(&bssid->PhyInfo.Optimum_antenna)); */
 	rtw_hal_get_def_var(padapter, HAL_DEF_CURRENT_ANTENNA,  &bssid->PhyInfo.Optimum_antenna);
 #endif
 
-	// checking SSID
+	/*  checking SSID */
 	if ((p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SSID_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_)) == NULL)
 	{
 		DBG_8192D("marc: cannot find SSID for survey event\n");
@@ -8724,7 +8650,7 @@ u8 collect_bss_info(struct rtw_adapter *
 
 	memset(bssid->SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
 
-	//checking rate info...
+	/* checking rate info... */
 	i = 0;
 	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SUPPORTEDRATES_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
 	if (p != NULL)
@@ -8749,13 +8675,13 @@ u8 collect_bss_info(struct rtw_adapter *
 		memcpy(bssid->SupportedRates + i, (p + 2), len);
 	}
 
-	//todo:
+	/* todo: */
 	bssid->NetworkTypeInUse = NDIS802_11OFDM24;
 
 	if (bssid->IELength < 12)
 		return _FAIL;
 
-	// Checking for DSConfig
+	/*  Checking for DSConfig */
 	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _DSSET_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
 
 	bssid->Configuration.DSConfig = 0;
@@ -8766,8 +8692,8 @@ u8 collect_bss_info(struct rtw_adapter *
 		bssid->Configuration.DSConfig = *(p + 2);
 	}
 	else
-	{// In 5G, some ap do not have DSSET IE
-		// checking HT info for channel
+	{/*  In 5G, some ap do not have DSSET IE */
+		/*  checking HT info for channel */
 		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
 		if (p)
 		{
@@ -8775,7 +8701,7 @@ u8 collect_bss_info(struct rtw_adapter *
 			bssid->Configuration.DSConfig = HT_info->primary_channel;
 		}
 		else
-		{ // use current channel
+		{ /*  use current channel */
 			bssid->Configuration.DSConfig = rtw_get_oper_ch(padapter);
 		}
 	}
@@ -8803,7 +8729,7 @@ u8 collect_bss_info(struct rtw_adapter *
 
 	bssid->Configuration.ATIMWindow = 0;
 
-	//20/40 BSS Coexistence check
+	/* 20/40 BSS Coexistence check */
 	if ((pregistrypriv->wifi_spec==1) && (false == pmlmeinfo->bwmode_updated))
 	{
 		struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
@@ -8827,12 +8753,12 @@ u8 collect_bss_info(struct rtw_adapter *
 	}
 
 #ifdef CONFIG_INTEL_WIDI
-	//process_intel_widi_query_or_tigger(padapter, bssid);
+	/* process_intel_widi_query_or_tigger(padapter, bssid); */
 	if (process_intel_widi_query_or_tigger(padapter, bssid))
 	{
 		return _FAIL;
 	}
-#endif // CONFIG_INTEL_WIDI
+#endif /*  CONFIG_INTEL_WIDI */
 
 	#if defined(DBG_RX_SIGNAL_DISPLAY_PROCESSING) & 1
 	if (strcmp(bssid->Ssid.Ssid, DBG_RX_SIGNAL_DISPLAY_SSID_MONITORED) == 0) {
@@ -8844,7 +8770,7 @@ u8 collect_bss_info(struct rtw_adapter *
 	}
 	#endif
 
-	// mark bss info receving from nearby channel as SignalQuality 101
+	/*  mark bss info receving from nearby channel as SignalQuality 101 */
 	if (bssid->Configuration.DSConfig != rtw_get_oper_ch(padapter))
 	{
 		bssid->PhyInfo.SignalQuality= 101;
@@ -8864,30 +8790,27 @@ void start_create_ibss(struct rtw_adapte
 	pmlmeext->cur_channel = (u8)pnetwork->Configuration.DSConfig;
 	pmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);
 
-	//update wireless mode
+	/* update wireless mode */
 	update_wireless_mode(padapter);
 
-	//udpate capability
+	/* udpate capability */
 	caps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);
 	update_capinfo(padapter, caps);
-	if (caps&cap_IBSS)//adhoc master
+	if (caps&cap_IBSS)/* adhoc master */
 	{
-		//set_opmode_cmd(padapter, adhoc);//removed
-
 		val8 = 0xcf;
 		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));
 
-		//switch channel
-		//SelectChannel(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+		/* switch channel */
 		set_channel_bwmode(padapter, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 
 		beacon_timing_control(padapter);
 
-		//set msr to WIFI_FW_ADHOC_STATE
+		/* set msr to WIFI_FW_ADHOC_STATE */
 		pmlmeinfo->state = WIFI_FW_ADHOC_STATE;
 		Set_MSR(padapter, (pmlmeinfo->state & 0x3));
 
-		//issue beacon
+		/* issue beacon */
 		if (send_beacon(padapter)==_FAIL)
 		{
 			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("issuing beacon frame fail....\n"));
@@ -8926,10 +8849,10 @@ void start_clnt_join(struct rtw_adapter*
 	pmlmeext->cur_channel = (u8)pnetwork->Configuration.DSConfig;
 	pmlmeinfo->bcn_interval = get_beacon_interval(pnetwork);
 
-	//update wireless mode
+	/* update wireless mode */
 	update_wireless_mode(padapter);
 
-	//udpate capability
+	/* udpate capability */
 	caps = rtw_get_capability((struct wlan_bssid_ex *)pnetwork);
 	update_capinfo(padapter, caps);
 	if (caps&cap_ESS)
@@ -8952,16 +8875,16 @@ void start_clnt_join(struct rtw_adapter*
 		val8 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_8021X)? 0xcc: 0xcf;
 		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));
 
-		//switch channel
+		/* switch channel */
 		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 
-		//here wait for receiving the beacon to start auth
-		//and enable a timer
+		/* here wait for receiving the beacon to start auth */
+		/* and enable a timer */
 		set_link_timer(pmlmeext, decide_wait_for_beacon_timeout(pmlmeinfo->bcn_interval));
 
 		pmlmeinfo->state = WIFI_FW_AUTH_NULL | WIFI_FW_STATION_STATE;
 	}
-	else if (caps&cap_IBSS) //adhoc client
+	else if (caps&cap_IBSS) /* adhoc client */
 	{
 #ifdef CONFIG_DUALMAC_CONCURRENT
 		dc_join_status = dc_handle_join_request(padapter);
@@ -8977,7 +8900,7 @@ void start_clnt_join(struct rtw_adapter*
 		val8 = 0xcf;
 		rtw_hal_set_hwreg(padapter, HW_VAR_SEC_CFG, (u8 *)(&val8));
 
-		//switch channel
+		/* switch channel */
 		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 
 		beacon_timing_control(padapter);
@@ -8988,7 +8911,7 @@ void start_clnt_join(struct rtw_adapter*
 	}
 	else
 	{
-		//DBG_8192D("marc: invalid cap:%x\n", caps);
+		/* DBG_8192D("marc: invalid cap:%x\n", caps); */
 		return;
 	}
 }
@@ -9010,11 +8933,11 @@ void start_clnt_auth(struct rtw_adapter*
 	pmlmeext->retry = 0;
 
 
-	// Because of AP's not receiving deauth before
-	// AP may: 1)not response auth or 2)deauth us after link is complete
-	// issue deauth before issuing auth to deal with the situation
-	//	Commented by Albert 2012/07/21
-	//	For the Win8 P2P connection, it will be hard to have a successful connection if this Wi-Fi doesn't connect to it.
+	/*  Because of AP's not receiving deauth before */
+	/*  AP may: 1)not response auth or 2)deauth us after link is complete */
+	/*  issue deauth before issuing auth to deal with the situation */
+	/* 	Commented by Albert 2012/07/21 */
+	/* 	For the Win8 P2P connection, it will be hard to have a successful connection if this Wi-Fi doesn't connect to it. */
 	issue_deauth(padapter, (&(pmlmeinfo->network))->MacAddress, WLAN_REASON_DEAUTH_LEAVING);
 
 	issue_auth(padapter, NULL, 0);
@@ -9043,7 +8966,7 @@ unsigned int receive_disconnect(struct r
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	//check A3
+	/* check A3 */
 	if (!(_rtw_memcmp(MacAddr, get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
 		return _SUCCESS;
 
@@ -9080,7 +9003,7 @@ static void process_80211d(struct rtw_ad
 	pregistrypriv = &padapter->registrypriv;
 	pmlmeext = &padapter->mlmeextpriv;
 
-	// Adjust channel plan by AP Country IE
+	/*  Adjust channel plan by AP Country IE */
 	if (pregistrypriv->enable80211d &&
 		(!pmlmeext->update_channel_plan_by_ap_done))
 	{
@@ -9089,8 +9012,8 @@ static void process_80211d(struct rtw_ad
 		struct rt_channel_plan chplan_ap;
 		struct rt_channel_info chplan_sta[MAX_CHANNEL_NUM];
 		u8 country[4];
-		u8 fcn; // first channel number
-		u8 noc; // number of channel
+		u8 fcn; /*  first channel number */
+		u8 noc; /*  number of channel */
 		u8 j, k;
 
 		ie = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _COUNTRY_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
@@ -9116,8 +9039,8 @@ static void process_80211d(struct rtw_ad
 
 			for (j = 0; j < noc; j++)
 			{
-				if (fcn <= 14) channel = fcn + j; // 2.4 GHz
-				else channel = fcn + j*4; // 5 GHz
+				if (fcn <= 14) channel = fcn + j; /*  2.4 GHz */
+				else channel = fcn + j*4; /*  5 GHz */
 
 				chplan_ap.Channel[i++] = channel;
 			}
@@ -9173,7 +9096,7 @@ static void process_80211d(struct rtw_ad
 				else if (chplan_sta[i].ChannelNum < chplan_ap.Channel[j])
 				{
 					chplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;
-//					chplan_new[k].ScanType = chplan_sta[i].ScanType;
+/* 					chplan_new[k].ScanType = chplan_sta[i].ScanType; */
 					chplan_new[k].ScanType = SCAN_PASSIVE;
 					i++;
 					k++;
@@ -9187,19 +9110,19 @@ static void process_80211d(struct rtw_ad
 				}
 			} while (1);
 
-			// change AP not support channel to Passive scan
+			/*  change AP not support channel to Passive scan */
 			while ((i < MAX_CHANNEL_NUM) &&
 				(chplan_sta[i].ChannelNum != 0) &&
 				(chplan_sta[i].ChannelNum <= 14))
 			{
 				chplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;
-//				chplan_new[k].ScanType = chplan_sta[i].ScanType;
+/* 				chplan_new[k].ScanType = chplan_sta[i].ScanType; */
 				chplan_new[k].ScanType = SCAN_PASSIVE;
 				i++;
 				k++;
 			}
 
-			// add channel AP supported
+			/*  add channel AP supported */
 			while ((j < chplan_ap.Len) && (chplan_ap.Channel[j] <= 14))
 			{
 				chplan_new[k].ChannelNum = chplan_ap.Channel[j];
@@ -9210,7 +9133,7 @@ static void process_80211d(struct rtw_ad
 		}
 		else
 		{
-			// keep original STA 2.4G channel plan
+			/*  keep original STA 2.4G channel plan */
 			while ((i < MAX_CHANNEL_NUM) &&
 				(chplan_sta[i].ChannelNum != 0) &&
 				(chplan_sta[i].ChannelNum <= 14))
@@ -9221,7 +9144,7 @@ static void process_80211d(struct rtw_ad
 				k++;
 			}
 
-			// skip AP 2.4G channel plan
+			/*  skip AP 2.4G channel plan */
 			while ((j < chplan_ap.Len) && (chplan_ap.Channel[j] <= 14))
 			{
 				j++;
@@ -9249,7 +9172,7 @@ static void process_80211d(struct rtw_ad
 				else if (chplan_sta[i].ChannelNum < chplan_ap.Channel[j])
 				{
 					chplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;
-//					chplan_new[k].ScanType = chplan_sta[i].ScanType;
+/* 					chplan_new[k].ScanType = chplan_sta[i].ScanType; */
 					chplan_new[k].ScanType = SCAN_PASSIVE;
 					i++;
 					k++;
@@ -9263,17 +9186,17 @@ static void process_80211d(struct rtw_ad
 				}
 			} while (1);
 
-			// change AP not support channel to Passive scan
+			/*  change AP not support channel to Passive scan */
 			while ((i < MAX_CHANNEL_NUM) && (chplan_sta[i].ChannelNum != 0))
 			{
 				chplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;
-//				chplan_new[k].ScanType = chplan_sta[i].ScanType;
+/* 				chplan_new[k].ScanType = chplan_sta[i].ScanType; */
 				chplan_new[k].ScanType = SCAN_PASSIVE;
 				i++;
 				k++;
 			}
 
-			// add channel AP supported
+			/*  add channel AP supported */
 			while ((j < chplan_ap.Len) && (chplan_ap.Channel[j] != 0))
 			{
 				chplan_new[k].ChannelNum = chplan_ap.Channel[j];
@@ -9284,7 +9207,7 @@ static void process_80211d(struct rtw_ad
 		}
 		else
 		{
-			// keep original STA 5G channel plan
+			/*  keep original STA 5G channel plan */
 			while ((i < MAX_CHANNEL_NUM) && (chplan_sta[i].ChannelNum != 0))
 			{
 				chplan_new[k].ChannelNum = chplan_sta[i].ChannelNum;
@@ -9309,7 +9232,7 @@ static void process_80211d(struct rtw_ad
 
 	}
 
-	// If channel is used by AP, set channel scan type to active
+	/*  If channel is used by AP, set channel scan type to active */
 	channel = bssid->Configuration.DSConfig;
 	chplan_new = pmlmeext->channel_set;
 	i = 0;
@@ -9319,7 +9242,7 @@ static void process_80211d(struct rtw_ad
 		{
 			if (chplan_new[i].ScanType == SCAN_PASSIVE)
 			{
-				//5G Bnad 2, 3 (DFS) doesn't change to active scan
+				/* 5G Bnad 2, 3 (DFS) doesn't change to active scan */
 				if (channel >= 52 && channel <= 144)
 					break;
 
@@ -9350,8 +9273,8 @@ void report_survey_event(struct rtw_adap
 	struct C2HEvent_Header *pc2h_evt_hdr;
 	struct mlme_ext_priv *pmlmeext;
 	struct cmd_priv *pcmdpriv;
-	//u8 *pframe = precv_frame->u.hdr.rx_data;
-	//uint len = precv_frame->u.hdr.len;
+	/* u8 *pframe = precv_frame->u.hdr.rx_data; */
+	/* uint len = precv_frame->u.hdr.len; */
 
 	if (!padapter)
 		return;
@@ -9612,18 +9535,18 @@ Following are the event callback functio
 
 *****************************************************************************/
 
-//for sta/adhoc mode
+/* for sta/adhoc mode */
 void update_sta_info(struct rtw_adapter *padapter, struct sta_info *psta)
 {
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
-	//ERP
+	/* ERP */
 	VCS_update(padapter, psta);
 
 
-	//HT
+	/* HT */
 	if (pmlmepriv->htpriv.ht_option)
 	{
 		psta->htpriv.ht_option = true;
@@ -9651,11 +9574,11 @@ void update_sta_info(struct rtw_adapter
 	psta->htpriv.bwmode = pmlmeext->cur_bwmode;
 	psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
 
-	psta->htpriv.agg_enable_bitmap = 0x0;//reset
-	psta->htpriv.candidate_tid_bitmap = 0x0;//reset
+	psta->htpriv.agg_enable_bitmap = 0x0;/* reset */
+	psta->htpriv.candidate_tid_bitmap = 0x0;/* reset */
 
 
-	//QoS
+	/* QoS */
 	if (pmlmepriv->qospriv.qos_option)
 		psta->qos_option = true;
 
@@ -9677,13 +9600,13 @@ void mlmeext_joinbss_event_callback(stru
 		rtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));
 		rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);
 
-		//restore to initial setting.
+		/* restore to initial setting. */
 		update_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);
 		goto exit_mlmeext_joinbss_event_callback;
 	}
 
 	if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {
-		//for bc/mc
+		/* for bc/mc */
 		psta_bmc = rtw_get_bcmc_stainfo(padapter);
 		if (psta_bmc)
 		{
@@ -9694,40 +9617,40 @@ void mlmeext_joinbss_event_callback(stru
 	}
 
 
-	//turn on dynamic functions
+	/* turn on dynamic functions */
 	Switch_DM_Func(padapter, DYNAMIC_FUNC_DIG|DYNAMIC_FUNC_HP|DYNAMIC_FUNC_SS, true);
 
-	// update IOT-releated issue
+	/*  update IOT-releated issue */
 	update_IOT_info(padapter);
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_BASIC_RATE, cur_network->SupportedRates);
 
-	//BCN interval
+	/* BCN interval */
 	rtw_hal_set_hwreg(padapter, HW_VAR_BEACON_INTERVAL, (u8 *)(&pmlmeinfo->bcn_interval));
 
-	//udpate capability
+	/* udpate capability */
 	update_capinfo(padapter, pmlmeinfo->capability);
 
-	//WMM, Update EDCA param
+	/* WMM, Update EDCA param */
 	WMMOnAssocRsp(padapter);
 
-	//HT
+	/* HT */
 	HTOnAssocRsp(padapter);
 
 #ifndef CONFIG_CONCURRENT_MODE
-	//	Call set_channel_bwmode when the CONFIG_CONCURRENT_MODE doesn't be defined.
-	//Set cur_channel&cur_bwmode&cur_ch_offset
+	/* 	Call set_channel_bwmode when the CONFIG_CONCURRENT_MODE doesn't be defined. */
+	/* Set cur_channel&cur_bwmode&cur_ch_offset */
 	set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 #endif
 
 	psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
-	if (psta) //only for infra. mode
+	if (psta) /* only for infra. mode */
 	{
 		pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
 
-		//DBG_8192D("set_sta_rate\n");
+		/* DBG_8192D("set_sta_rate\n"); */
 
-		//set per sta rate after updating HT cap.
+		/* set per sta rate after updating HT cap. */
 		set_sta_rate(padapter, psta);
 	}
 
@@ -9736,10 +9659,10 @@ void mlmeext_joinbss_event_callback(stru
 
 	if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
 	{
-		// correcting TSF
+		/*  correcting TSF */
 		correct_TSF(padapter, pmlmeext);
 
-		//set_link_timer(pmlmeext, DISCONNECT_TO);
+		/* set_link_timer(pmlmeext, DISCONNECT_TO); */
 	}
 
 #ifdef CONFIG_LPS
@@ -9768,19 +9691,19 @@ void mlmeext_sta_add_event_callback(stru
 
 	if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
 	{
-		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)//adhoc master or sta_count>1
+		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)/* adhoc master or sta_count>1 */
 		{
-			//nothing to do
+			/* nothing to do */
 		}
-		else//adhoc client
+		else/* adhoc client */
 		{
-			//update TSF Value
-			//update_TSF(pmlmeext, pframe, len);
+			/* update TSF Value */
+			/* update_TSF(pmlmeext, pframe, len); */
 
-			// correcting TSF
+			/*  correcting TSF */
 			correct_TSF(padapter, pmlmeext);
 
-			//start beacon
+			/* start beacon */
 			if (send_beacon(padapter)==_FAIL)
 			{
 				pmlmeinfo->FW_sta_info[psta->mac_id].status = 0;
@@ -9800,10 +9723,10 @@ void mlmeext_sta_add_event_callback(stru
 
 	pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
 
-	//rate radaptive
+	/* rate radaptive */
 	Update_RA_Entry(padapter, psta->mac_id);
 
-	//update adhoc sta_info
+	/* update adhoc sta_info */
 	update_sta_info(padapter, psta);
 }
 
@@ -9814,12 +9737,12 @@ void mlmeext_sta_del_event_callback(stru
 
 	if (is_client_associated_to_ap(padapter) || is_IBSS_empty(padapter))
 	{
-		//set_opmode_cmd(padapter, infra_client_with_mlme);
+		/* set_opmode_cmd(padapter, infra_client_with_mlme); */
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, 0);
 		rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);
 
-		//restore to initial setting.
+		/* restore to initial setting. */
 		update_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
@@ -9828,25 +9751,25 @@ void mlmeext_sta_del_event_callback(stru
 #ifdef CONFIG_CONCURRENT_MODE
 		if ((check_buddy_fwstate(padapter, _FW_LINKED)) != true)
 		{
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
-		//switch to the 20M Hz mode after disconnect
+		/* switch to the 20M Hz mode after disconnect */
 		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
 		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 
-		//SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
+		/* SelectChannel(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset); */
 		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 
 #ifdef CONFIG_CONCURRENT_MODE
 		}
-#endif //CONFIG_CONCURRENT_MODE
-#endif //CONFIG_DUALMAC_CONCURRENT
+#endif /* CONFIG_CONCURRENT_MODE */
+#endif /* CONFIG_DUALMAC_CONCURRENT */
 
 		flush_all_cam_entry(padapter);
 
 		pmlmeinfo->state = WIFI_FW_NULL_STATE;
 
-		//set MSR to no link state -> infra. mode
+		/* set MSR to no link state -> infra. mode */
 		Set_MSR(padapter, _HW_STATE_STATION_);
 
 		_cancel_timer_ex(&pmlmeext->link_timer);
@@ -9879,9 +9802,9 @@ void _linked_rx_signal_strehgth_display(
 	DBG_8192D("Rx Signal_qual:%d\n",pbuddy_adapter->recvpriv.signal_qual);
 	DBG_8192D("============ linked status check ===================\n");
 	DBG_8192D("adapter_type=%d\n", padapter->adapter_type);
-#else //CONFIG_CONCURRENT_MODE
+#else /* CONFIG_CONCURRENT_MODE */
 	DBG_8192D("============ linked status check ===================\n");
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 	DBG_8192D("pathA Rx SNRdb:%d, pathB Rx SNRdb:%d\n",padapter->recvpriv.RxSNRdB[0], padapter->recvpriv.RxSNRdB[1]);
 	DBG_8192D("pathA Rx PWDB:%d\n",padapter->recvpriv.rxpwdb);
 	DBG_8192D("pathA Rx RSSI:%d,pathB Rx RSSI:%d\n",padapter->recvpriv.RxRssi[0],padapter->recvpriv.RxRssi[1]);
@@ -9912,16 +9835,11 @@ u8 chk_ap_is_alive(struct rtw_adapter *p
 
 	#ifdef DBG_EXPIRATION_CHK
 	DBG_8192D(FUNC_ADPT_FMT" rx:"STA_PKTS_FMT", beacon:%llu, probersp_to_self:%llu"
-				/*", probersp_bm:%llu, probersp_uo:%llu, probereq:%llu, BI:%u"*/
 				", retry:%u\n"
 		, FUNC_ADPT_ARG(padapter)
 		, STA_RX_PKTS_DIFF_ARG(psta)
 		, psta->sta_stats.rx_beacon_pkts - psta->sta_stats.last_rx_beacon_pkts
 		, psta->sta_stats.rx_probersp_pkts - psta->sta_stats.last_rx_probersp_pkts
-		/*, psta->sta_stats.rx_probersp_bm_pkts - psta->sta_stats.last_rx_probersp_bm_pkts
-		, psta->sta_stats.rx_probersp_uo_pkts - psta->sta_stats.last_rx_probersp_uo_pkts
-		, psta->sta_stats.rx_probereq_pkts - psta->sta_stats.last_rx_probereq_pkts
-		, pmlmeinfo->bcn_interval*/
 		, pmlmeext->retry
 	);
 
@@ -9966,7 +9884,7 @@ void linked_status_chk(struct rtw_adapte
 
 	if (is_client_associated_to_ap(padapter))
 	{
-		//linked infrastructure client mode
+		/* linked infrastructure client mode */
 
 		int tx_chk = _SUCCESS, rx_chk = _SUCCESS;
 		int rx_chk_limit;
@@ -10064,12 +9982,12 @@ void linked_status_chk(struct rtw_adapte
 				pmlmeinfo->link_count = 0;
 			}
 
-		} //end of if ((psta = rtw_get_stainfo(pstapriv, passoc_res->network.MacAddress)) != NULL)
+		} /* end of if ((psta = rtw_get_stainfo(pstapriv, passoc_res->network.MacAddress)) != NULL) */
 	}
 	else if (is_client_associated_to_ibss(padapter))
 	{
-		//linked IBSS mode
-		//for each assoc list entry to check the rx pkt counter
+		/* linked IBSS mode */
+		/* for each assoc list entry to check the rx pkt counter */
 		for (i = IBSS_START_MAC_ID; i < NUM_STA; i++)
 		{
 			if (pmlmeinfo->FW_sta_info[i].status == 1)
@@ -10089,7 +10007,7 @@ void linked_status_chk(struct rtw_adapte
 						pmlmeinfo->FW_sta_info[i].retry = 0;
 						pmlmeinfo->FW_sta_info[i].status = 0;
 						report_del_sta_event(padapter, psta->hwaddr
-							, 65535// indicate disconnect caused by no rx
+							, 65535/*  indicate disconnect caused by no rx */
 						);
 					}
 				}
@@ -10101,7 +10019,7 @@ void linked_status_chk(struct rtw_adapte
 			}
 		}
 
-		//set_link_timer(pmlmeext, DISCONNECT_TO);
+		/* set_link_timer(pmlmeext, DISCONNECT_TO); */
 
 	}
 }
@@ -10116,14 +10034,14 @@ void survey_timer_hdl(struct rtw_adapter
 	struct wifidirect_info *pwdinfo= &(padapter->wdinfo);
 #endif
 
-	//issue rtw_sitesurvey_cmd
+	/* issue rtw_sitesurvey_cmd */
 	if (pmlmeext->sitesurvey_res.state > SCAN_START)
 	{
 		if (pmlmeext->sitesurvey_res.state ==  SCAN_PROCESS)
 		{
 #ifdef CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
 			if (padapter->mlmeextpriv.mlmext_info.scan_cnt != RTW_SCAN_NUM_OF_CH)
-#endif //CONFIG_STA_MODE_SCAN_UNDER_AP_MODE
+#endif /* CONFIG_STA_MODE_SCAN_UNDER_AP_MODE */
 				pmlmeext->sitesurvey_res.channel_idx++;
 		}
 
@@ -10148,7 +10066,7 @@ void survey_timer_hdl(struct rtw_adapter
 				);
 			}
 
-			pmlmeext->scan_abort = false;//reset
+			pmlmeext->scan_abort = false;/* reset */
 		}
 
 		if ((ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
@@ -10184,7 +10102,7 @@ void link_timer_hdl(struct rtw_adapter *
 	}
 	else if (pmlmeinfo->state & WIFI_FW_AUTH_STATE)
 	{
-		//re-auth timer
+		/* re-auth timer */
 		if (++pmlmeinfo->reauth_count > REAUTH_LIMIT) {
 			pmlmeinfo->state = 0;
 			report_join_res(padapter, -1);
@@ -10196,7 +10114,7 @@ void link_timer_hdl(struct rtw_adapter *
 		issue_auth(padapter, NULL, 0);
 		set_link_timer(pmlmeext, REAUTH_TO);
 	} else if (pmlmeinfo->state & WIFI_FW_ASSOC_STATE) {
-		//re-assoc timer
+		/* re-assoc timer */
 		if (++pmlmeinfo->reassoc_count > REASSOC_LIMIT) {
 			pmlmeinfo->state = WIFI_FW_NULL_STATE;
 			report_join_res(padapter, -2);
@@ -10244,13 +10162,13 @@ u8 setopmode_hdl(struct rtw_adapter *pad
 		pmlmeinfo->state = WIFI_FW_AP_STATE;
 		type = _HW_STATE_AP_;
 #ifdef CONFIG_NATIVEAP_MLME
-		//start_ap_mode(padapter);
+		/* start_ap_mode(padapter); */
 #endif
 	}
 	else if (psetop->mode == NDIS802_11INFRA)
 	{
-		pmlmeinfo->state &= ~(BIT(0)|BIT(1));// clear state
-		pmlmeinfo->state |= WIFI_FW_STATION_STATE;//set to	STATION_STATE
+		pmlmeinfo->state &= ~(BIT(0)|BIT(1));/*  clear state */
+		pmlmeinfo->state |= WIFI_FW_STATION_STATE;/* set to	STATION_STATE */
 		type = _HW_STATE_STATION_;
 	}
 	else if (psetop->mode == NDIS802_11IBSS)
@@ -10263,7 +10181,7 @@ u8 setopmode_hdl(struct rtw_adapter *pad
 	}
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_SET_OPMODE, (u8 *)(&type));
-	//Set_NETYPE0_MSR(padapter, type);
+	/* Set_NETYPE0_MSR(padapter, type); */
 
 	return H2C_SUCCESS;
 }
@@ -10283,13 +10201,13 @@ u8 createbss_hdl(struct rtw_adapter *pad
 
 		if (pmlmeinfo->state == WIFI_FW_AP_STATE)
 		{
-			//todo:
+			/* todo: */
 			return H2C_SUCCESS;
 		}
 #endif
 	}
 
-	//below is for ad-hoc master
+	/* below is for ad-hoc master */
 	if (pparm->network.InfrastructureMode == NDIS802_11IBSS)
 	{
 		rtw_joinbss_reset(padapter);
@@ -10304,24 +10222,24 @@ u8 createbss_hdl(struct rtw_adapter *pad
 		pmlmeinfo->agg_enable_bitmap = 0;
 		pmlmeinfo->candidate_tid_bitmap = 0;
 
-		//disable dynamic functions, such as high power, DIG
+		/* disable dynamic functions, such as high power, DIG */
 		Save_DM_Func_Flag(padapter);
 		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);
 
-		//config the initial gain under linking, need to write the BB registers
+		/* config the initial gain under linking, need to write the BB registers */
 		initialgain = 0x1E;
 		rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 
-		//cancel link timer
+		/* cancel link timer */
 		_cancel_timer_ex(&pmlmeext->link_timer);
 
-		//clear CAM
+		/* clear CAM */
 		flush_all_cam_entry(padapter);
 
 		memcpy(pnetwork, pbuf, FIELD_OFFSET(struct wlan_bssid_ex, IELength));
 		pnetwork->IELength = ((struct wlan_bssid_ex *)pbuf)->IELength;
 
-		if (pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
+		if (pnetwork->IELength>MAX_IE_SZ)/* Check pbuf->IELength */
 			return H2C_PARAMETERS_ERROR;
 
 		memcpy(pnetwork->IEs, ((struct wlan_bssid_ex *)pbuf)->IEs, pnetwork->IELength);
@@ -10343,12 +10261,12 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 	struct wlan_bssid_ex	*pnetwork = (struct wlan_bssid_ex *)(&(pmlmeinfo->network));
 #ifdef CONFIG_ANTENNA_DIVERSITY
 	struct joinbss_parm	*pparm = (struct joinbss_parm *)pbuf;
-#endif //CONFIG_ANTENNA_DIVERSITY
+#endif /* CONFIG_ANTENNA_DIVERSITY */
 	u32	initialgain, i;
 	u8 cbw40_enable=0;
-	//u32	acparm;
+	/* u32	acparm; */
 
-	//check already connecting to AP or not
+	/* check already connecting to AP or not */
 	if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
 	{
 		if (pmlmeinfo->state & WIFI_FW_STATION_STATE)
@@ -10358,13 +10276,13 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 
 		pmlmeinfo->state = WIFI_FW_NULL_STATE;
 
-		//clear CAM
+		/* clear CAM */
 		flush_all_cam_entry(padapter);
 
 		_cancel_timer_ex(&pmlmeext->link_timer);
 
-		//set MSR to nolink -> infra. mode
-		//Set_MSR(padapter, _HW_STATE_NOLINK_);
+		/* set MSR to nolink -> infra. mode */
+		/* Set_MSR(padapter, _HW_STATE_NOLINK_); */
 		Set_MSR(padapter, _HW_STATE_STATION_);
 
 
@@ -10387,18 +10305,18 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 	pmlmeinfo->agg_enable_bitmap = 0;
 	pmlmeinfo->candidate_tid_bitmap = 0;
 	pmlmeinfo->bwmode_updated = false;
-	//pmlmeinfo->assoc_AP_vendor = maxAP;
+	/* pmlmeinfo->assoc_AP_vendor = maxAP; */
 
 	memcpy(pnetwork, pbuf, FIELD_OFFSET(struct wlan_bssid_ex, IELength));
 	pnetwork->IELength = ((struct wlan_bssid_ex *)pbuf)->IELength;
 
-	if (pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
+	if (pnetwork->IELength>MAX_IE_SZ)/* Check pbuf->IELength */
 		return H2C_PARAMETERS_ERROR;
 
 	memcpy(pnetwork->IEs, ((struct wlan_bssid_ex *)pbuf)->IEs, pnetwork->IELength);
 
-	//Check AP vendor to move rtw_joinbss_cmd()
-	//pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->IEs, pnetwork->IELength);
+	/* Check AP vendor to move rtw_joinbss_cmd() */
+	/* pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->IEs, pnetwork->IELength); */
 
 	for (i = sizeof(struct ndis_802_11_fixed_ies); i < pnetwork->IELength;)
 	{
@@ -10406,24 +10324,24 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 
 		switch (pIE->ElementID)
 		{
-			case _VENDOR_SPECIFIC_IE_://Get WMM IE.
+			case _VENDOR_SPECIFIC_IE_:/* Get WMM IE. */
 				if (_rtw_memcmp(pIE->data, WMM_OUI, 4))
 				{
 					pmlmeinfo->WMM_enable = 1;
 				}
 				break;
 
-			case _HT_CAPABILITY_IE_:	//Get HT Cap IE.
+			case _HT_CAPABILITY_IE_:	/* Get HT Cap IE. */
 				pmlmeinfo->HT_caps_enable = 1;
 				break;
 
-			case _HT_EXTRA_INFO_IE_:	//Get HT Info IE.
+			case _HT_EXTRA_INFO_IE_:	/* Get HT Info IE. */
 				pmlmeinfo->HT_info_enable = 1;
 
-				//spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz
-//#if !defined(CONFIG_CONCURRENT_MODE) && !defined(CONFIG_DUALMAC_CONCURRENT)
-//				if (pmlmeinfo->assoc_AP_vendor == ciscoAP)
-//#endif
+				/* spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz */
+/* if !defined(CONFIG_CONCURRENT_MODE) && !defined(CONFIG_DUALMAC_CONCURRENT) */
+/* 				if (pmlmeinfo->assoc_AP_vendor == ciscoAP) */
+/* endif */
 				{
 					struct HT_info_element *pht_info = (struct HT_info_element *)(pIE->data);
 
@@ -10438,7 +10356,7 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 
 					if ((cbw40_enable) &&	 (pht_info->infos[0] & BIT(2)))
 					{
-						//switch to the 40M Hz mode according to the AP
+						/* switch to the 40M Hz mode according to the AP */
 						pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;
 						switch (pht_info->infos[0] & 0x3)
 						{
@@ -10466,9 +10384,9 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 
 		i += (pIE->Length + 2);
 	}
-	//disable dynamic functions, such as high power, DIG
+	/* disable dynamic functions, such as high power, DIG */
 
-	//config the initial gain under linking, need to write the BB registers
+	/* config the initial gain under linking, need to write the BB registers */
 
 	initialgain = 0x1E;
 	rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
@@ -10478,7 +10396,7 @@ u8 join_cmd_hdl(struct rtw_adapter *pada
 	join_type = 0;
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_JOIN, (u8 *)(&join_type));
 
-	//cancel link timer
+	/* cancel link timer */
 	_cancel_timer_ex(&pmlmeext->link_timer);
 
 	start_clnt_join(padapter);
@@ -10499,26 +10417,26 @@ u8 disconnect_hdl(struct rtw_adapter *pa
 		issue_deauth_ex(padapter, pnetwork->MacAddress, WLAN_REASON_DEAUTH_LEAVING, param->deauth_timeout_ms/100, 100);
 	}
 
-	//set_opmode_cmd(padapter, infra_client_with_mlme);
+	/* set_opmode_cmd(padapter, infra_client_with_mlme); */
 
-	//pmlmeinfo->state = WIFI_FW_NULL_STATE;
+	/* pmlmeinfo->state = WIFI_FW_NULL_STATE; */
 
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_MLME_DISCONNECT, 0);
 	rtw_hal_set_hwreg(padapter, HW_VAR_BSSID, null_addr);
 
-	//restore to initial setting.
+	/* restore to initial setting. */
 	update_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);
 
 	if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
-		//Stop BCN
+		/* Stop BCN */
 		val8 = 0;
 		rtw_hal_set_hwreg(padapter, HW_VAR_BCN_FUNC, (u8 *)(&val8));
 	}
 
 
-	//set MSR to no link state -> infra. mode
+	/* set MSR to no link state -> infra. mode */
 	Set_MSR(padapter, _HW_STATE_STATION_);
 
 	pmlmeinfo->state = WIFI_FW_NULL_STATE;
@@ -10529,16 +10447,16 @@ u8 disconnect_hdl(struct rtw_adapter *pa
 #ifdef CONFIG_CONCURRENT_MODE
 	if ((check_buddy_fwstate(padapter, _FW_LINKED)) != true)
 	{
-#endif //CONFIG_CONCURRENT_MODE
-		//switch to the 20M Hz mode after disconnect
+#endif /* CONFIG_CONCURRENT_MODE */
+		/* switch to the 20M Hz mode after disconnect */
 		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
 		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 
 		set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
 #ifdef CONFIG_CONCURRENT_MODE
 	}
-#endif //CONFIG_CONCURRENT_MODE
-#endif //CONFIG_DUALMAC_CONCURRENT
+#endif /* CONFIG_CONCURRENT_MODE */
+#endif /* CONFIG_DUALMAC_CONCURRENT */
 
 	flush_all_cam_entry(padapter);
 
@@ -10590,7 +10508,7 @@ int rtw_scan_ch_decision(struct rtw_adap
 		}
 	}
 
-	if (padapter->setband == GHZ_24) {				// 2.4G
+	if (padapter->setband == GHZ_24) {				/*  2.4G */
 		for (i=0; i < j ; i++) {
 			if (out[i].hw_value > 35)
 				memset(&out[i], 0 , sizeof(struct rtw_ieee80211_channel));
@@ -10598,7 +10516,7 @@ int rtw_scan_ch_decision(struct rtw_adap
 				scan_ch_num++;
 		}
 		j = scan_ch_num;
-	} else if  (padapter->setband == GHZ_50) {			// 5G
+	} else if  (padapter->setband == GHZ_50) {			/*  5G */
 		for (i=0; i < j ; i++) {
 			if (out[i].hw_value > 35) {
 				memcpy(&out[scan_ch_num++], &out[i], sizeof(struct rtw_ieee80211_channel));
@@ -10626,7 +10544,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 
 	if (pmlmeext->sitesurvey_res.state == SCAN_DISABLE)
 	{
-		//for first time sitesurvey_cmd
+		/* for first time sitesurvey_cmd */
 		rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);
 
 		pmlmeext->sitesurvey_res.state = SCAN_START;
@@ -10653,7 +10571,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 		bdelayscan = dc_handle_site_survey(padapter);
 #endif
 
-		//issue null data if associating to the AP
+		/* issue null data if associating to the AP */
 		if (is_client_associated_to_ap(padapter) == true)
 		{
 			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
@@ -10678,7 +10596,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 			{
 				issue_tunneled_probe_req(padapter->pbuddy_adapter);
 			}
-			#endif //CONFIG_TDLS
+			#endif /* CONFIG_TDLS */
 
 			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
 
@@ -10689,7 +10607,7 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 #endif
 		if (bdelayscan)
 		{
-			//delay 50ms to protect nulldata(1).
+			/* delay 50ms to protect nulldata(1). */
 			set_survey_timer(pmlmeext, 50);
 			return H2C_SUCCESS;
 		}
@@ -10700,33 +10618,33 @@ u8 sitesurvey_cmd_hdl(struct rtw_adapter
 #ifdef CONFIG_FIND_BEST_CHANNEL
 #endif /* CONFIG_FIND_BEST_CHANNEL */
 
-		//disable dynamic functions, such as high power, DIG
+		/* disable dynamic functions, such as high power, DIG */
 		Save_DM_Func_Flag(padapter);
 		Switch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);
 
-		//config the initial gain under scaning, need to write the BB registers
+		/* config the initial gain under scaning, need to write the BB registers */
 #ifdef CONFIG_IOCTL_CFG80211
 		if ((wdev_to_priv(padapter->rtw_wdev))->p2p_enabled == true)
 			initialgain = 0x27;
 		else
 			initialgain = 0x17;
-#else	//	go through the WEXT interface //CONFIG_IOCTL_CFG80211
+#else	/* 	go through the WEXT interface CONFIG_IOCTL_CFG80211 */
 #ifdef CONFIG_P2P
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 			initialgain = 0x17;
 		else
 			initialgain = 0x28;
-#else	// CONFIG_P2P
+#else	/*  CONFIG_P2P */
 		initialgain = 0x17;
-#endif // CONFIG_P2P
-#endif // CONFIG_IOCTL_CFG80211
+#endif /*  CONFIG_P2P */
+#endif /*  CONFIG_IOCTL_CFG80211 */
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_INITIAL_GAIN, (u8 *)(&initialgain));
 
-		//set MSR to no link state
+		/* set MSR to no link state */
 		Set_MSR(padapter, _HW_STATE_NOLINK_);
 
-		val8 = 1; //under site survey
+		val8 = 1; /* under site survey */
 		rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 
 		pmlmeext->sitesurvey_res.state = SCAN_PROCESS;
@@ -10759,16 +10677,16 @@ u8 setkey_hdl(struct rtw_adapter *padapt
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	unsigned char					null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 
-	//main tx key for wep.
+	/* main tx key for wep. */
 	if (pparm->set_tx)
 		pmlmeinfo->key_index = pparm->keyid;
 
-	//write cam
+	/* write cam */
 	ctrl = BIT(15) | ((pparm->algorithm) << 2) | pparm->keyid;
 
 	write_cam(padapter, pparm->keyid, ctrl, null_sta, pparm->key);
 
-	//allow multicast packets to driver
+	/* allow multicast packets to driver */
 	rtw_hal_set_hwreg(padapter, HW_VAR_ON_RCR_AM, null_addr);
 
 	return H2C_SUCCESS;
@@ -10777,7 +10695,7 @@ u8 setkey_hdl(struct rtw_adapter *padapt
 u8 set_stakey_hdl(struct rtw_adapter *padapter, u8 *pbuf)
 {
 	u16 ctrl=0;
-	u8 cam_id;//cam_entry
+	u8 cam_id;/* cam_entry */
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct set_stakey_parm	*pparm = (struct set_stakey_parm *)pbuf;
@@ -10785,20 +10703,12 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 	struct tdls_info	*ptdlsinfo = &padapter->tdlsinfo;
 	struct sta_priv	*pstapriv = &padapter->stapriv;
 	struct sta_info	*psta;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
-	//cam_entry:
-	//0~3 for default key
+	/* cam_entry: */
+	/* 0~3 for default key */
 
-	//for concurrent mode (ap+sta):
-	//default key is disable, using sw encrypt/decrypt
-	//cam_entry = 4 //for sta mode (macid=0)
-	//cam_entry(macid+3) = 5 ~ N//for ap mode (aid=1~N, macid=2 ~N)
-
-	//for concurrent mode (sta+sta):
-	//default key is disable, using sw encrypt/decrypt
-	//cam_entry = 4 //mapping to macid=0
-	//cam_entry = 5 //mapping to macid=2
+	/* for concurrent mode (sta+sta): */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
@@ -10816,16 +10726,6 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 		{
 			cam_id = 4;
 		}
-/*
-		if (padapter->iface_type > PRIMARY_IFACE)
-		{
-			cam_id = 5;
-		}
-		else
-		{
-			cam_id = 4;
-		}
-*/
 	}
 #else
 	cam_id = 4;
@@ -10837,7 +10737,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 		struct sta_info *psta;
 		struct sta_priv *pstapriv = &padapter->stapriv;
 
-		if (pparm->algorithm == _NO_PRIVACY_)	// clear cam entry
+		if (pparm->algorithm == _NO_PRIVACY_)	/*  clear cam entry */
 		{
 			clear_cam_entry(padapter, pparm->id);
 			return H2C_SUCCESS_RSP;
@@ -10856,7 +10756,7 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 				return H2C_REJECTED;
 			}
 
-			cam_id = (psta->mac_id + 3);//0~3 for default key, cmd_id=macid + 3, macid=aid+1;
+			cam_id = (psta->mac_id + 3);/* 0~3 for default key, cmd_id=macid + 3, macid=aid+1; */
 
 			DBG_8192D("Write CAM, mac_addr=%x:%x:%x:%x:%x:%x, cam_entry=%d\n", pparm->addr[0],
 						pparm->addr[1], pparm->addr[2], pparm->addr[3], pparm->addr[4],
@@ -10875,9 +10775,9 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 
 	}
 
-	//below for sta mode
+	/* below for sta mode */
 
-	if (pparm->algorithm == _NO_PRIVACY_)	// clear cam entry
+	if (pparm->algorithm == _NO_PRIVACY_)	/*  clear cam entry */
 	{
 		clear_cam_entry(padapter, pparm->id);
 		return H2C_SUCCESS;
@@ -10893,12 +10793,12 @@ u8 set_stakey_hdl(struct rtw_adapter *pa
 		return H2C_SUCCESS;
 	}
 
-	psta = rtw_get_stainfo(pstapriv, pparm->addr);//Get TDLS Peer STA
+	psta = rtw_get_stainfo(pstapriv, pparm->addr);/* Get TDLS Peer STA */
 	if (psta->tdls_sta_state&TDLS_LINKED_STATE) {
 		write_cam(padapter, psta->mac_id, ctrl, pparm->addr, pparm->key);
 	}
 	else
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 	write_cam(padapter, cam_id, ctrl, pparm->addr, pparm->key);
 
 	pmlmeinfo->enc_algo = pparm->algorithm;
@@ -10921,11 +10821,11 @@ u8 add_ba_hdl(struct rtw_adapter *padapt
 	if (((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && (pmlmeinfo->HT_enable)) ||
 		((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
 	{
-		//pmlmeinfo->ADDBA_retry_count = 0;
-		//pmlmeinfo->candidate_tid_bitmap |= (0x1 << pparm->tid);
-		//psta->htpriv.candidate_tid_bitmap |= BIT(pparm->tid);
+		/* pmlmeinfo->ADDBA_retry_count = 0; */
+		/* pmlmeinfo->candidate_tid_bitmap |= (0x1 << pparm->tid); */
+		/* psta->htpriv.candidate_tid_bitmap |= BIT(pparm->tid); */
 		issue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);
-		//_set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO);
+		/* _set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO); */
 		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
 	}
 #ifdef CONFIG_TDLS
@@ -10934,10 +10834,10 @@ u8 add_ba_hdl(struct rtw_adapter *padapt
 		(psta->htpriv.ampdu_enable==true))
 	{
 		issue_action_BA(padapter, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);
-		//_set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO);
+		/* _set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO); */
 		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
 	}
-#endif //CONFIG
+#endif /* CONFIG */
 	else
 	{
 		psta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);
@@ -11008,7 +10908,7 @@ u8 mlme_evt_hdl(struct rtw_adapter *pada
 
 
 	#ifdef CHECK_EVENT_SEQ
-	// checking event sequence...
+	/*  checking event sequence... */
 	if (evt_seq != (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f))
 	{
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_info_,("Evetn Seq Error! %d vs %d\n", (evt_seq & 0x7f), (ATOMIC_READ(&pevt_priv->event_seq) & 0x7f)));
@@ -11019,14 +10919,14 @@ u8 mlme_evt_hdl(struct rtw_adapter *pada
 	}
 	#endif
 
-	// checking if event code is valid
+	/*  checking if event code is valid */
 	if (evt_code >= MAX_C2HEVT)
 	{
 		RT_TRACE(_module_rtl871x_cmd_c_,_drv_err_,("\nEvent Code(%d) mismatch!\n", evt_code));
 		goto _abort_event_;
 	}
 
-	// checking if event size match the event parm size
+	/*  checking if event size match the event parm size */
 	if ((wlanevents[evt_code].parmsize != 0) &&
 			(wlanevents[evt_code].parmsize != evt_sz))
 	{
@@ -11071,20 +10971,20 @@ u8 tx_beacon_hdl(struct rtw_adapter *pad
 		return H2C_PARAMETERS_ERROR;
 	}
 #ifdef CONFIG_AP_MODE
-	else //tx bc/mc frames after update TIM
+	else /* tx bc/mc frames after update TIM */
 	{
 		struct sta_info *psta_bmc;
 		struct list_head *xmitframe_plist, *xmitframe_phead;
 		struct xmit_frame *pxmitframe=NULL;
 		struct sta_priv  *pstapriv = &padapter->stapriv;
 
-		//for BC/MC Frames
+		/* for BC/MC Frames */
 		psta_bmc = rtw_get_bcmc_stainfo(padapter);
 		if (!psta_bmc)
 			return H2C_SUCCESS;
 
 		if ((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len>0)) {
-			rtw_msleep_os(10);// 10ms, ATIM(HIQ) Windows
+			rtw_msleep_os(10);/*  10ms, ATIM(HIQ) Windows */
 			spin_lock_bh(&psta_bmc->sleep_q.lock);
 
 			xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
@@ -11106,7 +11006,7 @@ u8 tx_beacon_hdl(struct rtw_adapter *pad
 
 				pxmitframe->attrib.triggered=1;
 
-				pxmitframe->attrib.qsel = 0x11;//HIQ
+				pxmitframe->attrib.qsel = 0x11;/* HIQ */
 
 				spin_unlock_bh(&psta_bmc->sleep_q.lock);
 				if (rtw_hal_xmit(padapter, pxmitframe) == true)
@@ -11115,7 +11015,7 @@ u8 tx_beacon_hdl(struct rtw_adapter *pad
 				}
 				spin_lock_bh(&psta_bmc->sleep_q.lock);
 
-				//pstapriv->tim_bitmap &= ~BIT(0);
+				/* pstapriv->tim_bitmap &= ~BIT(0); */
 
 			}
 
@@ -11136,7 +11036,7 @@ void change_band_update_ie(struct rtw_ad
 	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
 	u8	erpinfo=0x4;
 
-	//DBG_8192D("%s\n", __func__);
+	/* DBG_8192D("%s\n", __func__); */
 
 	if (pmlmeext->cur_channel >= 36)
 	{
@@ -11191,7 +11091,7 @@ void dc_SelectChannel(struct rtw_adapter
 		(padapter->DualMacConcurrent == true) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
-		// only mac0 could control BB&RF
+		/*  only mac0 could control BB&RF */
 		ptarget_adapter = padapter->pbuddy_adapter;
 	}
 	else
@@ -11214,7 +11114,7 @@ void dc_SetBWMode(struct rtw_adapter *pa
 		(padapter->DualMacConcurrent == true) &&
 		(padapter->adapter_type == SECONDARY_ADAPTER))
 	{
-		// only mac0 could control BB&RF
+		/*  only mac0 could control BB&RF */
 		ptarget_adapter = padapter->pbuddy_adapter;
 	}
 	else
@@ -11241,7 +11141,7 @@ void dc_set_channel_bwmode_disconnect(st
 		pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 		if ((check_fwstate(pbuddy_mlmepriv, _FW_LINKED)) != true)
 		{
-			//switch to the 20M Hz mode after disconnect
+			/* switch to the 20M Hz mode after disconnect */
 			pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
 			pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 
@@ -11250,7 +11150,7 @@ void dc_set_channel_bwmode_disconnect(st
 	}
 	else
 	{
-		//switch to the 20M Hz mode after disconnect
+		/* switch to the 20M Hz mode after disconnect */
 		pmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_20;
 		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
 
@@ -11280,17 +11180,17 @@ u8 dc_handle_join_request(struct rtw_ada
 		{
 			if ((check_fwstate(pbuddy_mlmepriv, WIFI_AP_STATE)) == true)
 			{
-				//issue deauth to all stas if if2 is at ap mode
+				/* issue deauth to all stas if if2 is at ap mode */
 				rtw_sta_flush(pbuddy_adapter);
 
-				//rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);
+				/* rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0); */
 				rtw_hal_set_hwreg(pbuddy_adapter, HW_VAR_CHECK_TXBUF, 0);
 			}
 			else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true)
 			{
 				if (pmlmeext->cur_channel == pbuddy_mlmeext->cur_channel)
 				{
-					// HT_CHANNEL_WIDTH_40 or HT_CHANNEL_WIDTH_20 but channel offset is different
+					/*  HT_CHANNEL_WIDTH_40 or HT_CHANNEL_WIDTH_20 but channel offset is different */
 					if ((pmlmeext->cur_bwmode == pbuddy_mlmeext->cur_bwmode) &&
 						(pmlmeext->cur_ch_offset != pbuddy_mlmeext->cur_ch_offset))
 					{
@@ -11337,7 +11237,7 @@ void dc_handle_join_done(struct rtw_adap
 		if (((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 				check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 		{
-			//restart and update beacon
+			/* restart and update beacon */
 			DBG_8192D("after join, current adapter, CH=%d, BW=%d, offset=%d\n", pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
 
 			if (join_res >= 0)
@@ -11352,7 +11252,7 @@ void dc_handle_join_done(struct rtw_adap
 					change_band = true;
 				}
 
-				//sync channel/bwmode/ch_offset with another adapter
+				/* sync channel/bwmode/ch_offset with another adapter */
 				pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
 
 				if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
@@ -11361,14 +11261,14 @@ void dc_handle_join_done(struct rtw_adap
 					if (p && ie_len)
 					{
 						pht_info = (struct HT_info_element *)(p+2);
-						pht_info->infos[0] &= ~(BIT(0)|BIT(1)); //no secondary channel is present
+						pht_info->infos[0] &= ~(BIT(0)|BIT(1)); /* no secondary channel is present */
 					}
 
 					if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 					{
 						pbuddy_mlmeext->cur_ch_offset = pmlmeext->cur_ch_offset;
 
-						//to update cur_ch_offset value in beacon
+						/* to update cur_ch_offset value in beacon */
 						if (pht_info)
 						{
 							switch (pmlmeext->cur_ch_offset)
@@ -11412,7 +11312,7 @@ void dc_handle_join_done(struct rtw_adap
 					}
 				}
 
-				// to update channel value in beacon
+				/*  to update channel value in beacon */
 				pbuddy_network_mlmeext->Configuration.DSConfig = pmlmeext->cur_channel;
 				p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _DSSET_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
 				if (p && ie_len>0)
@@ -11425,12 +11325,12 @@ void dc_handle_join_done(struct rtw_adap
 					pht_info->primary_channel = pmlmeext->cur_channel;
 				}
 
-				// update mlmepriv's cur_network
+				/*  update mlmepriv's cur_network */
 				memcpy(&pbuddy_mlmepriv->cur_network.network, pbuddy_network_mlmeext, pbuddy_network_mlmeext->Length);
 			}
 			else
 			{
-				// switch back to original channel/bwmode/ch_offset;
+				/*  switch back to original channel/bwmode/ch_offset; */
 				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 			}
 
@@ -11479,7 +11379,7 @@ u8 dc_handle_site_survey(struct rtw_adap
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	struct rtw_adapter * pbuddy_adapter = padapter->pbuddy_adapter;
 
-	// only mac0 can do scan request, help issue nulldata(1) for mac1
+	/*  only mac0 can do scan request, help issue nulldata(1) for mac1 */
 	if (pbuddy_adapter != NULL &&
 		padapter->DualMacConcurrent == true)
 	{
@@ -11544,7 +11444,7 @@ void dc_set_channel_bwmode_survey_done(s
 		set_channel_bwmode(padapter, cur_channel, cur_ch_offset, cur_bwmode);
 
 		if (is_client_associated_to_ap(pbuddy_adapter) == true) {
-			//issue null data
+			/* issue null data */
 			issue_nulldata(pbuddy_adapter, NULL, 0, 0, 0);
 		}
 
@@ -11601,7 +11501,7 @@ void dc_set_ap_channel_bandwidth(struct
 		}
 		else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED)==true)
 		{
-			//To sync cur_channel/cur_bwmode/cur_ch_offset with another adapter
+			/* To sync cur_channel/cur_bwmode/cur_ch_offset with another adapter */
 			DBG_8192D("Another iface is at linked state, sync cur_channel/cur_bwmode/cur_ch_offset\n");
 			DBG_8192D("Another adapter, CH=%d, BW=%d, offset=%d\n", pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_bwmode, pbuddy_mlmeext->cur_ch_offset);
 			DBG_8192D("Current adapter, CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
@@ -11616,7 +11516,7 @@ void dc_set_ap_channel_bandwidth(struct
 				{
 					cur_ch_offset = pbuddy_mlmeext->cur_ch_offset;
 
-					//to update cur_ch_offset value in beacon
+					/* to update cur_ch_offset value in beacon */
 					if (pht_info)
 					{
 						switch (cur_ch_offset)
@@ -11660,7 +11560,7 @@ void dc_set_ap_channel_bandwidth(struct
 				}
 			}
 
-			// to update channel value in beacon
+			/*  to update channel value in beacon */
 			pnetwork->Configuration.DSConfig = cur_channel;
 			p = rtw_get_ie((pnetwork->IEs + sizeof(struct ndis_802_11_fixed_ies)), _DSSET_IE_, &ie_len, (pnetwork->IELength - sizeof(struct ndis_802_11_fixed_ies)));
 			if (p && ie_len>0)
@@ -11771,7 +11671,7 @@ int concurrent_chk_start_clnt_join(struc
 	pbuddy_pmlmeinfo = &(pbuddy_mlmeext->mlmext_info);
 	pbuddy_mlmepriv = &(pbuddy_adapter->mlmepriv);
 
-	if ((pbuddy_pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)//for AP MODE
+	if ((pbuddy_pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)/* for AP MODE */
 	{
 		bool inform_ch_switch = false;
 		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel)
@@ -11792,20 +11692,20 @@ int concurrent_chk_start_clnt_join(struc
 			} else
 			#endif
 			{
-				//issue deauth to all stas if if2 is at ap mode
+				/* issue deauth to all stas if if2 is at ap mode */
 				rtw_sta_flush(pbuddy_adapter);
 			}
 			rtw_hal_set_hwreg(padapter, HW_VAR_CHECK_TXBUF, 0);
 		}
 	}
 	else if (check_fwstate(pbuddy_mlmepriv, _FW_LINKED) == true &&
-		check_fwstate(pbuddy_mlmepriv, WIFI_STATION_STATE) == true) //for Client Mode/p2p client
+		check_fwstate(pbuddy_mlmepriv, WIFI_STATION_STATE) == true) /* for Client Mode/p2p client */
 	{
 #if defined(CONFIG_P2P) && defined(CONFIG_IOCTL_CFG80211)
 		struct wifidirect_info *pbuddy_wdinfo = &(pbuddy_adapter->wdinfo);
 		if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
-			return _SUCCESS; //wlan0-sta mode has higher priority than p2p0-p2p client
-#endif //CONFIG_P2P && CONFIG_IOCTL_CFG80211
+			return _SUCCESS; /* wlan0-sta mode has higher priority than p2p0-p2p client */
+#endif /* CONFIG_P2P && CONFIG_IOCTL_CFG80211 */
 
 		if (pmlmeext->cur_channel != pbuddy_mlmeext->cur_channel)
 		{
@@ -11859,7 +11759,7 @@ void concurrent_chk_joinbss_done(struct
 	if (((pbuddy_mlmeinfo->state&0x03) == WIFI_FW_AP_STATE) &&
 			check_fwstate(pbuddy_mlmepriv, _FW_LINKED))
 	{
-		//restart and update beacon
+		/* restart and update beacon */
 
 		DBG_8192D("after join,primary adapter, CH=%d, BW=%d, offset=%d\n"
 			, pmlmeext->cur_channel, pmlmeext->cur_bwmode, pmlmeext->cur_ch_offset);
@@ -11875,7 +11775,7 @@ void concurrent_chk_joinbss_done(struct
 				(pmlmeext->cur_channel >= 36 && pbuddy_mlmeext->cur_channel <= 14))
 				change_band = true;
 
-			//sync channel/bwmode/ch_offset with primary adapter
+			/* sync channel/bwmode/ch_offset with primary adapter */
 			pbuddy_mlmeext->cur_channel = pmlmeext->cur_channel;
 			if (pbuddy_mlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 			{
@@ -11883,14 +11783,14 @@ void concurrent_chk_joinbss_done(struct
 				if (p && ie_len)
 				{
 					pht_info = (struct HT_info_element *)(p+2);
-					pht_info->infos[0] &= ~(BIT(0)|BIT(1)); //no secondary channel is present
+					pht_info->infos[0] &= ~(BIT(0)|BIT(1)); /* no secondary channel is present */
 				}
 
 				if (pmlmeext->cur_bwmode == HT_CHANNEL_WIDTH_40)
 				{
 					pbuddy_mlmeext->cur_ch_offset = pmlmeext->cur_ch_offset;
 
-					//to update cur_ch_offset value in beacon
+					/* to update cur_ch_offset value in beacon */
 					if (pht_info)
 					{
 						switch (pmlmeext->cur_ch_offset)
@@ -11985,7 +11885,7 @@ void concurrent_chk_joinbss_done(struct
 
 			}
 
-			// to update channel value in beacon
+			/*  to update channel value in beacon */
 			pbuddy_network_mlmeext->Configuration.DSConfig = pmlmeext->cur_channel;
 			p = rtw_get_ie((pbuddy_network_mlmeext->IEs + sizeof(struct ndis_802_11_fixed_ies)), _DSSET_IE_, &ie_len, (pbuddy_network_mlmeext->IELength - sizeof(struct ndis_802_11_fixed_ies)));
 			if (p && ie_len>0)
@@ -11998,13 +11898,13 @@ void concurrent_chk_joinbss_done(struct
 				pht_info->primary_channel = pmlmeext->cur_channel;
 			}
 
-			//buddy interface band is different from current interface, update ERP, support rate, ext support rate IE
+			/* buddy interface band is different from current interface, update ERP, support rate, ext support rate IE */
 			if (change_band == true)
 				change_band_update_ie(pbuddy_adapter, pbuddy_network_mlmeext);
 		}
 		else
 		{
-			// switch back to original channel/bwmode/ch_offset;
+			/*  switch back to original channel/bwmode/ch_offset; */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 		}
 
@@ -12030,12 +11930,12 @@ void concurrent_chk_joinbss_done(struct
 		}
 		else
 		{
-			// switch back to original channel/bwmode/ch_offset;
+			/*  switch back to original channel/bwmode/ch_offset; */
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
 		}
 	}
 }
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 u8 set_ch_hdl(struct rtw_adapter *padapter, u8 *pbuf)
 {
@@ -12130,22 +12030,22 @@ u8 set_csa_hdl(struct rtw_adapter *padap
 	return	H2C_SUCCESS;
 #else
 	return	H2C_REJECTED;
-#endif //CONFIG_DFS
+#endif /* CONFIG_DFS */
 }
 
-// TDLS_WRCR		: write RCR DATA BIT
-// TDLS_SD_PTI		: issue peer traffic indication
-// TDLS_CS_OFF		: go back to the channel linked with AP, terminating channel switch procedure
-// TDLS_INIT_CH_SEN	: init channel sensing, receive all data and mgnt frame
-// TDLS_DONE_CH_SEN: channel sensing and report candidate channel
-// TDLS_OFF_CH		: first time set channel to off channel
-// TDLS_BASE_CH		: go back tp the channel linked with AP when set base channel as target channel
-// TDLS_P_OFF_CH	: periodically go to off channel
-// TDLS_P_BASE_CH	: periodically go back to base channel
-// TDLS_RS_RCR		: restore RCR
-// TDLS_CKALV_PH1	: check alive timer phase1
-// TDLS_CKALV_PH2	: check alive timer phase2
-// TDLS_FREE_STA	: free tdls sta
+/*  TDLS_WRCR		: write RCR DATA BIT */
+/*  TDLS_SD_PTI		: issue peer traffic indication */
+/*  TDLS_CS_OFF		: go back to the channel linked with AP, terminating channel switch procedure */
+/*  TDLS_INIT_CH_SEN	: init channel sensing, receive all data and mgnt frame */
+/*  TDLS_DONE_CH_SEN: channel sensing and report candidate channel */
+/*  TDLS_OFF_CH		: first time set channel to off channel */
+/*  TDLS_BASE_CH		: go back tp the channel linked with AP when set base channel as target channel */
+/*  TDLS_P_OFF_CH	: periodically go to off channel */
+/*  TDLS_P_BASE_CH	: periodically go back to base channel */
+/*  TDLS_RS_RCR		: restore RCR */
+/*  TDLS_CKALV_PH1	: check alive timer phase1 */
+/*  TDLS_CKALV_PH2	: check alive timer phase2 */
+/*  TDLS_FREE_STA	: free tdls sta */
 u8 tdls_hdl(struct rtw_adapter *padapter, unsigned char *pbuf)
 {
 #ifdef CONFIG_TDLS
@@ -12170,18 +12070,18 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 			return H2C_REJECTED;
 	}
 
-	//spin_lock_bh(&(ptdlsinfo->hdl_lock));
+	/* spin_lock_bh(&(ptdlsinfo->hdl_lock)); */
 	DBG_8192D("[%s] option:%d\n", __func__, option);
 
 	switch (option) {
 		case TDLS_WRCR:
-			//As long as TDLS handshake success, we should set RCR_CBSSID_DATA bit to 0
-			//such we can receive all kinds of data frames.
+			/* As long as TDLS handshake success, we should set RCR_CBSSID_DATA bit to 0 */
+			/* such we can receive all kinds of data frames. */
 			rtw_hal_set_hwreg(padapter, HW_VAR_TDLS_WRCR, 0);
 			DBG_8192D("TDLS with %pM\n", ptdls_sta->hwaddr);
 
 			pmlmeinfo->FW_sta_info[ptdls_sta->mac_id].psta = ptdls_sta;
-			//set TDLS sta rate.
+			/* set TDLS sta rate. */
 			set_sta_rate(padapter, ptdls_sta);
 			break;
 		case TDLS_SD_PTI:
@@ -12236,7 +12136,7 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 				if (ptdls_sta->tdls_sta_state & TDLS_PEER_SLEEP_STATE) {
 					ptdls_sta->tdls_sta_state |= TDLS_APSD_CHSW_STATE;
 				} else {
-					//send null data with pwrbit==1 before send ch_switching_req to peer STA.
+					/* send null data with pwrbit==1 before send ch_switching_req to peer STA. */
 					issue_nulldata(padapter, NULL, 1, 0, 0);
 
 					ptdls_sta->tdls_sta_state |= TDLS_CH_SW_INITIATOR_STATE;
@@ -12299,10 +12199,10 @@ u8 tdls_hdl(struct rtw_adapter *padapter
 
 	}
 
-	//spin_unlock_bh(&(ptdlsinfo->hdl_lock));
+	/* spin_unlock_bh(&(ptdlsinfo->hdl_lock)); */
 
 	return H2C_SUCCESS;
 #else
 	return H2C_REJECTED;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 }
--- a/drivers/staging/rtl8192du/core/rtw_p2p.c
+++ b/drivers/staging/rtl8192du/core/rtw_p2p.c
@@ -92,7 +92,7 @@ static u32 go_add_group_info_attr(struct
 	phead = &pstapriv->asoc_list;
 	plist = get_next(phead);
 
-	//look up sta asoc_queue
+	/* look up sta asoc_queue */
 	while ((rtw_end_of_queue_search(phead, plist)) == false)
 	{
 		psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
@@ -106,18 +106,17 @@ static u32 go_add_group_info_attr(struct
 
 			pcur++;
 
-			//P2P device address
+			/* P2P device address */
 			memcpy(pcur, psta->dev_addr, ETH_ALEN);
 			pcur += ETH_ALEN;
 
-			//P2P interface address
+			/* P2P interface address */
 			memcpy(pcur, psta->hwaddr, ETH_ALEN);
 			pcur += ETH_ALEN;
 
 			*pcur = psta->dev_cap;
 			pcur++;
 
-			//*(u16*)(pcur) = cpu_to_be16(psta->config_methods);
 			RTW_PUT_BE16(pcur, psta->config_methods);
 			pcur += 2;
 
@@ -132,11 +131,9 @@ static u32 go_add_group_info_attr(struct
 
 			if (psta->dev_name_len>0)
 			{
-				//*(u16*)(pcur) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
 				RTW_PUT_BE16(pcur, WPS_ATTR_DEVICE_NAME);
 				pcur += 2;
 
-				//*(u16*)(pcur) = cpu_to_be16(psta->dev_name_len);
 				RTW_PUT_BE16(pcur, psta->dev_name_len);
 				pcur += 2;
 
@@ -151,7 +148,7 @@ static u32 go_add_group_info_attr(struct
 
 			attr_len += tmplen;
 
-			//pstart += tmplen;
+			/* pstart += tmplen; */
 			pstart = pcur;
 
 		}
@@ -180,7 +177,7 @@ static void issue_group_disc_req(struct
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	unsigned char category = RTW_WLAN_CATEGORY_P2P;//P2P action frame
+	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame */
 	u32	p2poui = cpu_to_be32(P2POUI);
 	u8	oui_subtype = P2P_GO_DISC_REQUEST;
 	u8	dialogToken=0;
@@ -192,7 +189,7 @@ static void issue_group_disc_req(struct
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -215,13 +212,13 @@ static void issue_group_disc_req(struct
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
-	//Build P2P action frame header
+	/* Build P2P action frame header */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
-	//there is no IE in this P2P action frame
+	/* there is no IE in this P2P action frame */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -252,7 +249,7 @@ static void issue_p2p_devdisc_resp(struc
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -275,7 +272,7 @@ static void issue_p2p_devdisc_resp(struc
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
-	//Build P2P public action frame header
+	/* Build P2P public action frame header */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
@@ -283,15 +280,15 @@ static void issue_p2p_devdisc_resp(struc
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
 
-	//Build P2P IE
-	//	P2P OUI
+	/* Build P2P IE */
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	// P2P_ATTR_STATUS
+	/*  P2P_ATTR_STATUS */
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, p2pielen, p2pie, &pattrib->pktlen);
@@ -306,14 +303,14 @@ static void issue_p2p_provision_resp(str
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	unsigned char category = RTW_WLAN_CATEGORY_PUBLIC;
 	u8			action = P2P_PUB_ACTION_ACTION;
-	u8			dialogToken = frame_body[7];	//	The Dialog Token of provisioning discovery request frame.
+	u8			dialogToken = frame_body[7];	/* 	The Dialog Token of provisioning discovery request frame. */
 	u32			p2poui = cpu_to_be32(P2POUI);
 	u8			oui_subtype = P2P_PROVISION_DISC_RESP;
 	u8			wpsie[ 100 ] = { 0x00 };
 	u8			wpsielen = 0;
 #ifdef CONFIG_WFD
 	u32					wfdielen = 0;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	struct xmit_frame			*pmgntframe;
 	struct pkt_attrib			*pattrib;
@@ -330,7 +327,7 @@ static void issue_p2p_provision_resp(str
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -360,24 +357,20 @@ static void issue_p2p_provision_resp(str
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
 	wpsielen = 0;
-	//	WPS OUI
-	//*(u32*) (wpsie) = cpu_to_be32(WPSOUI);
+	/* 	WPS OUI */
 	RTW_PUT_BE32(wpsie, WPSOUI);
 	wpsielen += 4;
 
-	//	Config Method
-	//	Type:
-	//*(u16*) (wpsie + wpsielen) = cpu_to_be16(WPS_ATTR_CONF_METHOD);
+	/* 	Config Method */
+	/* 	Type: */
 	RTW_PUT_BE16(wpsie + wpsielen, WPS_ATTR_CONF_METHOD);
 	wpsielen += 2;
 
-	//	Length:
-	//*(u16*) (wpsie + wpsielen) = cpu_to_be16(0x0002);
+	/* 	Length: */
 	RTW_PUT_BE16(wpsie + wpsielen, 0x0002);
 	wpsielen += 2;
 
-	//	Value:
-	//*(u16*) (wpsie + wpsielen) = cpu_to_be16(config_method);
+	/* 	Value: */
 	RTW_PUT_BE16(wpsie + wpsielen, config_method);
 	wpsielen += 2;
 
@@ -387,7 +380,7 @@ static void issue_p2p_provision_resp(str
 	wfdielen = build_provdisc_resp_wfd_ie(pwdinfo, pframe);
 	pframe += wfdielen;
 	pattrib->pktlen += wfdielen;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 	pattrib->last_txcmdsz = pattrib->pktlen;
 
@@ -406,7 +399,7 @@ static void issue_p2p_presence_resp(stru
 	struct rtw_adapter *padapter = pwdinfo->padapter;
 	struct xmit_priv			*pxmitpriv = &(padapter->xmitpriv);
 	struct mlme_ext_priv	*pmlmeext = &(padapter->mlmeextpriv);
-	unsigned char category = RTW_WLAN_CATEGORY_P2P;//P2P action frame
+	unsigned char category = RTW_WLAN_CATEGORY_P2P;/* P2P action frame */
 	u32	p2poui = cpu_to_be32(P2POUI);
 	u8	oui_subtype = P2P_PRESENCE_RESPONSE;
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
@@ -420,7 +413,7 @@ static void issue_p2p_presence_resp(stru
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -443,29 +436,29 @@ static void issue_p2p_presence_resp(stru
 	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
 	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
 
-	//Build P2P action frame header
+	/* Build P2P action frame header */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *) &(p2poui), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(oui_subtype), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogToken), &(pattrib->pktlen));
 
 
-	//Add P2P IE header
-	//	P2P OUI
+	/* Add P2P IE header */
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//Add Status attribute in P2P IE
+	/* Add Status attribute in P2P IE */
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status);
 
-	//Add NoA attribute in P2P IE
-	noa_attr_content[0] = 0x1;//index
-	noa_attr_content[1] = 0x0;//CTWindow and OppPS Parameters
+	/* Add NoA attribute in P2P IE */
+	noa_attr_content[0] = 0x1;/* index */
+	noa_attr_content[1] = 0x0;/* CTWindow and OppPS Parameters */
 
-	//todo: Notice of Absence Descriptor(s)
+	/* todo: Notice of Absence Descriptor(s) */
 
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_NOA, 2, noa_attr_content);
 
@@ -486,27 +479,27 @@ u32 build_beacon_p2p_ie(struct wifidirec
 	u32 len=0, p2pielen = 0;
 
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
 
-	//	According to the P2P Specification, the beacon frame should contain 3 P2P attributes
-	//	1. P2P Capability
-	//	2. P2P Device ID
-	//	3. Notice of Absence (NOA)
-
-	//	P2P Capability ATTR
-	//	Type:
-	//	Length:
-	//	Value:
-	//	Device Capability Bitmap, 1 byte
-	//	Be able to participate in additional P2P Groups and
-	//	support the P2P Invitation Procedure
-	//	Group Capability Bitmap, 1 byte
+	/* 	According to the P2P Specification, the beacon frame should contain 3 P2P attributes */
+	/* 	1. P2P Capability */
+	/* 	2. P2P Device ID */
+	/* 	3. Notice of Absence (NOA) */
+
+	/* 	P2P Capability ATTR */
+	/* 	Type: */
+	/* 	Length: */
+	/* 	Value: */
+	/* 	Device Capability Bitmap, 1 byte */
+	/* 	Be able to participate in additional P2P Groups and */
+	/* 	support the P2P Invitation Procedure */
+	/* 	Group Capability Bitmap, 1 byte */
 	capability = P2P_DEVCAP_INVITATION_PROC|P2P_DEVCAP_CLIENT_DISCOVERABILITY;
 	capability |=  ((P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS) << 8);
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_PROVISIONING_ING))
@@ -517,16 +510,16 @@ u32 build_beacon_p2p_ie(struct wifidirec
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_CAPABILITY, 2, (u8*)&capability);
 
 
-	// P2P Device ID ATTR
+	/*  P2P Device ID ATTR */
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_DEVICE_ID, ETH_ALEN, pwdinfo->device_addr);
 
 
-	// Notice of Absence ATTR
-	//	Type:
-	//	Length:
-	//	Value:
+	/*  Notice of Absence ATTR */
+	/* 	Type: */
+	/* 	Length: */
+	/* 	Value: */
 
-	//go_add_noa_attr(pwdinfo);
+	/* go_add_noa_attr(pwdinfo); */
 
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &len);
@@ -544,77 +537,77 @@ u32 build_beacon_wfd_ie(struct wifidirec
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110812
-	//	According to the WFD Specification, the beacon frame should contain 4 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID
-	//	3. Coupled Sink Information
+	/* 	Commented by Albert 20110812 */
+	/* 	According to the WFD Specification, the beacon frame should contain 4 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID */
+	/* 	3. Coupled Sink Information */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
+	/* 	Value1: */
+	/* 	WFD device information */
 
 	if (P2P_ROLE_GO == pwdinfo->role)
 	{
 		if (is_any_client_associated(pwdinfo->padapter))
 		{
-			//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery)
+			/* 	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) */
 			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD);
 		}
 		else
 		{
-			//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+			/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 			RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 		}
 
 	}
 	else
 	{
-		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+		/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	}
 
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -626,20 +619,20 @@ u32 build_beacon_wfd_ie(struct wifidirec
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -660,35 +653,35 @@ u32 build_probe_req_wfd_ie(struct wifidi
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110812
-	//	According to the WFD Specification, the probe request frame should contain 4 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID
-	//	3. Coupled Sink Information
+	/* 	Commented by Albert 20110812 */
+	/* 	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID */
+	/* 	3. Coupled Sink Information */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
+	/* 	Value1: */
+	/* 	WFD device information */
 
 	if (1 == pwdinfo->wfd_tdls_enable)
 	{
-		//	WFD primary sink + available for WFD session + WiFi TDLS mode + WSC (WFD Service Discovery)
+		/* 	WFD primary sink + available for WFD session + WiFi TDLS mode + WSC (WFD Service Discovery) */
 		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type |
 						WFD_DEVINFO_SESSION_AVAIL |
 						WFD_DEVINFO_WSD |
@@ -696,7 +689,7 @@ u32 build_probe_req_wfd_ie(struct wifidi
 	}
 	else
 	{
-		//	WFD primary sink + available for WFD session + WiFi Direct mode + WSC (WFD Service Discovery)
+		/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSC (WFD Service Discovery) */
 		RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type |
 						WFD_DEVINFO_SESSION_AVAIL |
 						WFD_DEVINFO_WSD);
@@ -704,29 +697,29 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -738,20 +731,20 @@ u32 build_probe_req_wfd_ie(struct wifidi
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -772,33 +765,33 @@ u32 build_probe_resp_wfd_ie(struct wifid
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110812
-	//	According to the WFD Specification, the probe response frame should contain 4 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID
-	//	3. Coupled Sink Information
-	//	4. WFD Session Information
+	/* 	Commented by Albert 20110812 */
+	/* 	According to the WFD Specification, the probe response frame should contain 4 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID */
+	/* 	3. Coupled Sink Information */
+	/* 	4. WFD Session Information */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + available for WFD session + WiFi Direct mode */
 
 	if ( true == pwdinfo->session_available)
 	{
@@ -808,12 +801,12 @@ u32 build_probe_resp_wfd_ie(struct wifid
 			{
 				if (pwdinfo->wfd_tdls_enable)
 				{
-					//	WFD primary sink + TDLS mode + WSD (WFD Service Discovery)
+					/* 	WFD primary sink + TDLS mode + WSD (WFD Service Discovery) */
 					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
 				}
 				else
 				{
-					//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery)
+					/* 	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) */
 					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
 				}
 			}
@@ -821,12 +814,12 @@ u32 build_probe_resp_wfd_ie(struct wifid
 			{
 				if (pwdinfo->wfd_tdls_enable)
 				{
-					//	WFD primary sink + available for WFD session + TDLS mode + WSD (WFD Service Discovery)
+					/* 	WFD primary sink + available for WFD session + TDLS mode + WSD (WFD Service Discovery) */
 					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
 				}
 				else
 				{
-					//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+					/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 					RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
 				}
 			}
@@ -835,12 +828,12 @@ u32 build_probe_resp_wfd_ie(struct wifid
 		{
 			if (pwdinfo->wfd_tdls_enable)
 			{
-				//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+				/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 				RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_HDCP_SUPPORT);
 			}
 			else
 			{
-				//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+				/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 				RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD | WFD_DEVINFO_HDCP_SUPPORT);
 			}
 		}
@@ -860,29 +853,29 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -894,20 +887,20 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -917,40 +910,40 @@ u32 build_probe_resp_wfd_ie(struct wifid
 
 	if (P2P_ROLE_GO == pwdinfo->role)
 	{
-		//	WFD Session Information ATTR
-		//	Type:
+		/* 	WFD Session Information ATTR */
+		/* 	Type: */
 		wfdie[ wfdielen++ ] = WFD_ATTR_SESSION_INFO;
 
-		//	Length:
-		//	Note: In the WFD specification, the size of length field is 2.
+		/* 	Length: */
+		/* 	Note: In the WFD specification, the size of length field is 2. */
 		RTW_PUT_BE16(wfdie + wfdielen, 0x0000);
 		wfdielen += 2;
 
-		//	Todo: to add the list of WFD device info descriptor in WFD group.
+		/* 	Todo: to add the list of WFD device info descriptor in WFD group. */
 
 	}
 #ifdef CONFIG_CONCURRENT_MODE
 #ifdef CONFIG_TDLS
 	if ((tunneled == 0) && (padapter->pbuddy_adapter->wdinfo.wfd_tdls_enable == 1))
 	{
-		//	Alternative MAC Address ATTR
-		//	Type:
+		/* 	Alternative MAC Address ATTR */
+		/* 	Type: */
 		wfdie[ wfdielen++ ] = WFD_ATTR_ALTER_MAC;
 
-		//	Length:
-		//	Note: In the WFD specification, the size of length field is 2.
+		/* 	Length: */
+		/* 	Note: In the WFD specification, the size of length field is 2. */
 		RTW_PUT_BE16(wfdie + wfdielen,  ETH_ALEN);
 		wfdielen += 2;
 
-		//	Value:
-		//	Alternative MAC Address
+		/* 	Value: */
+		/* 	Alternative MAC Address */
 		memcpy(wfdie + wfdielen, &padapter->pbuddy_adapter->eeprompriv.mac_addr[ 0 ], ETH_ALEN);
-		//	This mac address is used to make the WFD session when TDLS is enable.
+		/* 	This mac address is used to make the WFD session when TDLS is enable. */
 
 		wfdielen += ETH_ALEN;
 	}
-#endif // CONFIG_TDLS
-#endif // CONFIG_CONCURRENT_MODE
+#endif /*  CONFIG_TDLS */
+#endif /*  CONFIG_CONCURRENT_MODE */
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, &len);
 
@@ -965,7 +958,7 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 	struct mlme_priv			*pmlmepriv = NULL;
 	struct wifi_display_info		*pwfd_info = NULL;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE) || rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 	{
 		return 0;
@@ -979,53 +972,53 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110812
-	//	According to the WFD Specification, the probe request frame should contain 4 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID
-	//	3. Coupled Sink Information
+	/* 	Commented by Albert 20110812 */
+	/* 	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID */
+	/* 	3. Coupled Sink Information */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1037,20 +1030,20 @@ u32 build_assoc_req_wfd_ie(struct wifidi
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1071,58 +1064,58 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110812
-	//	According to the WFD Specification, the probe request frame should contain 4 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID
-	//	3. Coupled Sink Information
+	/* 	Commented by Albert 20110812 */
+	/* 	According to the WFD Specification, the probe request frame should contain 4 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID */
+	/* 	3. Coupled Sink Information */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1134,20 +1127,20 @@ u32 build_assoc_resp_wfd_ie(struct wifid
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1168,58 +1161,58 @@ u32 build_nego_req_wfd_ie(struct wifidir
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110825
-	//	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID (Optional)
-	//	3. Local IP Adress (Optional)
+	/* 	Commented by Albert 20110825 */
+	/* 	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID (Optional) */
+	/* 	3. Local IP Adress (Optional) */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1231,20 +1224,20 @@ u32 build_nego_req_wfd_ie(struct wifidir
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1265,58 +1258,58 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110825
-	//	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID (Optional)
-	//	3. Local IP Adress (Optional)
+	/* 	Commented by Albert 20110825 */
+	/* 	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID (Optional) */
+	/* 	3. Local IP Adress (Optional) */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1328,20 +1321,20 @@ u32 build_nego_resp_wfd_ie(struct wifidi
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1363,58 +1356,58 @@ u32 build_nego_confirm_wfd_ie(struct wif
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110825
-	//	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID (Optional)
-	//	3. Local IP Adress (Optional)
+	/* 	Commented by Albert 20110825 */
+	/* 	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID (Optional) */
+	/* 	3. Local IP Adress (Optional) */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + WiFi Direct mode + WSD (WFD Service Discovery) + WFD Session Available */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_WSD | WFD_DEVINFO_SESSION_AVAIL);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1426,20 +1419,20 @@ u32 build_nego_confirm_wfd_ie(struct wif
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1461,58 +1454,58 @@ u32 build_invitation_req_wfd_ie(struct w
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110825
-	//	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID (Optional)
-	//	3. Local IP Adress (Optional)
+	/* 	Commented by Albert 20110825 */
+	/* 	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID (Optional) */
+	/* 	3. Local IP Adress (Optional) */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1524,20 +1517,20 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1547,16 +1540,16 @@ u32 build_invitation_req_wfd_ie(struct w
 
 	if (P2P_ROLE_GO == pwdinfo->role)
 	{
-		//	WFD Session Information ATTR
-		//	Type:
+		/* 	WFD Session Information ATTR */
+		/* 	Type: */
 		wfdie[ wfdielen++ ] = WFD_ATTR_SESSION_INFO;
 
-		//	Length:
-		//	Note: In the WFD specification, the size of length field is 2.
+		/* 	Length: */
+		/* 	Note: In the WFD specification, the size of length field is 2. */
 		RTW_PUT_BE16(wfdie + wfdielen, 0x0000);
 		wfdielen += 2;
 
-		//	Todo: to add the list of WFD device info descriptor in WFD group.
+		/* 	Todo: to add the list of WFD device info descriptor in WFD group. */
 
 	}
 
@@ -1573,58 +1566,58 @@ u32 build_invitation_resp_wfd_ie(struct
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110825
-	//	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID (Optional)
-	//	3. Local IP Adress (Optional)
+	/* 	Commented by Albert 20110825 */
+	/* 	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID (Optional) */
+	/* 	3. Local IP Adress (Optional) */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1636,20 +1629,20 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1659,16 +1652,16 @@ u32 build_invitation_resp_wfd_ie(struct
 
 	if (P2P_ROLE_GO == pwdinfo->role)
 	{
-		//	WFD Session Information ATTR
-		//	Type:
+		/* 	WFD Session Information ATTR */
+		/* 	Type: */
 		wfdie[ wfdielen++ ] = WFD_ATTR_SESSION_INFO;
 
-		//	Length:
-		//	Note: In the WFD specification, the size of length field is 2.
+		/* 	Length: */
+		/* 	Note: In the WFD specification, the size of length field is 2. */
 		RTW_PUT_BE16(wfdie + wfdielen, 0x0000);
 		wfdielen += 2;
 
-		//	Todo: to add the list of WFD device info descriptor in WFD group.
+		/* 	Todo: to add the list of WFD device info descriptor in WFD group. */
 
 	}
 
@@ -1685,58 +1678,58 @@ u32 build_provdisc_req_wfd_ie(struct wif
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110825
-	//	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID (Optional)
-	//	3. Local IP Adress (Optional)
+	/* 	Commented by Albert 20110825 */
+	/* 	According to the WFD Specification, the provision discovery request frame should contain 3 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID (Optional) */
+	/* 	3. Local IP Adress (Optional) */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1748,20 +1741,20 @@ u32 build_provdisc_req_wfd_ie(struct wif
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1783,58 +1776,58 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	struct wifi_display_info*	pwfd_info = padapter->wdinfo.wfd_info;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110825
-	//	According to the WFD Specification, the provision discovery response frame should contain 3 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID (Optional)
-	//	3. Local IP Adress (Optional)
+	/* 	Commented by Albert 20110825 */
+	/* 	According to the WFD Specification, the provision discovery response frame should contain 3 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID (Optional) */
+	/* 	3. Local IP Adress (Optional) */
 
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery)
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + available for WFD session + WiFi Direct mode + WSD (WFD Service Discovery) */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->wfd_device_type | WFD_DEVINFO_SESSION_AVAIL | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1846,20 +1839,20 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 
 	wfdielen += ETH_ALEN;
 
-	//	Coupled Sink Information ATTR
-	//	Type:
+	/* 	Coupled Sink Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_COUPLED_SINK_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0007);
 	wfdielen += 2;
 
-	//	Value:
-	//	Coupled Sink Status bitmap
-	//	Not coupled/available for Coupling
+	/* 	Value: */
+	/* 	Coupled Sink Status bitmap */
+	/* 	Not coupled/available for Coupling */
 	wfdie[ wfdielen++ ] = 0;
-	//  MAC Addr.
+	/*   MAC Addr. */
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
 	wfdie[ wfdielen++ ] = 0;
@@ -1872,7 +1865,7 @@ u32 build_provdisc_resp_wfd_ie(struct wi
 	return len;
 }
 
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 u32 build_probe_resp_p2p_ie(struct wifidirect_info *pwdinfo, u8 *pbuf)
 {
@@ -1880,37 +1873,36 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	u32 len=0, p2pielen = 0;
 #ifdef CONFIG_INTEL_WIDI
 	u8 zero_array_check[L2SDTA_SERVICE_VE_LEN] = { 0x00 };
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//	Commented by Albert 20100907
-	//	According to the P2P Specification, the probe response frame should contain 5 P2P attributes
-	//	1. P2P Capability
-	//	2. Extended Listen Timing
-	//	3. Notice of Absence (NOA)	(Only GO needs this)
-	//	4. Device Info
-	//	5. Group Info	(Only GO need this)
+	/* 	Commented by Albert 20100907 */
+	/* 	According to the P2P Specification, the probe response frame should contain 5 P2P attributes */
+	/* 	1. P2P Capability */
+	/* 	2. Extended Listen Timing */
+	/* 	3. Notice of Absence (NOA)	(Only GO needs this) */
+	/* 	4. Device Info */
+	/* 	5. Group Info	(Only GO need this) */
 
-	//	P2P Capability ATTR
-	//	Type:
+	/* 	P2P Capability ATTR */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
-	//	Length:
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
+	/* 	Length: */
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	//	Device Capability Bitmap, 1 byte
+	/* 	Value: */
+	/* 	Device Capability Bitmap, 1 byte */
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
-	//	Group Capability Bitmap, 1 byte
+	/* 	Group Capability Bitmap, 1 byte */
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		p2pie[ p2pielen ] = (P2P_GRPCAP_GO | P2P_GRPCAP_INTRABSS);
@@ -1922,7 +1914,7 @@ u32 build_probe_resp_p2p_ie(struct wifid
 	}
 	else if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE))
 	{
-		//	Group Capability Bitmap, 1 byte
+		/* 	Group Capability Bitmap, 1 byte */
 		if (pwdinfo->persistent_supported)
 			p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 		else
@@ -1930,82 +1922,74 @@ u32 build_probe_resp_p2p_ie(struct wifid
 
 	}
 
-	//	Extended Listen Timing ATTR
-	//	Type:
+	/* 	Extended Listen Timing ATTR */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_EX_LISTEN_TIMING;
 
-	//	Length:
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0004);
+	/* 	Length: */
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0004);
 	p2pielen += 2;
 
-	//	Value:
-	//	Availability Period
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
+	/* 	Value: */
+	/* 	Availability Period */
 	RTW_PUT_LE16(p2pie + p2pielen, 0xFFFF);
 	p2pielen += 2;
 
-	//	Availability Interval
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0xFFFF);
+	/* 	Availability Interval */
 	RTW_PUT_LE16(p2pie + p2pielen, 0xFFFF);
 	p2pielen += 2;
 
 
-	// Notice of Absence ATTR
-	//	Type:
-	//	Length:
-	//	Value:
+	/*  Notice of Absence ATTR */
+	/* 	Type: */
+	/* 	Length: */
+	/* 	Value: */
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
-		//go_add_noa_attr(pwdinfo);
+		/* go_add_noa_attr(pwdinfo); */
 	}
 
-	//	Device Info ATTR
-	//	Type:
+	/* 	Device Info ATTR */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
-	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
+	/* 	Length: */
+	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
+	/* 	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 #ifdef CONFIG_INTEL_WIDI
 	if (_rtw_memcmp(pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false)
 	{
 		RTW_PUT_LE16(p2pie + p2pielen, 21 + 8 + pwdinfo->device_name_len);
 	}
 	else
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 	RTW_PUT_LE16(p2pie + p2pielen, 21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
-	//	P2P Device Address
+	/* 	Value: */
+	/* 	P2P Device Address */
 	memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
-	//	Config Method
-	//	This field should be big endian. Noted by P2P specification.
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->supported_wps_cm);
+	/* 	Config Method */
+	/* 	This field should be big endian. Noted by P2P specification. */
 	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->supported_wps_cm);
 	p2pielen += 2;
 
-	//	Primary Device Type
-	//	Category ID
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
+	/* 	Primary Device Type */
+	/* 	Category ID */
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
-	//	OUI
-	//*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
+	/* 	OUI */
 	RTW_PUT_BE32(p2pie + p2pielen, WPSOUI);
 	p2pielen += 4;
 
-	//	Sub Category ID
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
+	/* 	Sub Category ID */
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
-	//	Number of Secondary Device Types
+	/* 	Number of Secondary Device Types */
 #ifdef CONFIG_INTEL_WIDI
 	if (_rtw_memcmp(pwdinfo->padapter->mlmepriv.sa_ext, zero_array_check, L2SDTA_SERVICE_VE_LEN) == false)
 	{
@@ -2021,28 +2005,26 @@ u32 build_probe_resp_p2p_ie(struct wifid
 		p2pielen += 2;
 	}
 	else
-#endif //CONFIG_INTEL_WIDI
-	p2pie[ p2pielen++ ] = 0x00;	//	No Secondary Device Type List
+#endif /* CONFIG_INTEL_WIDI */
+	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
 
-	//	Device Name
-	//	Type:
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
+	/* 	Device Name */
+	/* 	Type: */
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
-	//	Length:
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
+	/* 	Length: */
 	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
-	// Group Info ATTR
-	//	Type:
-	//	Length:
-	//	Value:
+	/*  Group Info ATTR */
+	/* 	Type: */
+	/* 	Length: */
+	/* 	Value: */
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		p2pielen += go_add_group_info_attr(pwdinfo, p2pie + p2pielen);
@@ -2060,119 +2042,109 @@ u32 build_prov_disc_request_p2p_ie(struc
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
 	u32 len=0, p2pielen = 0;
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	//	Commented by Albert 20110301
-	//	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes
-	//	1. P2P Capability
-	//	2. Device Info
-	//	3. Group ID (When joining an operating P2P Group)
+	/* 	Commented by Albert 20110301 */
+	/* 	According to the P2P Specification, the provision discovery request frame should contain 3 P2P attributes */
+	/* 	1. P2P Capability */
+	/* 	2. Device Info */
+	/* 	3. Group ID (When joining an operating P2P Group) */
 
-	//	P2P Capability ATTR
-	//	Type:
+	/* 	P2P Capability ATTR */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_CAPABILITY;
 
-	//	Length:
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(0x0002);
+	/* 	Length: */
 	RTW_PUT_LE16(p2pie + p2pielen, 0x0002);
 	p2pielen += 2;
 
-	//	Value:
-	//	Device Capability Bitmap, 1 byte
+	/* 	Value: */
+	/* 	Device Capability Bitmap, 1 byte */
 	p2pie[ p2pielen++ ] = DMP_P2P_DEVCAP_SUPPORT;
 
-	//	Group Capability Bitmap, 1 byte
+	/* 	Group Capability Bitmap, 1 byte */
 	if (pwdinfo->persistent_supported)
 		p2pie[ p2pielen++ ] = P2P_GRPCAP_PERSISTENT_GROUP | DMP_P2P_GRPCAP_SUPPORT;
 	else
 		p2pie[ p2pielen++ ] = DMP_P2P_GRPCAP_SUPPORT;
 
 
-	//	Device Info ATTR
-	//	Type:
+	/* 	Device Info ATTR */
+	/* 	Type: */
 	p2pie[ p2pielen++ ] = P2P_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes)
-	//	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes)
-	//*(u16*) (p2pie + p2pielen) = cpu_to_le16(21 + pwdinfo->device_name_len);
+	/* 	Length: */
+	/* 	21 -> P2P Device Address (6bytes) + Config Methods (2bytes) + Primary Device Type (8bytes) */
+	/* 	+ NumofSecondDevType (1byte) + WPS Device Name ID field (2bytes) + WPS Device Name Len field (2bytes) */
 	RTW_PUT_LE16(p2pie + p2pielen, 21 + pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
-	//	P2P Device Address
+	/* 	Value: */
+	/* 	P2P Device Address */
 	memcpy(p2pie + p2pielen, pwdinfo->device_addr, ETH_ALEN);
 	p2pielen += ETH_ALEN;
 
-	//	Config Method
-	//	This field should be big endian. Noted by P2P specification.
+	/* 	Config Method */
+	/* 	This field should be big endian. Noted by P2P specification. */
 	if (pwdinfo->ui_got_wps_info == P2P_GOT_WPSINFO_PBC)
 	{
-		//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_PBC);
 		RTW_PUT_BE16(p2pie + p2pielen, WPS_CONFIG_METHOD_PBC);
 	}
 	else
 	{
-		//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_CONFIG_METHOD_DISPLAY);
 		RTW_PUT_BE16(p2pie + p2pielen, WPS_CONFIG_METHOD_DISPLAY);
 	}
 
 	p2pielen += 2;
 
-	//	Primary Device Type
-	//	Category ID
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_CID_MULIT_MEDIA);
+	/* 	Primary Device Type */
+	/* 	Category ID */
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_CID_MULIT_MEDIA);
 	p2pielen += 2;
 
-	//	OUI
-	//*(u32*) (p2pie + p2pielen) = cpu_to_be32(WPSOUI);
+	/* 	OUI */
 	RTW_PUT_BE32(p2pie + p2pielen, WPSOUI);
 	p2pielen += 4;
 
-	//	Sub Category ID
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_PDT_SCID_MEDIA_SERVER);
+	/* 	Sub Category ID */
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_PDT_SCID_MEDIA_SERVER);
 	p2pielen += 2;
 
-	//	Number of Secondary Device Types
-	p2pie[ p2pielen++ ] = 0x00;	//	No Secondary Device Type List
+	/* 	Number of Secondary Device Types */
+	p2pie[ p2pielen++ ] = 0x00;	/* 	No Secondary Device Type List */
 
-	//	Device Name
-	//	Type:
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(WPS_ATTR_DEVICE_NAME);
+	/* 	Device Name */
+	/* 	Type: */
 	RTW_PUT_BE16(p2pie + p2pielen, WPS_ATTR_DEVICE_NAME);
 	p2pielen += 2;
 
-	//	Length:
-	//*(u16*) (p2pie + p2pielen) = cpu_to_be16(pwdinfo->device_name_len);
+	/* 	Length: */
 	RTW_PUT_BE16(p2pie + p2pielen, pwdinfo->device_name_len);
 	p2pielen += 2;
 
-	//	Value:
+	/* 	Value: */
 	memcpy(p2pie + p2pielen, pwdinfo->device_name, pwdinfo->device_name_len);
 	p2pielen += pwdinfo->device_name_len;
 
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_CLIENT))
 	{
-		//	Added by Albert 2011/05/19
-		//	In this case, the pdev_raddr is the device address of the group owner.
+		/* 	Added by Albert 2011/05/19 */
+		/* 	In this case, the pdev_raddr is the device address of the group owner. */
 
-		//	P2P Group ID ATTR
-		//	Type:
+		/* 	P2P Group ID ATTR */
+		/* 	Type: */
 		p2pie[ p2pielen++ ] = P2P_ATTR_GROUP_ID;
 
-		//	Length:
-		//*(u16*) (p2pie + p2pielen) = cpu_to_le16(ETH_ALEN + ussidlen);
+		/* 	Length: */
 		RTW_PUT_LE16(p2pie + p2pielen, ETH_ALEN + ussidlen);
 		p2pielen += 2;
 
-		//	Value:
+		/* 	Value: */
 		memcpy(p2pie + p2pielen, pdev_raddr, ETH_ALEN);
 		p2pielen += ETH_ALEN;
 
@@ -2193,26 +2165,26 @@ u32 build_assoc_resp_p2p_ie(struct wifid
 	u8 p2pie[ MAX_P2P_IE_LEN] = { 0x00 };
 	u32 len=0, p2pielen = 0;
 
-	//	P2P OUI
+	/* 	P2P OUI */
 	p2pielen = 0;
 	p2pie[ p2pielen++ ] = 0x50;
 	p2pie[ p2pielen++ ] = 0x6F;
 	p2pie[ p2pielen++ ] = 0x9A;
-	p2pie[ p2pielen++ ] = 0x09;	//	WFA P2P v1.0
+	p2pie[ p2pielen++ ] = 0x09;	/* 	WFA P2P v1.0 */
 
-	// According to the P2P Specification, the Association response frame should contain 2 P2P attributes
-	//	1. Status
-	//	2. Extended Listen Timing (optional)
+	/*  According to the P2P Specification, the Association response frame should contain 2 P2P attributes */
+	/* 	1. Status */
+	/* 	2. Extended Listen Timing (optional) */
 
 
-	//	Status ATTR
+	/* 	Status ATTR */
 	p2pielen += rtw_set_p2p_attr_content(&p2pie[p2pielen], P2P_ATTR_STATUS, 1, &status_code);
 
 
-	// Extended Listen Timing ATTR
-	//	Type:
-	//	Length:
-	//	Value:
+	/*  Extended Listen Timing ATTR */
+	/* 	Type: */
+	/* 	Length: */
+	/* 	Value: */
 
 
 	pbuf = rtw_set_ie(pbuf, _VENDOR_SPECIFIC_IE_, p2pielen, (unsigned char *) p2pie, &len);
@@ -2255,39 +2227,39 @@ u32 process_probe_req_p2p_ie(struct wifi
 
 		if (g_rate == 0)
 		{
-			//	There is no OFDM rate included in SupportedRates IE of this probe request frame
-			//	The driver should response this probe request.
+			/* 	There is no OFDM rate included in SupportedRates IE of this probe request frame */
+			/* 	The driver should response this probe request. */
 			return ret;
 		}
 	}
 	else
 	{
-		//	rate_cnt > 4 means the SupportRates IE contains the OFDM rate because the count of CCK rates are 4.
-		//	We should proceed the following check for this probe request.
+		/* 	rate_cnt > 4 means the SupportRates IE contains the OFDM rate because the count of CCK rates are 4. */
+		/* 	We should proceed the following check for this probe request. */
 	}
 
-	//	Added comments by Albert 20100906
-	//	There are several items we should check here.
-	//	1. This probe request frame must contain the P2P IE. (Done)
-	//	2. This probe request frame must contain the wildcard SSID. (Done)
-	//	3. Wildcard BSSID. (Todo)
-	//	4. Destination Address. (Done in mgt_dispatcher function)
-	//	5. Requested Device Type in WSC IE. (Todo)
-	//	6. Device ID attribute in P2P IE. (Todo)
+	/* 	Added comments by Albert 20100906 */
+	/* 	There are several items we should check here. */
+	/* 	1. This probe request frame must contain the P2P IE. (Done) */
+	/* 	2. This probe request frame must contain the wildcard SSID. (Done) */
+	/* 	3. Wildcard BSSID. (Todo) */
+	/* 	4. Destination Address. (Done in mgt_dispatcher function) */
+	/* 	5. Requested Device Type in WSC IE. (Todo) */
+	/* 	6. Device ID attribute in P2P IE. (Todo) */
 
 	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&ssid_len,
 			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
 
-	ssid_len &= 0xff;	//	Just last 1 byte is valid for ssid len of the probe request
+	ssid_len &= 0xff;	/* 	Just last 1 byte is valid for ssid len of the probe request */
 	if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_DEVICE) || rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 	{
 		if ((p2pie=rtw_get_p2p_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_ , len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_ , NULL, &p2pielen)))
 		{
 			if ((p != NULL) && _rtw_memcmp((void *) (p+2), (void *) pwdinfo->p2p_wildcard_ssid , 7))
 			{
-				//todo:
-				//Check Requested Device Type attributes in WSC IE.
-				//Check Device ID attribute in P2P IE
+				/* todo: */
+				/* Check Requested Device Type attributes in WSC IE. */
+				/* Check Device ID attribute in P2P IE */
 
 				ret = true;
 			}
@@ -2298,7 +2270,7 @@ u32 process_probe_req_p2p_ie(struct wifi
 		}
 		else
 		{
-			//non -p2p device
+			/* non -p2p device */
 		}
 
 	}
@@ -2327,7 +2299,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 	{
 		ie_offset = _ASOCREQ_IE_OFFSET_;
 	}
-	else // WIFI_REASSOCREQ
+	else /*  WIFI_REASSOCREQ */
 	{
 		ie_offset = _REASOCREQ_IE_OFFSET_;
 	}
@@ -2349,7 +2321,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 	while (p2p_ie)
 	{
-		//Check P2P Capability ATTR
+		/* Check P2P Capability ATTR */
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*) &attr_contentlen))
 		{
 			DBG_8192D("[%s] Got P2P Capability Attr!!\n", __func__);
@@ -2357,10 +2329,10 @@ u32 process_assoc_req_p2p_ie(struct wifi
 			psta->dev_cap = cap_attr&0xff;
 		}
 
-		//Check Extended Listen Timing ATTR
+		/* Check Extended Listen Timing ATTR */
 
 
-		//Check P2P Device Info ATTR
+		/* Check P2P Device Info ATTR */
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO, NULL, (uint*)&attr_contentlen))
 		{
 			DBG_8192D("[%s] Got P2P DEVICE INFO Attr!!\n", __func__);
@@ -2373,11 +2345,11 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 				rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_DEVICE_INFO , pattr_content, (uint*)&attr_contentlen);
 
-				memcpy(psta->dev_addr,	pattr_content, ETH_ALEN);//P2P Device Address
+				memcpy(psta->dev_addr,	pattr_content, ETH_ALEN);/* P2P Device Address */
 
 				pattr_content += ETH_ALEN;
 
-				memcpy(&psta->config_methods, pattr_content, 2);//Config Methods
+				memcpy(&psta->config_methods, pattr_content, 2);/* Config Methods */
 				psta->config_methods = be16_to_cpu(psta->config_methods);
 
 				pattr_content += 2;
@@ -2407,7 +2379,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 				}
 
 
-				//dev_name_len = attr_contentlen - ETH_ALEN - 2 - 8 - 1 - (num_of_secdev_type*8);
+				/* dev_name_len = attr_contentlen - ETH_ALEN - 2 - 8 - 1 - (num_of_secdev_type*8); */
 				psta->dev_name_len=0;
 				if (WPS_ATTR_DEVICE_NAME == be16_to_cpu(*(u16*)pattr_content))
 				{
@@ -2424,7 +2396,7 @@ u32 process_assoc_req_p2p_ie(struct wifi
 
 		}
 
-		//Get the next P2P IE
+		/* Get the next P2P IE */
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
 
 	}
@@ -2467,7 +2439,7 @@ u32 process_p2p_devdisc_req(struct wifid
 					phead = &pstapriv->asoc_list;
 					plist = get_next(phead);
 
-					//look up sta asoc_queue
+					/* look up sta asoc_queue */
 					while ((rtw_end_of_queue_search(phead, plist)) == false)
 					{
 						psta = LIST_CONTAINOR(plist, struct sta_info, asoc_list);
@@ -2508,7 +2480,7 @@ u32 process_p2p_devdisc_req(struct wifid
 	}
 
 
-	//issue Device Discoverability Response
+	/* issue Device Discoverability Response */
 	issue_p2p_devdisc_resp(pwdinfo, GetAddr2Ptr(pframe), status, dialogToken);
 
 
@@ -2647,8 +2619,8 @@ u8 process_p2p_group_negotation_req(stru
 	u32	wfd_ielen = 0;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-#endif // CONFIG_TDLS
-#endif // CONFIG_WFD
+#endif /*  CONFIG_TDLS */
+#endif /*  CONFIG_WFD */
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter				*pbuddy_adapter = pwdinfo->padapter->pbuddy_adapter;
 	struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
@@ -2658,9 +2630,9 @@ u8 process_p2p_group_negotation_req(stru
 
 	if ((wpsie=rtw_get_wps_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &wps_ielen)))
 	{
-		//	Commented by Kurt 20120113
-		//	If some device wants to do p2p handshake without sending prov_disc_req
-		//	We have to get peer_req_cm from here.
+		/* 	Commented by Kurt 20120113 */
+		/* 	If some device wants to do p2p handshake without sending prov_disc_req */
+		/* 	We have to get peer_req_cm from here. */
 		if (_rtw_memcmp(pwdinfo->rx_prov_disc_info.strconfig_method_desc_of_prov_disc_req, "000", 3))
 		{
 			rtw_get_wps_attr_content(wpsie, wps_ielen, WPS_ATTR_DEVICE_PWID, (u8*) &wps_devicepassword_id, &wps_devicepassword_id_len);
@@ -2721,7 +2693,7 @@ u8 process_p2p_group_negotation_req(stru
 
 		rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_ING);
 
-		//Check P2P Capability ATTR
+		/* Check P2P Capability ATTR */
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen))
 		{
 			cap_attr = le16_to_cpu(cap_attr);
@@ -2729,17 +2701,17 @@ u8 process_p2p_group_negotation_req(stru
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
 				ptdlsinfo->ap_prohibited = true;
-#endif //defined(CONFIG_WFD) && defined(CONFIG_TDLS)
+#endif /* defined(CONFIG_WFD) && defined(CONFIG_TDLS) */
 		}
 
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT , &attr_content, &attr_contentlen))
 		{
 			DBG_8192D("[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01);
-			pwdinfo->peer_intent = attr_content;	//	include both intent and tie breaker values.
+			pwdinfo->peer_intent = attr_content;	/* 	include both intent and tie breaker values. */
 
 			if (pwdinfo->intent == (pwdinfo->peer_intent >> 1))
 			{
-				//	Try to match the tie breaker value
+				/* 	Try to match the tie breaker value */
 				if (pwdinfo->intent == P2P_MAX_INTENT)
 				{
 					rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
@@ -2768,7 +2740,7 @@ u8 process_p2p_group_negotation_req(stru
 
 			if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 			{
-				//	Store the group id information.
+				/* 	Store the group id information. */
 				memcpy(pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN);
 				memcpy(pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
 			}
@@ -2811,7 +2783,7 @@ u8 process_p2p_group_negotation_req(stru
 						break;
 					}
 					else
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 					{
 						u8 operatingch_info[5] = { 0x00 }, peer_operating_ch = 0;
 						attr_contentlen = 0;
@@ -2832,7 +2804,7 @@ u8 process_p2p_group_negotation_req(stru
 						}
 						else
 						{
-							// Take first channel of ch_list_inclusioned as operating channel
+							/*  Take first channel of ch_list_inclusioned as operating channel */
 							pwdinfo->operating_channel = ch_list_inclusioned[0];
 							DBG_8192D("[%s] Change op ch to %02x\n", __func__, pwdinfo->operating_channel);
 						}
@@ -2842,13 +2814,13 @@ u8 process_p2p_group_negotation_req(stru
 			}
 		}
 
-		//Get the next P2P IE
+		/* Get the next P2P IE */
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
 	}
 
 #ifdef CONFIG_WFD
-	//	Added by Albert 20110823
-	//	Try to get the TCP port information when receiving the negotiation request.
+	/* 	Added by Albert 20110823 */
+	/* 	Try to get the TCP port information when receiving the negotiation request. */
 	if (rtw_get_wfd_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen))
 	{
 		u8	attr_content[ 10 ] = { 0x00 };
@@ -2862,7 +2834,7 @@ u8 process_p2p_group_negotation_req(stru
 			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
 		}
 	}
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 	return(result);
 }
@@ -2880,13 +2852,13 @@ u8 process_p2p_group_negotation_resp(str
 	u32	wfd_ielen = 0;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-#endif // CONFIG_TDLS
-#endif // CONFIG_WFD
+#endif /*  CONFIG_TDLS */
+#endif /*  CONFIG_WFD */
 
 	ies = pframe + _PUBLIC_ACTION_IE_OFFSET_;
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
 
-	//	Be able to know which one is the P2P GO and which one is P2P client.
+	/* 	Be able to know which one is the P2P GO and which one is P2P client. */
 
 	if (rtw_get_wps_ie(ies, ies_len, NULL, &wps_ielen))
 	{
@@ -2919,16 +2891,16 @@ u8 process_p2p_group_negotation_resp(str
 		u8	ch_list_inclusioned[50] = { 0x00 };
 		u8	ch_num_inclusioned = 0;
 
-		while (p2p_ie)	//	Found the P2P IE.
+		while (p2p_ie)	/* 	Found the P2P IE. */
 		{
-			//Check P2P Capability ATTR
+			/* Check P2P Capability ATTR */
 			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CAPABILITY, (u8*)&cap_attr, (uint*)&attr_contentlen))
 			{
 				cap_attr = le16_to_cpu(cap_attr);
 #if defined(CONFIG_WFD) && defined(CONFIG_TDLS)
 			if (!(cap_attr & P2P_GRPCAP_INTRABSS))
 				ptdlsinfo->ap_prohibited = true;
-#endif //defined(CONFIG_WFD) && defined(CONFIG_TDLS)
+#endif /* defined(CONFIG_WFD) && defined(CONFIG_TDLS) */
 			}
 
 			rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_STATUS, &attr_content, &attr_contentlen);
@@ -2937,7 +2909,7 @@ u8 process_p2p_group_negotation_resp(str
 				DBG_8192D("[%s] Status = %d\n", __func__, attr_content);
 				if (attr_content == P2P_STATUS_SUCCESS)
 				{
-					//	Do nothing.
+					/* 	Do nothing. */
 				}
 				else
 				{
@@ -2952,7 +2924,7 @@ u8 process_p2p_group_negotation_resp(str
 				}
 			}
 
-			//	Try to get the peer's interface address
+			/* 	Try to get the peer's interface address */
 			attr_contentlen = 0;
 			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_INTENTED_IF_ADDR, pwdinfo->p2p_peer_interface_addr, &attr_contentlen))
 			{
@@ -2962,17 +2934,17 @@ u8 process_p2p_group_negotation_resp(str
 				}
 			}
 
-			//	Try to get the peer's intent and tie breaker value.
+			/* 	Try to get the peer's intent and tie breaker value. */
 			attr_content = 0x00;
 			attr_contentlen = 0;
 			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GO_INTENT , &attr_content, &attr_contentlen))
 			{
 				DBG_8192D("[%s] GO Intent = %d, tie = %d\n", __func__, attr_content >> 1, attr_content & 0x01);
-				pwdinfo->peer_intent = attr_content;	//	include both intent and tie breaker values.
+				pwdinfo->peer_intent = attr_content;	/* 	include both intent and tie breaker values. */
 
 				if (pwdinfo->intent == (pwdinfo->peer_intent >> 1))
 				{
-					//	Try to match the tie breaker value
+					/* 	Try to match the tie breaker value */
 					if (pwdinfo->intent == P2P_MAX_INTENT)
 					{
 						rtw_p2p_set_role(pwdinfo, P2P_ROLE_DEVICE);
@@ -3008,14 +2980,14 @@ u8 process_p2p_group_negotation_resp(str
 
 				if (rtw_p2p_chk_role(pwdinfo, P2P_ROLE_GO))
 				{
-					//	Store the group id information.
+					/* 	Store the group id information. */
 					memcpy(pwdinfo->groupid_info.go_device_addr, pwdinfo->device_addr, ETH_ALEN);
 					memcpy(pwdinfo->groupid_info.ssid, pwdinfo->nego_ssid, pwdinfo->nego_ssidlen);
 
 				}
 			}
 
-			//	Try to get the operation channel information
+			/* 	Try to get the operation channel information */
 
 			attr_contentlen = 0;
 			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, operatingch_info, &attr_contentlen))
@@ -3024,7 +2996,7 @@ u8 process_p2p_group_negotation_resp(str
 				pwdinfo->peer_operating_ch = operatingch_info[4];
 			}
 
-			//	Try to get the channel list information
+			/* 	Try to get the channel list information */
 			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, pwdinfo->channel_list_attr, &pwdinfo->channel_list_attr_len))
 			{
 				DBG_8192D("[%s] channel list attribute found, len = %d\n", __func__,  pwdinfo->channel_list_attr_len);
@@ -3054,7 +3026,7 @@ u8 process_p2p_group_negotation_resp(str
 							break;
 						}
 						else
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 						{
 							u8 operatingch_info[5] = { 0x00 }, peer_operating_ch = 0;
 							attr_contentlen = 0;
@@ -3075,7 +3047,7 @@ u8 process_p2p_group_negotation_resp(str
 							}
 							else
 							{
-								// Take first channel of ch_list_inclusioned as operating channel
+								/*  Take first channel of ch_list_inclusioned as operating channel */
 								pwdinfo->operating_channel = ch_list_inclusioned[0];
 								DBG_8192D("[%s] Change op ch to %02x\n", __func__, pwdinfo->operating_channel);
 							}
@@ -3090,7 +3062,7 @@ u8 process_p2p_group_negotation_resp(str
 				DBG_8192D("[%s] channel list attribute not found!\n", __func__);
 			}
 
-			//	Try to get the group id information if peer is GO
+			/* 	Try to get the group id information if peer is GO */
 			attr_contentlen = 0;
 			memset(groupid, 0x00, 38);
 			if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen))
@@ -3099,15 +3071,15 @@ u8 process_p2p_group_negotation_resp(str
 				memcpy(pwdinfo->groupid_info.ssid, &groupid[6], attr_contentlen - ETH_ALEN);
 			}
 
-			//Get the next P2P IE
+			/* Get the next P2P IE */
 			p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
 		}
 
 	}
 
 #ifdef CONFIG_WFD
-	//	Added by Albert 20111122
-	//	Try to get the TCP port information when receiving the negotiation response.
+	/* 	Added by Albert 20111122 */
+	/* 	Try to get the TCP port information when receiving the negotiation response. */
 	if (rtw_get_wfd_ie(pframe + _PUBLIC_ACTION_IE_OFFSET_, len - _PUBLIC_ACTION_IE_OFFSET_, wfd_ie, &wfd_ielen))
 	{
 		u8	attr_content[ 10 ] = { 0x00 };
@@ -3121,7 +3093,7 @@ u8 process_p2p_group_negotation_resp(str
 			DBG_8192D("[%s] Peer PORT NUM = %d\n", __func__, pwdinfo->wfd_info->peer_rtsp_ctrlport);
 		}
 	}
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 	return(result);
 }
@@ -3137,7 +3109,7 @@ u8 process_p2p_group_negotation_confirm(
 	ies_len = len - _PUBLIC_ACTION_IE_OFFSET_;
 
 	p2p_ie = rtw_get_p2p_ie(ies, ies_len, NULL, &p2p_ielen);
-	while (p2p_ie)	//	Found the P2P IE.
+	while (p2p_ie)	/* 	Found the P2P IE. */
 	{
 		u8	attr_content = 0x00, operatingch_info[5] = { 0x00 };
 		u8	groupid[ 38 ] = { 0x00 };
@@ -3156,8 +3128,8 @@ u8 process_p2p_group_negotation_confirm(
 
 				_cancel_timer(&pwdinfo->restore_p2p_state_timer, &bcancelled);
 
-				//	Commented by Albert 20100911
-				//	Todo: Need to handle the case which both Intents are the same.
+				/* 	Commented by Albert 20100911 */
+				/* 	Todo: Need to handle the case which both Intents are the same. */
 				rtw_p2p_set_state(pwdinfo, P2P_STATE_GONEGO_OK);
 				rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
 				if ((pwdinfo->intent) > (pwdinfo->peer_intent >> 1))
@@ -3170,7 +3142,7 @@ u8 process_p2p_group_negotation_confirm(
 				}
 				else
 				{
-					//	Have to compare the Tie Breaker
+					/* 	Have to compare the Tie Breaker */
 					if (pwdinfo->peer_intent & 0x01)
 					{
 						rtw_p2p_set_role(pwdinfo, P2P_ROLE_CLIENT);
@@ -3184,7 +3156,7 @@ u8 process_p2p_group_negotation_confirm(
 #ifdef CONFIG_CONCURRENT_MODE
 				if (check_buddy_fwstate(pwdinfo->padapter , _FW_LINKED))
 				{
-					//	Switch back to the AP channel soon.
+					/* 	Switch back to the AP channel soon. */
 					_set_timer(&pwdinfo->ap_p2p_switch_timer, 100);
 				}
 #endif
@@ -3197,7 +3169,7 @@ u8 process_p2p_group_negotation_confirm(
 			}
 		}
 
-		//	Try to get the group id information
+		/* 	Try to get the group id information */
 		attr_contentlen = 0;
 		memset(groupid, 0x00, 38);
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, groupid, &attr_contentlen))
@@ -3214,7 +3186,7 @@ u8 process_p2p_group_negotation_confirm(
 			pwdinfo->peer_operating_ch = operatingch_info[4];
 		}
 
-		//Get the next P2P IE
+		/* Get the next P2P IE */
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
 
 	}
@@ -3232,7 +3204,7 @@ u8 process_p2p_presence_req(struct wifid
 
 	dialogToken = frame_body[6];
 
-	//todo: check NoA attribute
+	/* todo: check NoA attribute */
 
 	issue_p2p_presence_resp(pwdinfo, GetAddr2Ptr(pframe), status, dialogToken);
 
@@ -3299,8 +3271,8 @@ _func_enter_;
 #ifdef CONFIG_CONCURRENT_MODE
 		p2p_concurrent_handler(padapter);
 #else
-		//	In the P2P client mode, the driver should not switch back to its listen channel
-		//	because this P2P client should stay at the operating channel of P2P GO.
+		/* 	In the P2P client mode, the driver should not switch back to its listen channel */
+		/* 	because this P2P client should stay at the operating channel of P2P GO. */
 		set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 #endif
 	}
@@ -3353,10 +3325,10 @@ _func_exit_;
 void p2p_concurrent_handler(struct rtw_adapter*	padapter)
 {
 	struct wifidirect_info	*pwdinfo = &padapter->wdinfo;
-	//_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
-	//struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
-	//struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv;
-	//struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv;
+	/* _adapter				*pbuddy_adapter = padapter->pbuddy_adapter; */
+	/* struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo; */
+	/* struct mlme_priv		*pbuddy_mlmepriv = &pbuddy_adapter->mlmepriv; */
+	/* struct mlme_ext_priv	*pbuddy_mlmeext = &pbuddy_adapter->mlmeextpriv; */
 	u8					val8;
 _func_enter_;
 
@@ -3374,18 +3346,18 @@ _func_enter_;
 
 		issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
 
-#else //CONFIG_IOCTL_CFG80211
+#else /* CONFIG_IOCTL_CFG80211 */
 		if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_IDLE))
 		{
-			//	Now, the driver stays on the AP's channel.
-			//	If the pwdinfo->ext_listen_period = 0, that means the P2P listen state is not available on listen channel.
+			/* 	Now, the driver stays on the AP's channel. */
+			/* 	If the pwdinfo->ext_listen_period = 0, that means the P2P listen state is not available on listen channel. */
 			if (pwdinfo->ext_listen_period > 0)
 			{
 				DBG_8192D("[%s] P2P_STATE_IDLE, ext_listen_period = %d\n", __func__, pwdinfo->ext_listen_period);
 
 				if (pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel)
 				{
-					//	Will switch to listen channel so that need to send the NULL data with PW bit to AP.
+					/* 	Will switch to listen channel so that need to send the NULL data with PW bit to AP. */
 					issue_nulldata(pbuddy_adapter, NULL, 1, 3, 500);
 					set_channel_bwmode(padapter, pwdinfo->listen_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
 				}
@@ -3394,7 +3366,7 @@ _func_enter_;
 				val8 = 1;
 				rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 
-				//	Todo: To check the value of pwdinfo->ext_listen_period is equal to 0 or not.
+				/* 	Todo: To check the value of pwdinfo->ext_listen_period is equal to 0 or not. */
 				_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_period);
 			}
 		}
@@ -3403,13 +3375,13 @@ _func_enter_;
 				(rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING) && pwdinfo->nego_req_info.benable == false) ||
 				rtw_p2p_chk_state(pwdinfo, P2P_STATE_RX_PROVISION_DIS_REQ))
 		{
-			//	Now, the driver is in the listen state of P2P mode.
+			/* 	Now, the driver is in the listen state of P2P mode. */
 			DBG_8192D("[%s] P2P_STATE_IDLE, ext_listen_interval = %d\n", __func__, pwdinfo->ext_listen_interval);
 
-			//	Commented by Albert 2012/11/01
-			//	If the AP's channel is the same as the listen channel, we should still be in the listen state
-			//	Other P2P device is still able to find this device out even this device is in the AP's channel.
-			//	So, configure this device to be able to receive the probe request frame and set it to listen state.
+			/* 	Commented by Albert 2012/11/01 */
+			/* 	If the AP's channel is the same as the listen channel, we should still be in the listen state */
+			/* 	Other P2P device is still able to find this device out even this device is in the AP's channel. */
+			/* 	So, configure this device to be able to receive the probe request frame and set it to listen state. */
 			if (pbuddy_mlmeext->cur_channel != pwdinfo->listen_channel)
 			{
 				set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
@@ -3419,12 +3391,12 @@ _func_enter_;
 				issue_nulldata(pbuddy_adapter, NULL, 0, 3, 500);
 			}
 
-			//	Todo: To check the value of pwdinfo->ext_listen_interval is equal to 0 or not.
+			/* 	Todo: To check the value of pwdinfo->ext_listen_interval is equal to 0 or not. */
 			_set_timer(&pwdinfo->ap_p2p_switch_timer, pwdinfo->ext_listen_interval);
 		}
 		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_OK))
 		{
-			//	The driver had finished the P2P handshake successfully.
+			/* 	The driver had finished the P2P handshake successfully. */
 			val8 = 0;
 			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
 			set_channel_bwmode(padapter, pbuddy_mlmeext->cur_channel, pbuddy_mlmeext->cur_ch_offset, pbuddy_mlmeext->cur_bwmode);
@@ -3448,15 +3420,8 @@ _func_enter_;
 		}
 		else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ) && pwdinfo->invitereq_info.benable == true)
 		{
-			/*
-			val8 = 1;
-			set_channel_bwmode(padapter, , HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);
-			rtw_hal_set_hwreg(padapter, HW_VAR_MLME_SITESURVEY, (u8 *)(&val8));
-			issue_probereq_p2p(padapter, NULL);
-			_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
-			*/
 		}
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 	}
 	else
 	{
@@ -3490,7 +3455,7 @@ _func_enter_;
 			pmlmeext->cur_channel = pbuddy_mlmeext->cur_channel;
 
 		} else
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 		if (pcfg80211_wdinfo->restore_channel != pmlmeext->cur_channel)
 		{
 			if (!check_fwstate(&padapter->mlmepriv, _FW_LINKED))
@@ -3522,7 +3487,7 @@ static void ro_ch_timer_process (void *F
 	struct rtw_adapter *adapter = (struct rtw_adapter *)FunctionContext;
 	struct rtw_wdev_priv *pwdev_priv = wdev_to_priv(adapter->rtw_wdev);
 
-	//printk("%s\n", __func__);
+	/* printk("%s\n", __func__); */
 
 #ifdef	CONFIG_CONCURRENT_MODE
 	ATOMIC_SET(&pwdev_priv->ro_ch_to, 1);
@@ -3549,7 +3514,7 @@ static void rtw_cfg80211_adjust_p2pie_ch
 		u32	attr_contentlen = 0;
 		u8 *pattr = NULL;
 
-		//Check P2P_ATTR_CH_LIST
+		/* Check P2P_ATTR_CH_LIST */
 		if ((pattr=rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_CH_LIST, NULL, (uint*)&attr_contentlen))!=NULL)
 		{
 			int i;
@@ -3563,22 +3528,22 @@ static void rtw_cfg80211_adjust_p2pie_ch
 				num_of_ch = *(pattr_temp+1);
 
 				for (i=0; i<num_of_ch; i++)
-					*(pattr_temp+2+i) = pbuddy_mlmeext->cur_channel;//forcing to the same channel
+					*(pattr_temp+2+i) = pbuddy_mlmeext->cur_channel;/* forcing to the same channel */
 
 				pattr_temp += (2+num_of_ch);
 				attr_contentlen -= (2+num_of_ch);
 			}
 		}
 
-		//Check P2P_ATTR_OPERATING_CH
+		/* Check P2P_ATTR_OPERATING_CH */
 		attr_contentlen = 0;
 		pattr = NULL;
 		if ((pattr = rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_OPERATING_CH, NULL, (uint*)&attr_contentlen))!=NULL)
 		{
-			*(pattr+4) = pbuddy_mlmeext->cur_channel;//forcing to the same channel
+			*(pattr+4) = pbuddy_mlmeext->cur_channel;/* forcing to the same channel */
 		}
 
-		//Get the next P2P IE
+		/* Get the next P2P IE */
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
 
 	}
@@ -3606,7 +3571,7 @@ void rtw_append_wfd_ie(struct rtw_adapte
 		{
 			OUI_Subtype = frame_body[6];
 			dialogToken = frame_body[7];
-			switch (OUI_Subtype)//OUI Subtype
+			switch (OUI_Subtype)/* OUI Subtype */
 			{
 				case P2P_GO_NEGO_REQ:
 				{
@@ -3696,7 +3661,7 @@ void rtw_append_wfd_ie(struct rtw_adapte
 	else
 	{
 		DBG_8192D("%s, action frame category=%d\n", __func__, category);
-		//is_p2p_frame = (-1);
+		/* is_p2p_frame = (-1); */
 	}
 
 	return;
@@ -3714,7 +3679,7 @@ int rtw_p2p_check_frames(struct rtw_adap
 
 	frame_body = (unsigned char *)(buf + sizeof(struct rtw_ieee80211_hdr_3addr));
 	category = frame_body[0];
-	//just for check
+	/* just for check */
 	if (category == RTW_WLAN_CATEGORY_PUBLIC)
 	{
 		action = frame_body[1];
@@ -3735,7 +3700,7 @@ int rtw_p2p_check_frames(struct rtw_adap
 				len-sizeof(struct rtw_ieee80211_hdr_3addr)-_PUBLIC_ACTION_IE_OFFSET_,
 				NULL, &p2p_ielen);
 
-			switch (OUI_Subtype)//OUI Subtype
+			switch (OUI_Subtype)/* OUI Subtype */
 			{
 				u8 *cont;
 				uint cont_len;
@@ -3744,14 +3709,14 @@ int rtw_p2p_check_frames(struct rtw_adap
 
 					if (tx)
 					{
-#ifdef CONFIG_DRV_ISSUE_PROV_REQ // IOT FOR S2
+#ifdef CONFIG_DRV_ISSUE_PROV_REQ /*  IOT FOR S2 */
 						if (pwdev_priv->provdisc_req_issued == false)
 						{
 							rtw_cfg80211_issue_p2p_provision_request(padapter, buf, len);
 							pwdev_priv->provdisc_req_issued = true;
 							rtw_msleep_os(200);
 						}
-#endif //CONFIG_DRV_ISSUE_PROV_REQ
+#endif /* CONFIG_DRV_ISSUE_PROV_REQ */
 
 #ifdef CONFIG_CONCURRENT_MODE
 						if (check_buddy_fwstate(padapter, _FW_LINKED))
@@ -3867,12 +3832,12 @@ int rtw_p2p_check_frames(struct rtw_adap
 
 					if ((p2p_ie=rtw_get_p2p_ie(frame_body + _PUBLIC_ACTION_IE_OFFSET_, frame_body_len - _PUBLIC_ACTION_IE_OFFSET_, NULL, &p2p_ielen))) {
 						if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_GROUP_ID, NULL, &contentlen)) {
-							pwdev_priv->provdisc_req_issued = false;//case: p2p_client join p2p GO
+							pwdev_priv->provdisc_req_issued = false;/* case: p2p_client join p2p GO */
 						} else {
 							#ifdef CONFIG_DEBUG_CFG80211
 							DBG_8192D("provdisc_req_issued is true\n");
-							#endif //CONFIG_DEBUG_CFG80211
-							pwdev_priv->provdisc_req_issued = true;//case: p2p_devices connection before Nego req.
+							#endif /* CONFIG_DEBUG_CFG80211 */
+							pwdev_priv->provdisc_req_issued = true;/* case: p2p_devices connection before Nego req. */
 						}
 					}
 				}
@@ -3920,7 +3885,7 @@ int rtw_p2p_check_frames(struct rtw_adap
 	else
 	{
 		DBG_8192D("RTW_%s:action frame category=%d\n", (tx==true)?"TX":"RX", category);
-		//is_p2p_frame = (-1);
+		/* is_p2p_frame = (-1); */
 	}
 
 	return is_p2p_frame;
@@ -3934,7 +3899,7 @@ void rtw_init_cfg80211_wifidirect_info(s
 
 	_init_timer(&pcfg80211_wdinfo->remain_on_ch_timer, padapter->pnetdev, ro_ch_timer_process, padapter);
 }
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 void p2p_protocol_wk_hdl(struct rtw_adapter *padapter, int intCmdType)
 {
@@ -4017,7 +3982,7 @@ _func_enter_;
 			ro_ch_handler(padapter);
 			break;
 		}
-#endif //CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 
 	}
 
@@ -4031,7 +3996,7 @@ void process_p2p_ps_ie(struct rtw_adapte
 	u32 ies_len;
 	u8 * p2p_ie;
 	u32	p2p_ielen = 0;
-	u8	noa_attr[MAX_P2P_IE_LEN] = { 0x00 };// NoA length should be n*(13) + 2
+	u8	noa_attr[MAX_P2P_IE_LEN] = { 0x00 };/*  NoA length should be n*(13) + 2 */
 	u32	attr_contentlen = 0;
 
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
@@ -4060,14 +4025,14 @@ _func_enter_;
 	while (p2p_ie)
 	{
 		find_p2p = true;
-		// Get Notice of Absence IE.
+		/*  Get Notice of Absence IE. */
 		if (rtw_get_p2p_attr_content(p2p_ie, p2p_ielen, P2P_ATTR_NOA, noa_attr, &attr_contentlen))
 		{
 			find_p2p_ps = true;
 			noa_index = noa_attr[0];
 
 			if ((pwdinfo->p2p_ps_mode == P2P_PS_NONE) ||
-				(noa_index != pwdinfo->noa_index))// if index change, driver should reconfigure related setting.
+				(noa_index != pwdinfo->noa_index))/*  if index change, driver should reconfigure related setting. */
 			{
 				pwdinfo->noa_index = noa_index;
 				pwdinfo->opp_ps = noa_attr[1] >> 7;
@@ -4075,12 +4040,12 @@ _func_enter_;
 
 				noa_offset = 2;
 				noa_num = 0;
-				// NoA length should be n*(13) + 2
+				/*  NoA length should be n*(13) + 2 */
 				if (attr_contentlen > 2)
 				{
 					while (noa_offset < attr_contentlen)
 					{
-						//memcpy(&wifidirect_info->noa_count[noa_num], &noa_attr[noa_offset], 1);
+						/* memcpy(&wifidirect_info->noa_count[noa_num], &noa_attr[noa_offset], 1); */
 						pwdinfo->noa_count[noa_num] = noa_attr[noa_offset];
 						noa_offset += 1;
 
@@ -4101,7 +4066,7 @@ _func_enter_;
 				if (pwdinfo->opp_ps == 1)
 				{
 					pwdinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
-					// driver should wait LPS for entering CTWindow
+					/*  driver should wait LPS for entering CTWindow */
 					if (padapter->pwrctrlpriv.bFwCurrentInPSMode == true)
 					{
 						p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 1);
@@ -4118,10 +4083,10 @@ _func_enter_;
 				}
 			}
 
-			break; // find target, just break.
+			break; /*  find target, just break. */
 		}
 
-		//Get the next P2P IE
+		/* Get the next P2P IE */
 		p2p_ie = rtw_get_p2p_ie(p2p_ie+p2p_ielen, ies_len -(p2p_ie -ies + p2p_ielen), NULL, &p2p_ielen);
 
 	}
@@ -4249,7 +4214,7 @@ _func_exit_;
 
 	return res;
 }
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 
 static void reset_ch_sitesurvey_timer_process (void *FunctionContext)
 {
@@ -4260,7 +4225,7 @@ static void reset_ch_sitesurvey_timer_pr
 		return;
 
 	DBG_8192D("[%s] In\n", __func__);
-	//	Reset the operation channel information
+	/* 	Reset the operation channel information */
 	pwdinfo->rx_invitereq_info.operation_ch[0] = 0;
 	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
 }
@@ -4274,7 +4239,7 @@ static void reset_ch_sitesurvey_timer_pr
 		return;
 
 	DBG_8192D("[%s] In\n", __func__);
-	//	Reset the operation channel information
+	/* 	Reset the operation channel information */
 	pwdinfo->p2p_info.operation_ch[0] = 0;
 	pwdinfo->p2p_info.scan_op_ch_only = 0;
 }
@@ -4302,16 +4267,16 @@ static void pre_tx_scan_timer_process (v
 
 	spin_lock_bh(&pmlmepriv->lock);
 
-	//	Commented by Albert 20110805
-	//	Todo: Use the issuing probe request directly instead of using the rtw_sitesurvey_cmd!!
+	/* 	Commented by Albert 20110805 */
+	/* 	Todo: Use the issuing probe request directly instead of using the rtw_sitesurvey_cmd!! */
 
 	if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_PROVISION_DIS_REQ))
 	{
-		if (true == pwdinfo->tx_prov_disc_info.benable)	//	the provision discovery request frame is trigger to send or not
+		if (true == pwdinfo->tx_prov_disc_info.benable)	/* 	the provision discovery request frame is trigger to send or not */
 		{
 			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_PROVDISC_PROCESS_WK);
-			//issue_probereq_p2p(adapter, NULL);
-			//_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
+			/* issue_probereq_p2p(adapter, NULL); */
+			/* _set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT); */
 		}
 	}
 	else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_GONEGO_ING))
@@ -4319,8 +4284,8 @@ static void pre_tx_scan_timer_process (v
 		if (true == pwdinfo->nego_req_info.benable)
 		{
 			p2p_protocol_wk_cmd(adapter, P2P_PRE_TX_NEGOREQ_PROCESS_WK);
-			//issue_probereq_p2p(adapter, NULL);
-			//_set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT);
+			/* issue_probereq_p2p(adapter, NULL); */
+			/* _set_timer(&pwdinfo->pre_tx_scan_timer, P2P_TX_PRESCAN_TIMEOUT); */
 		}
 	}
 	else if (rtw_p2p_chk_state(pwdinfo, P2P_STATE_TX_INVITE_REQ))
@@ -4388,23 +4353,23 @@ int rtw_init_wifi_display_info(struct rt
 	int	res = _SUCCESS;
 	struct wifi_display_info *pwfd_info = &padapter->wfd_info;
 
-	// Used in P2P and TDLS
+	/*  Used in P2P and TDLS */
 	pwfd_info->rtsp_ctrlport = 554;
-	pwfd_info->peer_rtsp_ctrlport = 0;	//	Reset to 0
+	pwfd_info->peer_rtsp_ctrlport = 0;	/* 	Reset to 0 */
 	pwfd_info->wfd_enable = false;
 	pwfd_info->wfd_device_type = WFD_DEVINFO_PSINK;
 	pwfd_info->scan_result_type = SCAN_RESULT_P2P_ONLY;
 
-	// Used in P2P
+	/*  Used in P2P */
 	pwfd_info->peer_session_avail = true;
 	pwfd_info->wfd_pc = false;
 
-	// Used in TDLS
+	/*  Used in TDLS */
 	memset(pwfd_info->ip_address, 0x00, 4);
 	memset(pwfd_info->peer_ip_address, 0x00, 4);
 	return res;
 }
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 void rtw_init_wifidirect_timers(struct rtw_adapter* padapter)
 {
@@ -4425,7 +4390,6 @@ void rtw_init_wifidirect_addrs(struct rt
 #ifdef CONFIG_P2P
 	struct wifidirect_info *pwdinfo = &padapter->wdinfo;
 
-	/*init device&interface address */
 	if (dev_addr) {
 		memcpy(pwdinfo->device_addr, dev_addr, ETH_ALEN);
 	}
@@ -4452,11 +4416,11 @@ void init_wifidirect_info(struct rtw_ada
 
 	pwdinfo->padapter = padapter;
 
-	//	1, 6, 11 are the social channel defined in the WiFi Direct specification.
+	/* 	1, 6, 11 are the social channel defined in the WiFi Direct specification. */
 	pwdinfo->social_chan[0] = 1;
 	pwdinfo->social_chan[1] = 6;
 	pwdinfo->social_chan[2] = 11;
-	pwdinfo->social_chan[3] = 0;	//	channel 0 for scanning ending in site survey function.
+	pwdinfo->social_chan[3] = 0;	/* 	channel 0 for scanning ending in site survey function. */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (pbuddy_adapter) {
@@ -4469,14 +4433,14 @@ void init_wifidirect_info(struct rtw_ada
 	      ((pbuddy_mlmeext->cur_channel == 1) || (pbuddy_mlmeext->cur_channel == 6) || (pbuddy_mlmeext->cur_channel == 11))
 	  )
 	{
-		//	Use the AP's channel as the listen channel
-		//	This will avoid the channel switch between AP's channel and listen channel.
+		/* 	Use the AP's channel as the listen channel */
+		/* 	This will avoid the channel switch between AP's channel and listen channel. */
 		pwdinfo->listen_channel = pbuddy_mlmeext->cur_channel;
 	}
 	else
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 	{
-		//	Use the channel 11 as the listen channel
+		/* 	Use the channel 11 as the listen channel */
 		pwdinfo->listen_channel = 11;
 	}
 
@@ -4511,15 +4475,15 @@ void init_wifidirect_info(struct rtw_ada
 		rtw_p2p_set_pre_state(pwdinfo, P2P_STATE_GONEGO_OK);
 	}
 
-//	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54)
-	pwdinfo->support_rate[0] = 0x8c;	//	6(B)
-	pwdinfo->support_rate[1] = 0x92;	//	9(B)
-	pwdinfo->support_rate[2] = 0x18;	//	12
-	pwdinfo->support_rate[3] = 0x24;	//	18
-	pwdinfo->support_rate[4] = 0x30;	//	24
-	pwdinfo->support_rate[5] = 0x48;	//	36
-	pwdinfo->support_rate[6] = 0x60;	//	48
-	pwdinfo->support_rate[7] = 0x6c;	//	54
+/* 	Use the OFDM rate in the P2P probe response frame. (6(B), 9(B), 12, 18, 24, 36, 48, 54) */
+	pwdinfo->support_rate[0] = 0x8c;	/* 	6(B) */
+	pwdinfo->support_rate[1] = 0x92;	/* 	9(B) */
+	pwdinfo->support_rate[2] = 0x18;	/* 	12 */
+	pwdinfo->support_rate[3] = 0x24;	/* 	18 */
+	pwdinfo->support_rate[4] = 0x30;	/* 	24 */
+	pwdinfo->support_rate[5] = 0x48;	/* 	36 */
+	pwdinfo->support_rate[6] = 0x60;	/* 	48 */
+	pwdinfo->support_rate[7] = 0x6c;	/* 	54 */
 
 	memcpy((void*) pwdinfo->p2p_wildcard_ssid, "DIRECT-", 7);
 
@@ -4527,7 +4491,7 @@ void init_wifidirect_info(struct rtw_ada
 	pwdinfo->device_name_len = 0;
 
 	memset(&pwdinfo->invitereq_info, 0x00, sizeof(struct tx_invite_req_info));
-	pwdinfo->invitereq_info.token = 3;	//	Token used for P2P invitation request frame.
+	pwdinfo->invitereq_info.token = 3;	/* 	Token used for P2P invitation request frame. */
 
 	memset(&pwdinfo->inviteresp_info, 0x00, sizeof(struct tx_invite_resp_info));
 	pwdinfo->inviteresp_info.token = 0;
@@ -4538,7 +4502,7 @@ void init_wifidirect_info(struct rtw_ada
 	rtw_p2p_findphase_ex_set(pwdinfo, P2P_FINDPHASE_EX_NONE);
 
 	pwdinfo->listen_dwell = (u8) ((rtw_get_current_time() % 3) + 1);
-	//DBG_8192D("[%s] listen_dwell time is %d00ms\n", __func__, pwdinfo->listen_dwell);
+	/* DBG_8192D("[%s] listen_dwell time is %d00ms\n", __func__, pwdinfo->listen_dwell); */
 
 	memset(&pwdinfo->tx_prov_disc_info, 0x00, sizeof(struct tx_provdisc_req_info));
 	pwdinfo->tx_prov_disc_info.wps_config_method_request = WPS_CM_NONE;
@@ -4557,7 +4521,7 @@ void init_wifidirect_info(struct rtw_ada
 	pwdinfo->wfd_info = pwfd_info;
 #else
 	pwdinfo->supported_wps_cm = WPS_CONFIG_METHOD_DISPLAY | WPS_CONFIG_METHOD_PBC | WPS_CONFIG_METHOD_KEYPAD;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 	pwdinfo->channel_list_attr_len = 0;
 	memset(pwdinfo->channel_list_attr, 0x00, 100);
 
@@ -4566,24 +4530,24 @@ void init_wifidirect_info(struct rtw_ada
 	memset(&pwdinfo->groupid_info, 0x00, sizeof(struct group_id_info));
 #ifdef CONFIG_CONCURRENT_MODE
 #ifdef CONFIG_IOCTL_CFG80211
-	pwdinfo->ext_listen_interval = 1000; //The interval to be available with legacy AP during p2p0-find/scan
-	pwdinfo->ext_listen_period = 3000; //The time period to be available for P2P during nego
-#else //!CONFIG_IOCTL_CFG80211
-	//pwdinfo->ext_listen_interval = 3000;
-	//pwdinfo->ext_listen_period = 400;
+	pwdinfo->ext_listen_interval = 1000; /* The interval to be available with legacy AP during p2p0-find/scan */
+	pwdinfo->ext_listen_period = 3000; /* The time period to be available for P2P during nego */
+#else /* CONFIG_IOCTL_CFG80211 */
+	/* pwdinfo->ext_listen_interval = 3000; */
+	/* pwdinfo->ext_listen_period = 400; */
 	pwdinfo->ext_listen_interval = 1000;
 	pwdinfo->ext_listen_period = 1000;
-#endif //!CONFIG_IOCTL_CFG80211
+#endif /* CONFIG_IOCTL_CFG80211 */
 #endif
 	pwdinfo->wfd_tdls_enable = 0;
 	memset(pwdinfo->p2p_peer_interface_addr, 0x00, ETH_ALEN);
 	memset(pwdinfo->p2p_peer_device_addr, 0x00, ETH_ALEN);
 
 	pwdinfo->rx_invitereq_info.operation_ch[0] = 0;
-	pwdinfo->rx_invitereq_info.operation_ch[1] = 0;	//	Used to indicate the scan end in site survey function
+	pwdinfo->rx_invitereq_info.operation_ch[1] = 0;	/* 	Used to indicate the scan end in site survey function */
 	pwdinfo->rx_invitereq_info.scan_op_ch_only = 0;
 	pwdinfo->p2p_info.operation_ch[0] = 0;
-	pwdinfo->p2p_info.operation_ch[1] = 0;			//	Used to indicate the scan end in site survey function
+	pwdinfo->p2p_info.operation_ch[1] = 0;			/* 	Used to indicate the scan end in site survey function */
 	pwdinfo->p2p_info.scan_op_ch_only = 0;
 }
 
@@ -4658,7 +4622,7 @@ void dbg_rtw_p2p_set_role(struct wifidir
 		);
 	}
 }
-#endif //CONFIG_DBG_P2P
+#endif /* CONFIG_DBG_P2P */
 
 
 int rtw_p2p_enable(struct rtw_adapter *padapter, enum P2P_ROLE role)
@@ -4675,29 +4639,29 @@ int rtw_p2p_enable(struct rtw_adapter *p
 #ifdef CONFIG_CONCURRENT_MODE
 		struct rtw_adapter				*pbuddy_adapter = padapter->pbuddy_adapter;
 		struct wifidirect_info	*pbuddy_wdinfo = &pbuddy_adapter->wdinfo;
-		//	Commented by Albert 2011/12/30
-		//	The driver just supports 1 P2P group operation.
-		//	So, this function will do nothing if the buddy adapter had enabled the P2P function.
+		/* 	Commented by Albert 2011/12/30 */
+		/* 	The driver just supports 1 P2P group operation. */
+		/* 	So, this function will do nothing if the buddy adapter had enabled the P2P function. */
 		if (!rtw_p2p_chk_state(pbuddy_wdinfo, P2P_STATE_NONE))
 		{
-			//	The buddy adapter had enabled the P2P function.
+			/* 	The buddy adapter had enabled the P2P function. */
 			return ret;
 		}
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
-		//leave IPS/Autosuspend
+		/* leave IPS/Autosuspend */
 		if (_FAIL == rtw_pwr_wakeup(padapter)) {
 			ret = _FAIL;
 			goto exit;
 		}
 
 
-		//	Added by Albert 2011/03/22
-		//	In the P2P mode, the driver should not support the b mode.
-		//	So, the Tx packet shouldn't use the CCK rate
+		/* 	Added by Albert 2011/03/22 */
+		/* 	In the P2P mode, the driver should not support the b mode. */
+		/* 	So, the Tx packet shouldn't use the CCK rate */
 		update_tx_basic_rate(padapter, WIRELESS_11AGN);
 
-		//Enable P2P function
+		/* Enable P2P function */
 		init_wifidirect_info(padapter, role);
 	}
 	else if (role == P2P_ROLE_DISABLE)
@@ -4707,7 +4671,7 @@ int rtw_p2p_enable(struct rtw_adapter *p
 			goto exit;
 		}
 
-		//Disable P2P function
+		/* Disable P2P function */
 		if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		{
 			_cancel_timer_ex(&pwdinfo->find_phase_timer);
@@ -4725,7 +4689,7 @@ int rtw_p2p_enable(struct rtw_adapter *p
 			memset(&pwdinfo->rx_prov_disc_info, 0x00, sizeof(struct rx_provdisc_req_info));
 		}
 
-		//Restore to initial setting.
+		/* Restore to initial setting. */
 		update_tx_basic_rate(padapter, padapter->registrypriv.wireless_mode);
 	}
 
@@ -4733,4 +4697,4 @@ exit:
 	return ret;
 }
 
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
--- a/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
+++ b/drivers/staging/rtl8192du/core/rtw_pwrctrl.c
@@ -35,7 +35,7 @@ void ips_enter(struct rtw_adapter * pada
 
 	pwrpriv->bips_processing = true;
 
-	// syn ips_mode with request
+	/*  syn ips_mode with request */
 	pwrpriv->ips_mode = pwrpriv->ips_mode_req;
 
 	pwrpriv->ips_enter_cnts++;
@@ -124,7 +124,7 @@ bool rtw_pwr_unassociated_idle(struct rt
 	bool ret = false;
 
 	if (adapter->pwrctrlpriv.ips_deny_time >= rtw_get_current_time()) {
-		//DBG_8192D("%s ips_deny_time\n", __func__);
+		/* DBG_8192D("%s ips_deny_time\n", __func__); */
 		goto exit;
 	}
 
@@ -174,12 +174,12 @@ void rtw_ps_processor(struct rtw_adapter
 {
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 #ifdef SUPPORT_HW_RFOFF_DETECTED
 	rt_rf_power_state rfpwrstate;
-#endif //SUPPORT_HW_RFOFF_DETECTED
+#endif /* SUPPORT_HW_RFOFF_DETECTED */
 
 	pwrpriv->ps_processing = true;
 
@@ -187,7 +187,7 @@ void rtw_ps_processor(struct rtw_adapter
 	if (pwrpriv->bips_processing == true)
 		goto exit;
 
-	//DBG_8192D("==> fw report state(0x%x)\n",rtw_read8(padapter,0x1ca));
+	/* DBG_8192D("==> fw report state(0x%x)\n",rtw_read8(padapter,0x1ca)); */
 	if (padapter->pwrctrlpriv.bHWPwrPindetect)
 	{
 	#ifdef CONFIG_AUTOSUSPEND
@@ -215,7 +215,7 @@ void rtw_ps_processor(struct rtw_adapter
 			}
 		}
 		else
-	#endif //CONFIG_AUTOSUSPEND
+	#endif /* CONFIG_AUTOSUSPEND */
 		{
 			rfpwrstate = RfOnOffDetect(padapter);
 			DBG_8192D("@@@@- #2  %s==> rfstate:%s\n",__func__,(rfpwrstate==rf_on)?"rf_on":"rf_off");
@@ -239,7 +239,7 @@ void rtw_ps_processor(struct rtw_adapter
 		}
 		pwrpriv->pwr_state_check_cnts ++;
 	}
-#endif //SUPPORT_HW_RFOFF_DETECTED
+#endif /* SUPPORT_HW_RFOFF_DETECTED */
 
 	if (pwrpriv->ips_mode_req == IPS_NONE
 		#ifdef CONFIG_CONCURRENT_MODE
@@ -272,7 +272,7 @@ void rtw_ps_processor(struct rtw_adapter
 		{
 		}
 		else
-		#endif //CONFIG_AUTOSUSPEND
+		#endif /* CONFIG_AUTOSUSPEND */
 		{
 			#ifdef CONFIG_IPS
 			ips_enter(padapter);
@@ -385,13 +385,13 @@ void rtw_set_ps_mode(struct rtw_adapter
 	struct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;
 #ifdef CONFIG_P2P
 	struct wifidirect_info	*pwdinfo = &(padapter->wdinfo);
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 #ifdef CONFIG_TDLS
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	int i, j;
 	_list	*plist, *phead;
 	struct sta_info *ptdls_sta;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 _func_enter_;
 
@@ -409,12 +409,12 @@ _func_enter_;
 		return;
 	}
 
-	//if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+	/* if (pwrpriv->pwr_mode == PS_MODE_ACTIVE) */
 	if (ps_mode == PS_MODE_ACTIVE)
 	{
 #ifdef CONFIG_P2P_PS
 		if (pwdinfo->opp_ps == 0)
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 		{
 #ifdef CONFIG_LPS_LCLK
 			_enter_pwrlock(&pwrpriv->lock);
@@ -439,7 +439,7 @@ _func_enter_;
 			}
 
 			spin_unlock_bh(&pstapriv->sta_hash_lock);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 			pwrpriv->smart_ps = smart_ps;
 			pwrpriv->pwr_mode = ps_mode;
@@ -493,17 +493,17 @@ _func_enter_;
 			}
 
 			spin_unlock_bh(&pstapriv->sta_hash_lock);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 			pwrpriv->smart_ps = smart_ps;
 			pwrpriv->pwr_mode = ps_mode;
 			pwrpriv->bFwCurrentInPSMode = true;
 			rtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));
 #ifdef CONFIG_P2P_PS
-			// Set CTWindow after LPS
+			/*  Set CTWindow after LPS */
 			if (pwdinfo->opp_ps == 1)
 				p2p_ps_wk_cmd(padapter, P2P_PS_ENABLE, 0);
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 #ifdef CONFIG_LPS_LCLK
 			if (pwrpriv->alives == 0)
 				rtw_set_rpwm(padapter, PS_STATE_S0);
@@ -514,20 +514,20 @@ _func_enter_;
 			_exit_pwrlock(&pwrpriv->lock);
 #endif
 		}
-		//else
-		//{
-		//	pwrpriv->pwr_mode = PS_MODE_ACTIVE;
-		//}
+		/* else */
+		/*  */
+		/* 	pwrpriv->pwr_mode = PS_MODE_ACTIVE; */
+		/*  */
 	}
 
 _func_exit_;
 }
 
 
-//
-//	Description:
-//		Enter the leisure power save mode.
-//
+/*  */
+/* 	Description: */
+/* 		Enter the leisure power save mode. */
+/*  */
 void rtw_lps_enter(struct rtw_adapter * padapter)
 {
 	struct pwrctrl_priv	*pwrpriv = &padapter->pwrctrlpriv;
@@ -536,7 +536,7 @@ void rtw_lps_enter(struct rtw_adapter *
 
 _func_enter_;
 
-//	DBG_8192D("+LeisurePSEnter\n");
+/* 	DBG_8192D("+LeisurePSEnter\n"); */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
@@ -579,8 +579,8 @@ _func_enter_;
 		return ;
 
 	if (pwrpriv->bLeisurePs) {
-		// Idle for a while if we connect to AP a while ago.
-		if (pwrpriv->LpsIdleCount >= 2) //  4 Sec
+		/*  Idle for a while if we connect to AP a while ago. */
+		if (pwrpriv->LpsIdleCount >= 2) /*   4 Sec */
 		{
 			if (pwrpriv->pwr_mode == PS_MODE_ACTIVE)
 			{
@@ -591,16 +591,16 @@ _func_enter_;
 			pwrpriv->LpsIdleCount++;
 	}
 
-//	DBG_8192D("-LeisurePSEnter\n");
+/* 	DBG_8192D("-LeisurePSEnter\n"); */
 
 _func_exit_;
 }
 
 
-//
-//	Description:
-//		Leave the leisure power save mode.
-//
+/*  */
+/* 	Description: */
+/* 		Leave the leisure power save mode. */
+/*  */
 void rtw_lps_leave(struct rtw_adapter * padapter)
 {
 #define LPS_LEAVE_TIMEOUT_MS 100
@@ -611,7 +611,7 @@ void rtw_lps_leave(struct rtw_adapter *
 
 _func_enter_;
 
-//	DBG_8192D("+LeisurePSLeave\n");
+/* 	DBG_8192D("+LeisurePSLeave\n"); */
 
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->iface_type != IFACE_PORT0)
@@ -646,31 +646,31 @@ _func_enter_;
 	}
 
 
-//	DBG_8192D("-LeisurePSLeave\n");
+/* 	DBG_8192D("-LeisurePSLeave\n"); */
 
 _func_exit_;
 }
 
 #endif
 
-//
-// Description: Leave all power save mode: LPS, FwLPS, IPS if needed.
-// Move code to function by tynli. 2010.03.26.
-//
+/*  */
+/*  Description: Leave all power save mode: LPS, FwLPS, IPS if needed. */
+/*  Move code to function by tynli. 2010.03.26. */
+/*  */
 void LeaveAllPowerSaveMode(struct rtw_adapter * Adapter)
 {
 	struct mlme_priv	*pmlmepriv = &(Adapter->mlmepriv);
 
 _func_enter_;
 
-	//DBG_8192D("%s.....\n",__func__);
+	/* DBG_8192D("%s.....\n",__func__); */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
-	{ //connect
+	{ /* connect */
 #ifdef CONFIG_P2P_PS
 		p2p_ps_wk_cmd(Adapter, P2P_PS_DISABLE, 0);
-#endif // CONFIG_P2P_PS
+#endif /*  CONFIG_P2P_PS */
 #ifdef CONFIG_LPS
-		//DBG_8192D("==> leave LPS.......\n");
+		/* DBG_8192D("==> leave LPS.......\n"); */
 		rtw_lps_leave(Adapter);
 #endif
 	}
@@ -684,20 +684,12 @@ _func_enter_;
 				#if (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,35))
 				usb_disable_autosuspend(adapter_to_dvobj(Adapter)->pusbdev);
 				#elif (LINUX_VERSION_CODE>=KERNEL_VERSION(2,6,22) && LINUX_VERSION_CODE<=KERNEL_VERSION(2,6,34))
-				adapter_to_dvobj(Adapter)->pusbdev->autosuspend_disabled = Adapter->bDisableAutosuspend;//autosuspend disabled by the user
+				adapter_to_dvobj(Adapter)->pusbdev->autosuspend_disabled = Adapter->bDisableAutosuspend;/* autosuspend disabled by the user */
 				#endif
 			}
 			else
 			#endif
 			{
-			/*
-				#ifdef CONFIG_IPS
-				if (false == ips_leave(Adapter))
-				{
-					DBG_8192D("======> ips_leave fail.............\n");
-				}
-				#endif
-			*/
 			}
 		}
 	}
@@ -1029,7 +1021,7 @@ _func_exit_;
 
 #ifdef CONFIG_RESUME_IN_WORKQUEUE
 static void resume_workitem_callback(struct work_struct *work);
-#endif //CONFIG_RESUME_IN_WORKQUEUE
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
 
 void rtw_init_pwrctrl_priv(struct rtw_adapter * padapter)
 {
@@ -1058,8 +1050,7 @@ _func_enter_;
 #endif
 
 	pwrctrlpriv->LpsIdleCount = 0;
-	//pwrctrlpriv->FWCtrlPSMode =padapter->registrypriv.power_mgnt;// PS_MODE_MIN;
-	pwrctrlpriv->power_mgnt =padapter->registrypriv.power_mgnt;// PS_MODE_MIN;
+	pwrctrlpriv->power_mgnt =padapter->registrypriv.power_mgnt;/*  PS_MODE_MIN; */
 	pwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt)?true:false;
 
 	pwrctrlpriv->bFwCurrentInPSMode = false;
@@ -1078,12 +1069,12 @@ _func_enter_;
 	#ifdef CONFIG_RESUME_IN_WORKQUEUE
 	_init_workitem(&pwrctrlpriv->resume_work, resume_workitem_callback, NULL);
 	pwrctrlpriv->rtw_workqueue = create_singlethread_workqueue("rtw_workqueue");
-	#endif //CONFIG_RESUME_IN_WORKQUEUE
+	#endif /* CONFIG_RESUME_IN_WORKQUEUE */
 
 	#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
 	pwrctrlpriv->early_suspend.suspend = NULL;
 	rtw_register_early_suspend(pwrctrlpriv);
-	#endif //CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER
+	#endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
 
 
 _func_exit_;
@@ -1096,7 +1087,7 @@ void rtw_free_pwrctrl_priv(struct rtw_ad
 
 _func_enter_;
 
-	//memset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv));
+	/* memset((unsigned char *)pwrctrlpriv, 0, sizeof(struct pwrctrl_priv)); */
 
 
 	#ifdef CONFIG_RESUME_IN_WORKQUEUE
@@ -1109,7 +1100,7 @@ _func_enter_;
 
 	#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
 	rtw_unregister_early_suspend(pwrctrlpriv);
-	#endif //CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER
+	#endif /* CONFIG_HAS_EARLYSUSPEND || CONFIG_ANDROID_POWER */
 
 	_free_pwrlock(&pwrctrlpriv->lock);
 
@@ -1129,11 +1120,11 @@ static void resume_workitem_callback(str
 
 void rtw_resume_in_workqueue(struct pwrctrl_priv *pwrpriv)
 {
-	// accquire system's suspend lock preventing from falliing asleep while resume in workqueue
+	/*  accquire system's suspend lock preventing from falliing asleep while resume in workqueue */
 	rtw_lock_suspend();
 	queue_work(pwrpriv->rtw_workqueue, &pwrpriv->resume_work);
 }
-#endif //CONFIG_RESUME_IN_WORKQUEUE
+#endif /* CONFIG_RESUME_IN_WORKQUEUE */
 
 #if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_ANDROID_POWER)
 inline bool rtw_is_earlysuspend_registered(struct pwrctrl_priv *pwrpriv)
@@ -1178,7 +1169,7 @@ void rtw_register_early_suspend(struct p
 {
 	DBG_8192D("%s\n", __func__);
 
-	//jeff: set the early suspend level before blank screen, so we wll do late resume after scree is lit
+	/* jeff: set the early suspend level before blank screen, so we wll do late resume after scree is lit */
 	pwrpriv->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
 	pwrpriv->early_suspend.suspend = rtw_early_suspend;
 	pwrpriv->early_suspend.resume = rtw_late_resume;
@@ -1198,7 +1189,7 @@ void rtw_unregister_early_suspend(struct
 	pwrpriv->early_suspend.suspend = NULL;
 	pwrpriv->early_suspend.resume = NULL;
 }
-#endif //CONFIG_HAS_EARLYSUSPEND
+#endif /* CONFIG_HAS_EARLYSUSPEND */
 
 #ifdef CONFIG_ANDROID_POWER
 extern int rtw_resume_process(struct rtw_adapter * padapter);
@@ -1226,7 +1217,7 @@ void rtw_register_early_suspend(struct p
 {
 	DBG_8192D("%s\n", __func__);
 
-	//jeff: set the early suspend level before blank screen, so we wll do late resume after scree is lit
+	/* jeff: set the early suspend level before blank screen, so we wll do late resume after scree is lit */
 	pwrpriv->early_suspend.level = ANDROID_EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
 	pwrpriv->early_suspend.suspend = rtw_early_suspend;
 	pwrpriv->early_suspend.resume = rtw_late_resume;
@@ -1245,7 +1236,7 @@ void rtw_unregister_early_suspend(struct
 	pwrpriv->early_suspend.suspend = NULL;
 	pwrpriv->early_suspend.resume = NULL;
 }
-#endif //CONFIG_ANDROID_POWER
+#endif /* CONFIG_ANDROID_POWER */
 
 u8 rtw_interface_ps_func(struct rtw_adapter *padapter, enum HAL_INTF_PS_FUNC efunc_id,u8* val)
 {
@@ -1314,19 +1305,19 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 			DBG_8192D("%s wait bInSuspend done\n", __func__);
 	}
 
-	//System suspend is not allowed to wakeup
+	/* System suspend is not allowed to wakeup */
 	if ((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend)) {
 		ret = _FAIL;
 		goto exit;
 	}
 
-	//block???
+	/* block??? */
 	if ((pwrpriv->bInternalAutoSuspend == true)  && (padapter->net_closed == true)) {
 		ret = _FAIL;
 		goto exit;
 	}
 
-	//I think this should be check in IPS, LPS, autosuspend functions...
+	/* I think this should be check in IPS, LPS, autosuspend functions... */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		ret = _SUCCESS;
@@ -1367,7 +1358,7 @@ int _rtw_pwr_wakeup(struct rtw_adapter *
 		}
 	}
 
-	//TODO: the following checking need to be merged...
+	/* TODO: the following checking need to be merged... */
 	if (padapter->bDriverStopped
 		|| !padapter->bup
 		|| !padapter->hw_init_completed
--- a/drivers/staging/rtl8192du/core/rtw_recv.c
+++ b/drivers/staging/rtl8192du/core/rtw_recv.c
@@ -32,7 +32,7 @@
 
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS);
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 
 void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
@@ -44,8 +44,8 @@ _func_enter_;
 
 	_rtw_spinlock_init(&psta_recvpriv->lock);
 
-	//for (i=0; i<MAX_RX_NUMBLKS; i++)
-	//	_rtw_init_queue(&psta_recvpriv->blk_strms[i]);
+	/* for (i=0; i<MAX_RX_NUMBLKS; i++) */
+	/* 	_rtw_init_queue(&psta_recvpriv->blk_strms[i]); */
 
 	_rtw_init_queue(&psta_recvpriv->defrag_q);
 
@@ -62,8 +62,8 @@ int _rtw_init_recv_priv(struct recv_priv
 
 _func_enter_;
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
-	//memset((unsigned char *)precvpriv, 0, sizeof (struct  recv_priv));
+	/*  We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc(). */
+	/* memset((unsigned char *)precvpriv, 0, sizeof (struct  recv_priv)); */
 
 	_rtw_spinlock_init(&precvpriv->lock);
 
@@ -83,11 +83,11 @@ _func_enter_;
 		res= _FAIL;
 		goto exit;
 	}
-	//memset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ);
+	/* memset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME * sizeof(union recv_frame) + RXFRAME_ALIGN_SZ); */
 
 	precvpriv->precv_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(precvpriv->pallocated_frame_buf), RXFRAME_ALIGN_SZ);
-	//precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf + RXFRAME_ALIGN_SZ -
-	//						((SIZE_PTR) (precvpriv->pallocated_frame_buf) &(RXFRAME_ALIGN_SZ-1));
+	/* precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf + RXFRAME_ALIGN_SZ - */
+	/* 						((SIZE_PTR) (precvpriv->pallocated_frame_buf) &(RXFRAME_ALIGN_SZ-1)); */
 
 	precvframe = (union recv_frame*) precvpriv->precv_frame_buf;
 
@@ -117,10 +117,10 @@ _func_enter_;
 #ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
 	_init_timer(&precvpriv->signal_stat_timer, padapter->pnetdev, RTW_TIMER_HDL_NAME(signal_stat), padapter);
 
-	precvpriv->signal_stat_sampling_interval = 1000; //ms
+	precvpriv->signal_stat_sampling_interval = 1000; /* ms */
 
 	rtw_set_signal_stat_timer(precvpriv);
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
 
 exit:
 
@@ -145,7 +145,7 @@ void rtw_mfree_recv_priv_lock(struct rec
 
 #ifdef CONFIG_USE_USB_BUFFER_ALLOC_RX
 	_rtw_spinlock_free(&precvpriv->recv_buf_pending_queue.lock);
-#endif	// CONFIG_USE_USB_BUFFER_ALLOC_RX
+#endif	/*  CONFIG_USE_USB_BUFFER_ALLOC_RX */
 }
 
 void _rtw_free_recv_priv (struct recv_priv *precvpriv)
@@ -234,7 +234,7 @@ _func_enter_;
 #ifdef CONFIG_CONCURRENT_MODE
 	if (padapter->adapter_type > PRIMARY_ADAPTER)
 	{
-		padapter = padapter->pbuddy_adapter;//get primary_padapter
+		padapter = padapter->pbuddy_adapter;/* get primary_padapter */
 		precvpriv = &padapter->recvpriv;
 		pfree_recv_queue = &precvpriv->free_recv_queue;
 		precvframe->u.hdr.adapter = padapter;
@@ -243,9 +243,9 @@ _func_enter_;
 	if (precvframe->u.hdr.pkt) {
 #ifdef CONFIG_BSD_RX_USE_MBUF
 		m_freem(precvframe->u.hdr.pkt);
-#else	// CONFIG_BSD_RX_USE_MBUF
-		dev_kfree_skb_any(precvframe->u.hdr.pkt);//free skb by driver
-#endif	// CONFIG_BSD_RX_USE_MBUF
+#else	/*  CONFIG_BSD_RX_USE_MBUF */
+		dev_kfree_skb_any(precvframe->u.hdr.pkt);/* free skb by driver */
+#endif	/*  CONFIG_BSD_RX_USE_MBUF */
 		precvframe->u.hdr.pkt = NULL;
 	}
 
@@ -277,7 +277,7 @@ int _rtw_enqueue_recvframe(union recv_fr
 
 _func_enter_;
 
-	//INIT_LIST_HEAD(&(precvframe->u.hdr.list));
+	/* INIT_LIST_HEAD(&(precvframe->u.hdr.list)); */
 	rtw_list_delete(&(precvframe->u.hdr.list));
 
 
@@ -419,7 +419,7 @@ int recvframe_chkmic(struct rtw_adapter
 	u8	bmic_err=false,brpt_micerror = true;
 	u8	*pframe, *payload,*pframemic;
 	u8	*mickey;
-	//u8	*iv,rxdata_key_idx=0;
+	/* u8	*iv,rxdata_key_idx=0; */
 	struct	sta_info		*stainfo;
 	struct	rx_pkt_attrib	*prxattrib=&precvframe->u.hdr.attrib;
 	struct	security_priv	*psecuritypriv=&adapter->securitypriv;
@@ -436,19 +436,19 @@ _func_enter_;
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic:da=0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",
 			prxattrib->ra[0],prxattrib->ra[1],prxattrib->ra[2],prxattrib->ra[3],prxattrib->ra[4],prxattrib->ra[5]));
 
-		//calculate mic code
+		/* calculate mic code */
 		if (stainfo!= NULL)
 		{
 			if (IS_MCAST(prxattrib->ra))
 			{
-				//mickey=&psecuritypriv->dot118021XGrprxmickey.skey[0];
-				//iv = precvframe->u.hdr.rx_data+prxattrib->hdrlen;
-				//rxdata_key_idx =(((iv[3])>>6)&0x3) ;
+				/* mickey=&psecuritypriv->dot118021XGrprxmickey.skey[0]; */
+				/* iv = precvframe->u.hdr.rx_data+prxattrib->hdrlen; */
+				/* rxdata_key_idx =(((iv[3])>>6)&0x3) ; */
 				mickey=&psecuritypriv->dot118021XGrprxmickey[prxattrib->key_index].skey[0];
 
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n recvframe_chkmic: bcmc key\n"));
-				//DBG_8192D("\n recvframe_chkmic: bcmc key psecuritypriv->dot118021XGrpKeyid(%d),pmlmeinfo->key_index(%d) ,recv key_id(%d)\n",
-				//								psecuritypriv->dot118021XGrpKeyid,pmlmeinfo->key_index,rxdata_key_idx);
+				/* DBG_8192D("\n recvframe_chkmic: bcmc key psecuritypriv->dot118021XGrpKeyid(%d),pmlmeinfo->key_index(%d) ,recv key_id(%d)\n", */
+				/* 								psecuritypriv->dot118021XGrpKeyid,pmlmeinfo->key_index,rxdata_key_idx); */
 
 				if (psecuritypriv->binstallGrpkey==false)
 				{
@@ -463,15 +463,14 @@ _func_enter_;
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("\n recvframe_chkmic: unicast key\n"));
 			}
 
-			datalen=precvframe->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len-prxattrib->icv_len-8;//icv_len included the mic code
+			datalen=precvframe->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len-prxattrib->icv_len-8;/* icv_len included the mic code */
 			pframe=precvframe->u.hdr.rx_data;
 			payload=pframe+prxattrib->hdrlen+prxattrib->iv_len;
 
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n prxattrib->iv_len=%d prxattrib->icv_len=%d\n",prxattrib->iv_len,prxattrib->icv_len));
 
-			//rtw_seccalctkipmic(&stainfo->dot11tkiprxmickey.skey[0],pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); //care the length of the data
 
-			rtw_seccalctkipmic(mickey,pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); //care the length of the data
+			rtw_seccalctkipmic(mickey,pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); /* care the length of the data */
 
 			pframemic=payload+datalen;
 
@@ -509,8 +508,8 @@ _func_enter_;
 					prxattrib->ra[0],prxattrib->ra[1],prxattrib->ra[2],
 					prxattrib->ra[3],prxattrib->ra[4],prxattrib->ra[5],psecuritypriv->binstallGrpkey));
 
-				// double check key_index for some timing issue ,
-				// cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue
+				/*  double check key_index for some timing issue , */
+				/*  cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue */
 				if ((IS_MCAST(prxattrib->ra)==true)  && (prxattrib->key_index != pmlmeinfo->key_index))
 					brpt_micerror = false;
 
@@ -525,7 +524,7 @@ _func_enter_;
 
 			}
 			else {
-				//mic checked ok
+				/* mic checked ok */
 				if ((psecuritypriv->bcheck_grpkey ==false)&&(IS_MCAST(prxattrib->ra)==true)) {
 					psecuritypriv->bcheck_grpkey =true;
 					RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("psecuritypriv->bcheck_grpkey =true"));
@@ -549,7 +548,7 @@ _func_exit_;
 	return res;
 }
 
-//decrypt and set the ivlen,icvlen of the recv_frame
+/* decrypt and set the ivlen,icvlen of the recv_frame */
 union recv_frame * decryptor(struct rtw_adapter *padapter,union recv_frame *precv_frame);
 union recv_frame * decryptor(struct rtw_adapter *padapter,union recv_frame *precv_frame)
 {
@@ -587,7 +586,7 @@ _func_enter_;
 	if ((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==true)))
 	{
 #ifdef CONFIG_CONCURRENT_MODE
-		if (!IS_MCAST(prxattrib->ra))//bc/mc packets use sw decryption for concurrent mode
+		if (!IS_MCAST(prxattrib->ra))/* bc/mc packets use sw decryption for concurrent mode */
 #endif
 		psecuritypriv->hw_decrypted=false;
 
@@ -638,7 +637,7 @@ _func_exit_;
 
 	return return_packet;
 }
-//###set the security information in the recv_frame
+/* set the security information in the recv_frame */
 union recv_frame * portctrl(struct rtw_adapter *adapter,union recv_frame * precv_frame);
 union recv_frame * portctrl(struct rtw_adapter *adapter,union recv_frame * precv_frame)
 {
@@ -649,7 +648,7 @@ union recv_frame * portctrl(struct rtw_a
 	struct sta_priv *pstapriv ;
 	union recv_frame * prtnframe;
 	u16	ether_type=0;
-	u16  eapol_type = 0x888e;//for Funia BD's WPA issue
+	u16  eapol_type = 0x888e;/* for Funia BD's WPA issue */
 	struct rx_pkt_attrib *pattrib = & precv_frame->u.hdr.attrib;
 
 _func_enter_;
@@ -668,13 +667,13 @@ _func_enter_;
 	{
 		if ((psta!=NULL) && (psta->ieee8021x_blocked))
 		{
-			//blocked
-			//only accept EAPOL frame
+			/* blocked */
+			/* only accept EAPOL frame */
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:psta->ieee8021x_blocked==1\n"));
 
 			prtnframe=precv_frame;
 
-			//get ether_type
+			/* get ether_type */
 			ptr=ptr+pfhdr->attrib.hdrlen+pfhdr->attrib.iv_len+LLC_HEADER_SIZE;
 			memcpy(&ether_type,ptr, 2);
 			ether_type= ntohs((unsigned short)ether_type);
@@ -683,15 +682,15 @@ _func_enter_;
 				prtnframe=precv_frame;
 			}
 			else {
-				//free this frame
+				/* free this frame */
 				rtw_free_recvframe(precv_frame, &adapter->recvpriv.free_recv_queue);
 				prtnframe=NULL;
 			}
 		}
 		else
 		{
-			//allowed
-			//check decryption status, and decrypt the frame if needed
+			/* allowed */
+			/* check decryption status, and decrypt the frame if needed */
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("########portctrl:psta->ieee8021x_blocked==0\n"));
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl:precv_frame->hdr.attrib.privacy=%x\n",precv_frame->u.hdr.attrib.privacy));
 
@@ -699,10 +698,10 @@ _func_enter_;
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("portctrl:prxstat->decrypted=%x\n", pattrib->bdecrypted));
 
 			prtnframe=precv_frame;
-			//check is the EAPOL frame or not (Rekey)
+			/* check is the EAPOL frame or not (Rekey) */
 			if (ether_type == eapol_type) {
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("########portctrl:ether_type == 0x888e\n"));
-				//check Rekey
+				/* check Rekey */
 
 				prtnframe=precv_frame;
 			}
@@ -738,7 +737,7 @@ _func_enter_;
 		return _FAIL;
 	}
 
-	if (1)//if (bretry)
+	if (1)/* if (bretry) */
 	{
 		if (seq_ctrl == prxcache->tid_rxseq[tid])
 		{
@@ -775,24 +774,24 @@ void process_pwrbit_data(struct rtw_adap
 		{
 			if (!(psta->state & WIFI_SLEEP_STATE))
 			{
-				//psta->state |= WIFI_SLEEP_STATE;
-				//pstapriv->sta_dz_bitmap |= BIT(psta->aid);
+				/* psta->state |= WIFI_SLEEP_STATE; */
+				/* pstapriv->sta_dz_bitmap |= BIT(psta->aid); */
 
 				stop_sta_xmit(padapter, psta);
 
-				//DBG_8192D("to sleep, sta_dz_bitmap=%x\n", pstapriv->sta_dz_bitmap);
+				/* DBG_8192D("to sleep, sta_dz_bitmap=%x\n", pstapriv->sta_dz_bitmap); */
 			}
 		}
 		else
 		{
 			if (psta->state & WIFI_SLEEP_STATE)
 			{
-				//psta->state ^= WIFI_SLEEP_STATE;
-				//pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
+				/* psta->state ^= WIFI_SLEEP_STATE; */
+				/* pstapriv->sta_dz_bitmap &= ~BIT(psta->aid); */
 
 				wakeup_sta_to_xmit(padapter, psta);
 
-				//DBG_8192D("to wakeup, sta_dz_bitmap=%x\n", pstapriv->sta_dz_bitmap);
+				/* DBG_8192D("to wakeup, sta_dz_bitmap=%x\n", pstapriv->sta_dz_bitmap); */
 			}
 		}
 
@@ -816,7 +815,7 @@ void process_wmmps_data(struct rtw_adapt
 #ifdef CONFIG_TDLS
 	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE))
 	{
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	if (!psta->qos_option)
 		return;
@@ -826,7 +825,7 @@ void process_wmmps_data(struct rtw_adapt
 
 #ifdef CONFIG_TDLS
 	}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	if (psta->state&WIFI_SLEEP_STATE)
 	{
@@ -857,12 +856,12 @@ void process_wmmps_data(struct rtw_adapt
 		{
 			if (psta->sleepq_ac_len>0)
 			{
-				//process received triggered frame
+				/* process received triggered frame */
 				xmit_delivery_enabled_frames(padapter, psta);
 			}
 			else
 			{
-				//issue one qos null frame with More data bit = 0 and the EOSP bit set (=1)
+				/* issue one qos null frame with More data bit = 0 and the EOSP bit set (=1) */
 				issue_qos_nulldata(padapter, psta->hwaddr, (u16)pattrib->priority, 0, 0);
 			}
 		}
@@ -882,10 +881,10 @@ int OnTDLS(struct rtw_adapter *adapter,
 	u8 category_field = 1;
 #ifdef CONFIG_WFD
 	u8 WFA_OUI[3] = { 0x50, 0x6f, 0x9a };
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 	struct tdls_info *ptdlsinfo = &(adapter->tdlsinfo);
 
-	//point to action field
+	/* point to action field */
 	paction+=pattrib->hdrlen
 			+ pattrib->iv_len
 			+ SNAP_SIZE
@@ -935,25 +934,25 @@ int OnTDLS(struct rtw_adapter *adapter,
 			ret=On_TDLS_Ch_Switch_Rsp(adapter, precv_frame);
 			break;
 #ifdef CONFIG_WFD
-		case 0x50:	//First byte of WFA OUI
+		case 0x50:	/* First byte of WFA OUI */
 			if (_rtw_memcmp(WFA_OUI, (paction), 3))
 			{
-				if (*(paction + 3) == 0x04)	//Probe request frame
+				if (*(paction + 3) == 0x04)	/* Probe request frame */
 				{
-					//WFDTDLS: for sigma test, do not setup direct link automatically
+					/* WFDTDLS: for sigma test, do not setup direct link automatically */
 					ptdlsinfo->dev_discovered = 1;
 					DBG_8192D("recv tunneled probe request frame\n");
 					issue_tunneled_probe_rsp(adapter, precv_frame);
 				}
-				if (*(paction + 3) == 0x05)	//Probe response frame
+				if (*(paction + 3) == 0x05)	/* Probe response frame */
 				{
-					//WFDTDLS: for sigma test, do not setup direct link automatically
+					/* WFDTDLS: for sigma test, do not setup direct link automatically */
 					ptdlsinfo->dev_discovered = 1;
 					DBG_8192D("recv tunneled probe response frame\n");
 				}
 			}
 			break;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 		default:
 			DBG_8192D("receive TDLS frame but not supported\n");
 			ret=_FAIL;
@@ -963,7 +962,7 @@ int OnTDLS(struct rtw_adapter *adapter,
 exit:
 	return ret;
 }
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 void count_rx_stats(struct rtw_adapter *padapter, union recv_frame *prframe, struct sta_info*sta);
 void count_rx_stats(struct rtw_adapter *padapter, union recv_frame *prframe, struct sta_info*sta)
@@ -1023,14 +1022,14 @@ int sta2sta_data_frame(
 	struct sta_info *ptdls_sta=NULL;
 	u8 *psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
 	u8 *pframe_body = psnap_type + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 _func_enter_;
 
 	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
 		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
 	{
-		// filter packets that SA is myself or multicast or broadcast
+		/*  filter packets that SA is myself or multicast or broadcast */
 		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself\n"));
 			ret= _FAIL;
@@ -1055,7 +1054,7 @@ _func_enter_;
 	else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
 	{
 #ifdef CONFIG_TDLS
-		//direct link data transfer
+		/* direct link data transfer */
 		if (ptdlsinfo->setup_state == TDLS_LINKED_STATE) {
 			ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->src);
 			if (ptdls_sta==NULL)
@@ -1065,7 +1064,7 @@ _func_enter_;
 			}
 			else if (ptdls_sta->tdls_sta_state&TDLS_LINKED_STATE)
 			{
-				//drop QoS-SubType Data, including QoS NULL, excluding QoS-Data
+				/* drop QoS-SubType Data, including QoS NULL, excluding QoS-Data */
 				if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE)== WIFI_QOS_DATA_TYPE)
 				{
 					if (GetFrameSubType(ptr)&(BIT(4)|BIT(5)|BIT(6)))
@@ -1075,18 +1074,18 @@ _func_enter_;
 						goto exit;
 					}
 				}
-				// filter packets that SA is myself or multicast or broadcast
+				/*  filter packets that SA is myself or multicast or broadcast */
 				if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
 					ret= _FAIL;
 					goto exit;
 				}
-				// da should be for me
+				/*  da should be for me */
 				if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
 				{
 					ret= _FAIL;
 					goto exit;
 				}
-				// check BSSID
+				/*  check BSSID */
 				if (_rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 				     _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 				     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)))
@@ -1095,20 +1094,20 @@ _func_enter_;
 					goto exit;
 				}
 
-				//process UAPSD tdls sta
+				/* process UAPSD tdls sta */
 				process_pwrbit_data(adapter, precv_frame);
 
-				// if NULL-frame, check pwrbit
+				/*  if NULL-frame, check pwrbit */
 				if ((GetFrameSubType(ptr)) == WIFI_DATA_NULL)
 				{
-					//NULL-frame with pwrbit=1, buffer_STA should buffer frames for sleep_STA
+					/* NULL-frame with pwrbit=1, buffer_STA should buffer frames for sleep_STA */
 					if (GetPwrMgt(ptr))
 					{
 						DBG_8192D("TDLS: recv peer null frame with pwr bit 1\n");
 						ptdls_sta->tdls_sta_state|=TDLS_PEER_SLEEP_STATE;
 					}
-					// it would be triggered when we are off channel and receiving NULL DATA
-					// we can confirm that peer STA is at off channel
+					/*  it would be triggered when we are off channel and receiving NULL DATA */
+					/*  we can confirm that peer STA is at off channel */
 					else if (ptdls_sta->tdls_sta_state&TDLS_CH_SWITCH_ON_STATE)
 					{
 						if ((ptdls_sta->tdls_sta_state & TDLS_PEER_AT_OFF_STATE) != TDLS_PEER_AT_OFF_STATE)
@@ -1122,7 +1121,7 @@ _func_enter_;
 					ret= _FAIL;
 					goto exit;
 				}
-				//receive some of all TDLS management frames, process it at ON_TDLS
+				/* receive some of all TDLS management frames, process it at ON_TDLS */
 				if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, 2))) {
 					ret= OnTDLS(adapter, precv_frame);
 					goto exit;
@@ -1134,9 +1133,9 @@ _func_enter_;
 
 		}
 		else
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 		{
-			// For Station mode, sa and bssid should always be BSSID, and DA is my mac-address
+			/*  For Station mode, sa and bssid should always be BSSID, and DA is my mac-address */
 			if (!_rtw_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN))
 			{
 				RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("bssid != TA under STATION_MODE; drop pkt\n"));
@@ -1151,15 +1150,15 @@ _func_enter_;
 	{
 		if (bmcast)
 		{
-			// For AP mode, if DA == MCAST, then BSSID should be also MCAST
+			/*  For AP mode, if DA == MCAST, then BSSID should be also MCAST */
 			if (!IS_MCAST(pattrib->bssid)) {
 					ret= _FAIL;
 					goto exit;
 			}
 		}
-		else // not mc-frame
+		else /*  not mc-frame */
 		{
-			// For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID
+			/*  For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID */
 			if (!_rtw_memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN)) {
 				ret= _FAIL;
 				goto exit;
@@ -1189,12 +1188,12 @@ _func_enter_;
 	if (bmcast)
 		*psta = rtw_get_bcmc_stainfo(adapter);
 	else
-		*psta = rtw_get_stainfo(pstapriv, sta_addr); // get ap_info
+		*psta = rtw_get_stainfo(pstapriv, sta_addr); /*  get ap_info */
 
 #ifdef CONFIG_TDLS
 	if (ptdls_sta != NULL)
 		*psta = ptdls_sta;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 
 	if (*psta == NULL) {
@@ -1237,7 +1236,7 @@ _func_enter_;
 			|| check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true	)
 		)
 	{
-		// filter packets that SA is myself or multicast or broadcast
+		/*  filter packets that SA is myself or multicast or broadcast */
 		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)) {
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" SA==myself\n"));
 			#ifdef DBG_RX_DROP_FRAME
@@ -1251,7 +1250,7 @@ _func_enter_;
 			goto exit;
 		}
 
-		// da should be for me
+		/*  da should be for me */
 		if ((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,
@@ -1264,7 +1263,7 @@ _func_enter_;
 		}
 
 
-		// check BSSID
+		/*  check BSSID */
 		if (_rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		     _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
 		     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)))
@@ -1290,7 +1289,7 @@ _func_enter_;
 		if (bmcast)
 			*psta = rtw_get_bcmc_stainfo(adapter);
 		else
-			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get ap_info
+			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); /*  get ap_info */
 
 		if (*psta == NULL) {
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("ap2sta: can't get psta under STATION_MODE ; drop pkt\n"));
@@ -1321,11 +1320,11 @@ _func_enter_;
 		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
 		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
 
-		//
+		/*  */
 		memcpy(pattrib->bssid,  mybssid, ETH_ALEN);
 
 
-		*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get sta_info
+		*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); /*  get sta_info */
 		if (*psta == NULL) {
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("can't get psta under MP_MODE ; drop pkt\n"));
 			#ifdef DBG_RX_DROP_FRAME
@@ -1347,7 +1346,7 @@ _func_enter_;
 	{
 		if (_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN)&& (!bmcast))
 		{
-			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get sta_info
+			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); /*  get sta_info */
 			if (*psta == NULL)
 			{
 				DBG_8192D("issue_deauth to the ap=%pM for the reason(7)\n", pattrib->bssid);
@@ -1389,7 +1388,7 @@ _func_enter_;
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 	{
-		//For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR
+		/* For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR */
 		if (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))
 		{
 			ret= _FAIL;
@@ -1447,22 +1446,22 @@ int validate_recv_ctrl_frame(struct rtw_
 	struct rx_pkt_attrib *pattrib = &precv_frame->u.hdr.attrib;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	u8 *pframe = precv_frame->u.hdr.rx_data;
-	//uint len = precv_frame->u.hdr.len;
+	/* uint len = precv_frame->u.hdr.len; */
 
-	//DBG_8192D("+validate_recv_ctrl_frame\n");
+	/* DBG_8192D("+validate_recv_ctrl_frame\n"); */
 
 	if (GetFrameType(pframe) != WIFI_CTRL_TYPE)
 	{
 		return _FAIL;
 	}
 
-	//receive the frames that ra(a1) is my address
+	/* receive the frames that ra(a1) is my address */
 	if (!_rtw_memcmp(GetAddr1Ptr(pframe), myid(&padapter->eeprompriv), ETH_ALEN))
 	{
 		return _FAIL;
 	}
 
-	//only handle ps-poll
+	/* only handle ps-poll */
 	if (GetFrameSubType(pframe) == WIFI_PSPOLL)
 	{
 		u16 aid;
@@ -1477,7 +1476,7 @@ int validate_recv_ctrl_frame(struct rtw_
 			return _FAIL;
 		}
 
-		//for rx pkt statistics
+		/* for rx pkt statistics */
 		psta->sta_stats.rx_ctrl_pkts++;
 
 		switch (pattrib->priority)
@@ -1538,7 +1537,7 @@ int validate_recv_ctrl_frame(struct rtw_
 
 				pxmitframe->attrib.triggered = 1;
 
-	                        //DBG_8192D("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
+	                        /* DBG_8192D("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap); */
 
 				spin_unlock_bh(&psta->sleep_q.lock);
 				if (rtw_hal_xmit(padapter, pxmitframe) == true)
@@ -1551,24 +1550,24 @@ int validate_recv_ctrl_frame(struct rtw_
 				{
 					pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
-					//DBG_8192D("after handling ps-poll, tim=%x\n", pstapriv->tim_bitmap);
+					/* DBG_8192D("after handling ps-poll, tim=%x\n", pstapriv->tim_bitmap); */
 
-					//upate BCN for TIM IE
-					//update_BCNTIM(padapter);
+					/* upate BCN for TIM IE */
+					/* update_BCNTIM(padapter); */
 					update_beacon(padapter, _TIM_IE_, NULL, false);
 				}
 
 			}
 			else
 			{
-				//DBG_8192D("no buffered packets to xmit\n");
+				/* DBG_8192D("no buffered packets to xmit\n"); */
 				if (pstapriv->tim_bitmap&BIT(psta->aid))
 				{
 					if (psta->sleepq_len==0)
 					{
 						DBG_8192D("no buffered packets to xmit\n");
 
-						//issue nulldata with More data bit = 0 to indicate we have no buffered packets
+						/* issue nulldata with More data bit = 0 to indicate we have no buffered packets */
 						issue_nulldata(padapter, psta->hwaddr, 0, 0, 0);
 					}
 					else
@@ -1579,8 +1578,8 @@ int validate_recv_ctrl_frame(struct rtw_
 
 					pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
-					//upate BCN for TIM IE
-					//update_BCNTIM(padapter);
+					/* upate BCN for TIM IE */
+					/* update_BCNTIM(padapter); */
 					update_beacon(padapter, _TIM_IE_, NULL, false);
 				}
 
@@ -1610,7 +1609,7 @@ int validate_recv_mgnt_frame(struct rtw_
 	}
 
 	{
-		//for rx pkt statistics
+		/* for rx pkt statistics */
 		struct sta_info *psta = rtw_get_stainfo(&padapter->stapriv, GetAddr2Ptr(precv_frame->u.hdr.rx_data));
 		if (psta) {
 			psta->sta_stats.rx_mgnt_pkts++;
@@ -1646,7 +1645,7 @@ int validate_recv_data_frame(struct rtw_
 	int ret = _SUCCESS;
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 _func_enter_;
 
@@ -1714,14 +1713,14 @@ _func_enter_;
 		goto exit;
 	}
 
-	//psta->rssi = prxcmd->rssi;
-	//psta->signal_quality= prxcmd->sq;
+	/* psta->rssi = prxcmd->rssi; */
+	/* psta->signal_quality= prxcmd->sq; */
 	precv_frame->u.hdr.psta = psta;
 
 
 	pattrib->amsdu=0;
 	pattrib->ack_policy = 0;
-	//parsing QC field
+	/* parsing QC field */
 	if (pattrib->qos == 1)
 	{
 		pattrib->priority = GetPriority((ptr + 24));
@@ -1741,14 +1740,14 @@ _func_enter_;
 	}
 
 
-	if (pattrib->order)//HT-CTRL 11n
+	if (pattrib->order)/* HT-CTRL 11n */
 	{
 		pattrib->hdrlen += 4;
 	}
 
 	precv_frame->u.hdr.preorder_ctrl = &psta->recvreorder_ctrl[pattrib->priority];
 
-	// decache, drop duplicate recv packets
+	/*  decache, drop duplicate recv packets */
 	if (recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) == _FAIL)
 	{
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("decache : drop pkt\n"));
@@ -1766,7 +1765,7 @@ _func_enter_;
 				pattrib->encrypt=psta->dot118021XPrivacy;
 		}
 		else
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, IS_MCAST(pattrib->ra));
 
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n pattrib->encrypt=%d\n",pattrib->encrypt));
@@ -1789,9 +1788,9 @@ _func_exit_;
 int validate_recv_frame(struct rtw_adapter *adapter, union recv_frame *precv_frame);
 int validate_recv_frame(struct rtw_adapter *adapter, union recv_frame *precv_frame)
 {
-	//shall check frame subtype, to / from ds, da, bssid
+	/* shall check frame subtype, to / from ds, da, bssid */
 
-	//then call check if rx seq/frag. duplicated.
+	/* then call check if rx seq/frag. duplicated. */
 
 	u8 type;
 	u8 subtype;
@@ -1807,7 +1806,7 @@ int validate_recv_frame(struct rtw_adapt
 
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 _func_enter_;
 
@@ -1824,9 +1823,9 @@ _func_enter_;
 	if (ptdlsinfo->ch_sensing==1 && ptdlsinfo->cur_channel !=0) {
 		ptdlsinfo->collect_pkt_num[ptdlsinfo->cur_channel-1]++;
 	}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
-	//add version chk
+	/* add version chk */
 	if (ver!=0) {
 		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail! (ver!=0)\n"));
 		retval= _FAIL;
@@ -1834,7 +1833,7 @@ _func_enter_;
 	}
 
 	type =  GetFrameType(ptr);
-	subtype = GetFrameSubType(ptr); //bit(7)~bit(2)
+	subtype = GetFrameSubType(ptr); /* bit(7)~bit(2) */
 
 	pattrib->to_fr_ds = get_tofr_ds(ptr);
 
@@ -1847,19 +1846,19 @@ _func_enter_;
 	pattrib->privacy = GetPrivacy(ptr);
 	pattrib->order = GetOrder(ptr);
 	switch (type) {
-	case WIFI_MGT_TYPE: //mgnt
+	case WIFI_MGT_TYPE: /* mgnt */
 		retval = validate_recv_mgnt_frame(adapter, precv_frame);
 		if (retval == _FAIL)
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_mgnt_frame fail\n"));
-		retval = _FAIL; // only data frame return _SUCCESS
+		retval = _FAIL; /*  only data frame return _SUCCESS */
 		break;
-	case WIFI_CTRL_TYPE: //ctrl
+	case WIFI_CTRL_TYPE: /* ctrl */
 		retval = validate_recv_ctrl_frame(adapter, precv_frame);
 		if (retval == _FAIL)
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_ctrl_frame fail\n"));
-		retval = _FAIL; // only data frame return _SUCCESS
+		retval = _FAIL; /*  only data frame return _SUCCESS */
 		break;
-	case WIFI_DATA_TYPE: //data
+	case WIFI_DATA_TYPE: /* data */
 		rtw_led_control(adapter, LED_CTL_RX);
 		pattrib->qos = (subtype & BIT(7))? 1:0;
 		retval = validate_recv_data_frame(adapter, precv_frame);
@@ -1885,7 +1884,7 @@ _func_exit_;
 	return retval;
 }
 
-//remove the wlanhdr and add the eth_hdr
+/* remove the wlanhdr and add the eth_hdr */
 
 int wlanhdr_to_ethhdr (union recv_frame *precvframe)
 {
@@ -1899,7 +1898,7 @@ int wlanhdr_to_ethhdr (union recv_frame
 	struct rtw_adapter			*adapter =precvframe->u.hdr.adapter;
 	struct mlme_priv	*pmlmepriv = &adapter->mlmepriv;
 
-	u8	*ptr = get_recvframe_data(precvframe) ; // point to frame_ctrl field
+	u8	*ptr = get_recvframe_data(precvframe) ; /*  point to frame_ctrl field */
 	struct rx_pkt_attrib *pattrib = & precvframe->u.hdr.attrib;
 
 _func_enter_;
@@ -1911,11 +1910,11 @@ _func_enter_;
 	psnap=(struct ieee80211_snap_hdr	*)(ptr+pattrib->hdrlen + pattrib->iv_len);
 	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
 	/* convert hdr + possible LLC headers into Ethernet header */
-	//eth_type = (psnap_type[0] << 8) | psnap_type[1];
+	/* eth_type = (psnap_type[0] << 8) | psnap_type[1]; */
 	if ((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
 		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == false) &&
 		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==false))||
-		//eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		/* eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) || */
 		 _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)) {
 		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
 		bsnaphdr = true;
@@ -1931,7 +1930,7 @@ _func_enter_;
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("\n===pattrib->hdrlen: %x,  pattrib->iv_len:%x ===\n\n", pattrib->hdrlen,  pattrib->iv_len));
 
 	memcpy(&eth_type, ptr+rmv_len, 2);
-	eth_type= ntohs((unsigned short)eth_type); //pattrib->ether_type
+	eth_type= ntohs((unsigned short)eth_type); /* pattrib->ether_type */
 	pattrib->eth_type = eth_type;
 
 	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true))
@@ -1941,7 +1940,7 @@ _func_enter_;
 		*(ptr+1) = 0x12;
 
 		eth_type = 0x8712;
-		// append rx status for mp test packets
+		/*  append rx status for mp test packets */
 		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);
 		memcpy(ptr, get_rxmem(precvframe), 24);
 		ptr+=24;
@@ -1962,7 +1961,7 @@ _func_exit_;
 	return ret;
 }
 
-//perform defrag
+/* perform defrag */
 union recv_frame * recvframe_defrag(struct rtw_adapter *adapter, struct __queue *defrag_q)
 {
 	struct list_head *plist, *phead;
@@ -1985,8 +1984,8 @@ _func_enter_;
 
 	if (curfragnum!=pfhdr->attrib.frag_num)
 	{
-		//the first fragment number must be 0
-		//free the whole queue
+		/* the first fragment number must be 0 */
+		/* free the whole queue */
 		rtw_free_recvframe(prframe, pfree_recv_queue);
 		rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
 
@@ -2007,12 +2006,12 @@ _func_enter_;
 		pnfhdr=&pnextrframe->u.hdr;
 
 
-		//check the fragment sequence  (2nd ~n fragment frame)
+		/* check the fragment sequence  (2nd ~n fragment frame) */
 
 		if (curfragnum!=pnfhdr->attrib.frag_num)
 		{
-			//the fragment number must be increasing  (after decache)
-			//release the defrag_q & prframe
+			/* the fragment number must be increasing  (after decache) */
+			/* release the defrag_q & prframe */
 			rtw_free_recvframe(prframe, pfree_recv_queue);
 			rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
 			return NULL;
@@ -2020,17 +2019,17 @@ _func_enter_;
 
 		curfragnum++;
 
-		//copy the 2nd~n fragment frame's payload to the first fragment
-		//get the 2nd~last fragment frame's payload
+		/* copy the 2nd~n fragment frame's payload to the first fragment */
+		/* get the 2nd~last fragment frame's payload */
 
 		wlanhdr_offset = pnfhdr->attrib.hdrlen + pnfhdr->attrib.iv_len;
 
 		recvframe_pull(pnextrframe, wlanhdr_offset);
 
-		//append  to first fragment frame's tail (if privacy frame, pull the ICV)
+		/* append  to first fragment frame's tail (if privacy frame, pull the ICV) */
 		recvframe_pull_tail(prframe, pfhdr->attrib.icv_len);
 
-		//memcpy
+		/* memcpy */
 		memcpy(pfhdr->rx_tail, pnfhdr->rx_data, pnfhdr->len);
 
 		recvframe_put(prframe, pnfhdr->len);
@@ -2040,7 +2039,7 @@ _func_enter_;
 
 	};
 
-	//free the defrag_q queue and return the prframe
+	/* free the defrag_q queue and return the prframe */
 	rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
 
 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Performance defrag!!!!!\n"));
@@ -2050,7 +2049,7 @@ _func_exit_;
 	return prframe;
 }
 
-//check if need to defrag, if needed queue the frame to defrag_q
+/* check if need to defrag, if needed queue the frame to defrag_q */
 union recv_frame* recvframe_chk_defrag(struct rtw_adapter * padapter, union recv_frame *precv_frame)
 {
 	u8	ismfrag;
@@ -2071,7 +2070,7 @@ _func_enter_;
 
 	pfree_recv_queue = &padapter->recvpriv.free_recv_queue;
 
-	//need to define struct of wlan header frame ctrl
+	/* need to define struct of wlan header frame ctrl */
 	ismfrag = pfhdr->attrib.mfrag;
 	fragnum = pfhdr->attrib.frag_num;
 
@@ -2091,32 +2090,32 @@ _func_enter_;
 
 	if ((ismfrag==0) && (fragnum==0))
 	{
-		prtnframe = precv_frame;//isn't a fragment frame
+		prtnframe = precv_frame;/* isn't a fragment frame */
 	}
 
 	if (ismfrag==1)
 	{
-		//0~(n-1) fragment frame
-		//enqueue to defraf_g
+		/* 0~(n-1) fragment frame */
+		/* enqueue to defraf_g */
 		if (pdefrag_q != NULL)
 		{
 			if (fragnum==0)
 			{
-				//the first fragment
+				/* the first fragment */
 				if (_rtw_queue_empty(pdefrag_q) == false)
 				{
-					//free current defrag_q
+					/* free current defrag_q */
 					rtw_free_recvframe_queue(pdefrag_q, pfree_recv_queue);
 				}
 			}
 
 
-			//Then enqueue the 0~(n-1) fragment into the defrag_q
+			/* Then enqueue the 0~(n-1) fragment into the defrag_q */
 
-			//_rtw_spinlock(&pdefrag_q->lock);
+			/* _rtw_spinlock(&pdefrag_q->lock); */
 			phead = get_list_head(pdefrag_q);
 			rtw_list_insert_tail(&pfhdr->list, phead);
-			//_rtw_spinunlock(&pdefrag_q->lock);
+			/* _rtw_spinunlock(&pdefrag_q->lock); */
 
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Enqueuq: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
 
@@ -2125,7 +2124,7 @@ _func_enter_;
 		}
 		else
 		{
-			//can't find this ta's defrag_queue, so free this recv_frame
+			/* can't find this ta's defrag_queue, so free this recv_frame */
 			rtw_free_recvframe(precv_frame, pfree_recv_queue);
 			prtnframe=NULL;
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n", ismfrag, fragnum));
@@ -2135,16 +2134,16 @@ _func_enter_;
 
 	if ((ismfrag==0)&&(fragnum!=0))
 	{
-		//the last fragment frame
-		//enqueue the last fragment
+		/* the last fragment frame */
+		/* enqueue the last fragment */
 		if (pdefrag_q != NULL)
 		{
-			//_rtw_spinlock(&pdefrag_q->lock);
+			/* _rtw_spinlock(&pdefrag_q->lock); */
 			phead = get_list_head(pdefrag_q);
 			rtw_list_insert_tail(&pfhdr->list,phead);
-			//_rtw_spinunlock(&pdefrag_q->lock);
+			/* _rtw_spinunlock(&pdefrag_q->lock); */
 
-			//call recvframe_defrag to defrag
+			/* call recvframe_defrag to defrag */
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("defrag: ismfrag = %d, fragnum= %d\n", ismfrag, fragnum));
 			precv_frame = recvframe_defrag(padapter, pdefrag_q);
 			prtnframe=precv_frame;
@@ -2152,7 +2151,7 @@ _func_enter_;
 		}
 		else
 		{
-			//can't find this ta's defrag_queue, so free this recv_frame
+			/* can't find this ta's defrag_queue, so free this recv_frame */
 			rtw_free_recvframe(precv_frame, pfree_recv_queue);
 			prtnframe=NULL;
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("Free because pdefrag_q ==NULL: ismfrag = %d, fragnum= %d\n", ismfrag,fragnum));
@@ -2163,7 +2162,7 @@ _func_enter_;
 
 	if ((prtnframe!=NULL)&&(prtnframe->u.hdr.attrib.privacy))
 	{
-		//after defrag we must check tkip mic code
+		/* after defrag we must check tkip mic code */
 		if (recvframe_chkmic(padapter,  prtnframe)==_FAIL)
 		{
 			RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("recvframe_chkmic(padapter,  prtnframe)==_FAIL\n"));
@@ -2207,14 +2206,14 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 	while (a_len > ETH_HLEN) {
 		/* Offset 12 denote 2 mac address */
 #ifdef ENDIAN_FREE
-		//nSubframe_Length = ntohs(*((u16*)(pdata + 12)));
+		/* nSubframe_Length = ntohs(*((u16*)(pdata + 12))); */
 		nSubframe_Length = RTW_GET_BE16(pdata + 12);
-#else // ENDIAN_FREE
+#else /*  ENDIAN_FREE */
 		nSubframe_Length = *((u16*)(pdata + 12));
-		//==m==>change the length order
+		/* m==>change the length order */
 		nSubframe_Length = (nSubframe_Length>>8) + (nSubframe_Length<<8);
-		//ntohs(nSubframe_Length);
-#endif // ENDIAN_FREE
+		/* ntohs(nSubframe_Length); */
+#endif /*  ENDIAN_FREE */
 
 		if (a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length)) {
 			DBG_8192D("nRemain_Length is %d and nSubframe_Length is : %d\n",a_len,nSubframe_Length);
@@ -2235,7 +2234,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 			memcpy(data_ptr, pdata, nSubframe_Length);
 		}
 		else
-#endif // CONFIG_SKB_COPY
+#endif /*  CONFIG_SKB_COPY */
 		{
 			sub_skb = skb_clone(prframe->u.hdr.pkt, GFP_ATOMIC);
 			if (sub_skb)
@@ -2278,11 +2277,11 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 		sub_skb = subframes[i];
 		/* convert hdr + possible LLC headers into Ethernet header */
 #ifdef ENDIAN_FREE
-		//eth_type = ntohs(*(u16*)&sub_skb->data[6]);
+		/* eth_type = ntohs(*(u16*)&sub_skb->data[6]); */
 		eth_type = RTW_GET_BE16(&sub_skb->data[6]);
-#else // ENDIAN_FREE
+#else /*  ENDIAN_FREE */
 		eth_type = (sub_skb->data[6] << 8) | sub_skb->data[7];
-#endif // ENDIAN_FREE
+#endif /*  ENDIAN_FREE */
 		if (sub_skb->len >= 8 &&
 			((_rtw_memcmp(sub_skb->data, rtw_rfc1042_header, SNAP_SIZE) &&
 			  eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
@@ -2302,34 +2301,34 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 
 		/* Indicat the packets to upper layer */
 		if (sub_skb) {
-			//memset(sub_skb->cb, 0, sizeof(sub_skb->cb));
+			/* memset(sub_skb->cb, 0, sizeof(sub_skb->cb)); */
 
 #ifdef CONFIG_BR_EXT
-			// Insert NAT2.5 RX here!
+			/*  Insert NAT2.5 RX here! */
 			struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 			void *br_port = NULL;
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 			br_port = padapter->pnetdev->br_port;
-#else   // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 			rcu_read_lock();
 			br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
 			rcu_read_unlock();
-#endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 
 
 			if (br_port && (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true))
 			{
 				int nat25_handle_frame(struct rtw_adapter *priv, struct sk_buff *skb);
 				if (nat25_handle_frame(padapter, sub_skb) == -1) {
-					//priv->ext_stats.rx_data_drops++;
-					//DEBUG_ERR("RX DROP: nat25_handle_frame fail!\n");
-					//return FAIL;
+					/* priv->ext_stats.rx_data_drops++; */
+					/* DEBUG_ERR("RX DROP: nat25_handle_frame fail!\n"); */
+					/* return FAIL; */
 
-					// bypass this frame to upper layer!!
+					/*  bypass this frame to upper layer!! */
 				}
 			}
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 			sub_skb->protocol = eth_type_trans(sub_skb, padapter->pnetdev);
 			sub_skb->dev = padapter->pnetdev;
@@ -2342,7 +2341,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 			}
 #else /* !CONFIG_TCP_CSUM_OFFLOAD_RX */
 			sub_skb->ip_summed = CHECKSUM_NONE;
-#endif //CONFIG_TCP_CSUM_OFFLOAD_RX
+#endif /* CONFIG_TCP_CSUM_OFFLOAD_RX */
 
 			netif_rx(sub_skb);
 		}
@@ -2351,7 +2350,7 @@ int amsdu_to_msdu(struct rtw_adapter *pa
 exit:
 
 	prframe->u.hdr.len=0;
-	rtw_free_recvframe(prframe, pfree_recv_queue);//free this recv_frame
+	rtw_free_recvframe(prframe, pfree_recv_queue);/* free this recv_frame */
 
 	return ret;
 }
@@ -2360,9 +2359,9 @@ int check_indicate_seq(struct recv_reord
 int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)
 {
 	u8	wsize = preorder_ctrl->wsize_b;
-	u16	wend = (preorder_ctrl->indicate_seq + wsize -1) & 0xFFF;//% 4096;
+	u16	wend = (preorder_ctrl->indicate_seq + wsize -1) & 0xFFF;/*  4096; */
 
-	// Rx Reorder initialize condition.
+	/*  Rx Reorder initialize condition. */
 	if (preorder_ctrl->indicate_seq == 0xFFFF)
 	{
 		preorder_ctrl->indicate_seq = seq_num;
@@ -2371,16 +2370,16 @@ int check_indicate_seq(struct recv_reord
 			preorder_ctrl->indicate_seq, seq_num);
 		#endif
 
-		//DbgPrint("check_indicate_seq, 1st->indicate_seq=%d\n", precvpriv->indicate_seq);
+		/* DbgPrint("check_indicate_seq, 1st->indicate_seq=%d\n", precvpriv->indicate_seq); */
 	}
 
-	//DbgPrint("enter->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+	/* DbgPrint("enter->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num); */
 
-	// Drop out the packet which SeqNum is smaller than WinStart
+	/*  Drop out the packet which SeqNum is smaller than WinStart */
 	if (SN_LESS(seq_num, preorder_ctrl->indicate_seq))
 	{
-		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
-		//DbgPrint("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+		/* RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum)); */
+		/* DbgPrint("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num); */
 
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_8192D("%s IndicateSeq: %d > NewSeq: %d\n", __func__,
@@ -2391,11 +2390,11 @@ int check_indicate_seq(struct recv_reord
 		return false;
 	}
 
-	//
-	// Sliding window manipulation. Conditions includes:
-	// 1. Incoming SeqNum is equal to WinStart =>Window shift 1
-	// 2. Incoming SeqNum is larger than the WinEnd => Window shift N
-	//
+	/*  */
+	/*  Sliding window manipulation. Conditions includes: */
+	/*  1. Incoming SeqNum is equal to WinStart =>Window shift 1 */
+	/*  2. Incoming SeqNum is larger than the WinEnd => Window shift N */
+	/*  */
 	if (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq))
 	{
 		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;
@@ -2406,10 +2405,10 @@ int check_indicate_seq(struct recv_reord
 	}
 	else if (SN_LESS(wend, seq_num))
 	{
-		//RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
-		//DbgPrint("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+		/* RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum)); */
+		/* DbgPrint("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num); */
 
-		// boundary situation, when seq_num cross 0xFFF
+		/*  boundary situation, when seq_num cross 0xFFF */
 		if (seq_num >= (wsize - 1))
 			preorder_ctrl->indicate_seq = seq_num + 1 -wsize;
 		else
@@ -2421,7 +2420,7 @@ int check_indicate_seq(struct recv_reord
 		#endif
 	}
 
-	//DbgPrint("exit->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+	/* DbgPrint("exit->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num); */
 
 	return true;
 }
@@ -2449,10 +2448,10 @@ int enqueue_reorder_recvframe(struct rec
 		}
 		else if (SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num))
 		{
-			//Duplicate entry is found!! Do not insert current entry.
-			//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
+			/* Duplicate entry is found!! Do not insert current entry. */
+			/* RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum)); */
 
-			//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
+			/* spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql); */
 
 			return false;
 		}
@@ -2461,23 +2460,23 @@ int enqueue_reorder_recvframe(struct rec
 			break;
 		}
 
-		//DbgPrint("enqueue_reorder_recvframe():while\n");
+		/* DbgPrint("enqueue_reorder_recvframe():while\n"); */
 
 	}
 
 
-	//spin_lock_irqsave(&ppending_recvframe_queue->lock, &irql);
-	//_rtw_spinlock_ex(&ppending_recvframe_queue->lock);
+	/* spin_lock_irqsave(&ppending_recvframe_queue->lock, &irql); */
+	/* _rtw_spinlock_ex(&ppending_recvframe_queue->lock); */
 
 	rtw_list_delete(&(prframe->u.hdr.list));
 
 	rtw_list_insert_tail(&(prframe->u.hdr.list), plist);
 
-	//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
-	//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
+	/* _rtw_spinunlock_ex(&ppending_recvframe_queue->lock); */
+	/* spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql); */
 
 
-	//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
+	/* RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum)); */
 	return true;
 }
 
@@ -2494,13 +2493,13 @@ int recv_indicatepkts_in_order(struct rt
 	phead =		get_list_head(ppending_recvframe_queue);
 	plist = get_next(phead);
 
-	// Handling some condition for forced indicate case.
+	/*  Handling some condition for forced indicate case. */
 	if (bforced==true)
 	{
 		if (rtw_is_list_empty(phead))
 		{
-			// spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
-			//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
+			/*  spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql); */
+			/* _rtw_spinunlock_ex(&ppending_recvframe_queue->lock); */
 			return true;
 		}
 
@@ -2513,8 +2512,8 @@ int recv_indicatepkts_in_order(struct rt
 		#endif
 	}
 
-	// Prepare indication list and indication.
-	// Check if there is any packet need indicate.
+	/*  Prepare indication list and indication. */
+	/*  Check if there is any packet need indicate. */
 	while (!rtw_is_list_empty(phead))
 	{
 		prframe = LIST_CONTAINOR(plist, union recv_frame, u);
@@ -2538,13 +2537,13 @@ int recv_indicatepkts_in_order(struct rt
 				#endif
 			}
 
-			//indicate this recv_frame
+			/* indicate this recv_frame */
 			if (!pattrib->amsdu)
 			{
 				if ((padapter->bDriverStopped == false) &&
 				    (padapter->bSurpriseRemoved == false))
 
-					rtw_recv_indicatepkt(padapter, prframe);//indicate this recv_frame
+					rtw_recv_indicatepkt(padapter, prframe);/* indicate this recv_frame */
 
 			} else if (pattrib->amsdu==1) {
 				if (amsdu_to_msdu(padapter, prframe)!=_SUCCESS)
@@ -2554,11 +2553,11 @@ int recv_indicatepkts_in_order(struct rt
 			}
 			else
 			{
-				//error condition;
+				/* error condition; */
 			}
 
 
-			//Update local variables.
+			/* Update local variables. */
 			bPktInBuf = false;
 
 		}
@@ -2567,36 +2566,10 @@ int recv_indicatepkts_in_order(struct rt
 			bPktInBuf = true;
 			break;
 		}
-
-		//DbgPrint("recv_indicatepkts_in_order():while\n");
-
 	}
-
-	//_rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
-	//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
-
-/*
-	//Release the indication lock and set to new indication step.
-	if (bPktInBuf)
-	{
-		// Set new pending timer.
-		//pTS->RxIndicateState = RXTS_INDICATE_REORDER;
-		//PlatformSetTimer(Adapter, &pTS->RxPktPendingTimer, pHTInfo->RxReorderPendingTime);
-		//DBG_8192D("_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME)\n");
-		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
-	}
-	else
-	{
-		//pTS->RxIndicateState = RXTS_INDICATE_IDLE;
-	}
-*/
-	//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
-
-	//return true;
 	return bPktInBuf;
 }
 
-int recv_indicatepkt_reorder(struct rtw_adapter *padapter, union recv_frame *prframe);
 int recv_indicatepkt_reorder(struct rtw_adapter *padapter, union recv_frame *prframe)
 {
 	int retval = _SUCCESS;
@@ -2606,7 +2579,7 @@ int recv_indicatepkt_reorder(struct rtw_
 
 	if (!pattrib->amsdu)
 	{
-		//s1.
+		/* s1. */
 		wlanhdr_to_ethhdr(prframe);
 
 		if ((pattrib->qos!=1) /*|| pattrib->priority!=0 || IS_MCAST(pattrib->ra)*/
@@ -2632,7 +2605,7 @@ int recv_indicatepkt_reorder(struct rtw_
 
 		if (preorder_ctrl->enable == false)
 		{
-			//indicate this recv_frame
+			/* indicate this recv_frame */
 			preorder_ctrl->indicate_seq = pattrib->seq_num;
 			#ifdef DBG_RX_SEQ
 			DBG_8192D("DBG_RX_SEQ %s:%d IndicateSeq: %d, NewSeq: %d\n", __func__, __LINE__,
@@ -2651,13 +2624,13 @@ int recv_indicatepkt_reorder(struct rtw_
 		}
 
 #ifndef CONFIG_RECV_REORDERING_CTRL
-		//indicate this recv_frame
+		/* indicate this recv_frame */
 		rtw_recv_indicatepkt(padapter, prframe);
 		return _SUCCESS;
 #endif
 
 	}
-	else if (pattrib->amsdu==1) //temp filter -> means didn't support A-MSDUs in a A-MPDU
+	else if (pattrib->amsdu==1) /* temp filter -> means didn't support A-MSDUs in a A-MPDU */
 	{
 		if (preorder_ctrl->enable == false)
 		{
@@ -2694,14 +2667,14 @@ int recv_indicatepkt_reorder(struct rtw_
 		 ("recv_indicatepkt_reorder: indicate=%d seq=%d\n",
 		  preorder_ctrl->indicate_seq, pattrib->seq_num));
 
-	//s2. check if winstart_b(indicate_seq) needs to been updated
+	/* s2. check if winstart_b(indicate_seq) needs to been updated */
 	if (!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
 	{
-		//pHTInfo->RxReorderDropCounter++;
-		//ReturnRFDList(Adapter, pRfd);
-		//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("RxReorderIndicatePacket() ==> Packet Drop!!\n"));
-		//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
-		//return _FAIL;
+		/* pHTInfo->RxReorderDropCounter++; */
+		/* ReturnRFDList(Adapter, pRfd); */
+		/* RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("RxReorderIndicatePacket() ==> Packet Drop!!\n")); */
+		/* spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql); */
+		/* return _FAIL; */
 
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_8192D("DBG_RX_DROP_FRAME %s check_indicate_seq fail\n", __func__);
@@ -2710,12 +2683,12 @@ int recv_indicatepkt_reorder(struct rtw_
 	}
 
 
-	//s3. Insert all packet into Reorder Queue to maintain its ordering.
+	/* s3. Insert all packet into Reorder Queue to maintain its ordering. */
 	if (!enqueue_reorder_recvframe(preorder_ctrl, prframe))
 	{
-		//DbgPrint("recv_indicatepkt_reorder, enqueue_reorder_recvframe fail!\n");
-		//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
-		//return _FAIL;
+		/* DbgPrint("recv_indicatepkt_reorder, enqueue_reorder_recvframe fail!\n"); */
+		/* spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql); */
+		/* return _FAIL; */
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_8192D("DBG_RX_DROP_FRAME %s enqueue_reorder_recvframe fail\n", __func__);
 		#endif
@@ -2723,17 +2696,17 @@ int recv_indicatepkt_reorder(struct rtw_
 	}
 
 
-	//s4.
-	// Indication process.
-	// After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets
-	// with the SeqNum smaller than latest WinStart and buffer other packets.
-	//
-	// For Rx Reorder condition:
-	// 1. All packets with SeqNum smaller than WinStart => Indicate
-	// 2. All packets with SeqNum larger than or equal to WinStart => Buffer it.
-	//
+	/* s4. */
+	/*  Indication process. */
+	/*  After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets */
+	/*  with the SeqNum smaller than latest WinStart and buffer other packets. */
+	/*  */
+	/*  For Rx Reorder condition: */
+	/*  1. All packets with SeqNum smaller than WinStart => Indicate */
+	/*  2. All packets with SeqNum larger than or equal to WinStart => Buffer it. */
+	/*  */
 
-	//recv_indicatepkts_in_order(padapter, preorder_ctrl, true);
+	/* recv_indicatepkts_in_order(padapter, preorder_ctrl, true); */
 	if (recv_indicatepkts_in_order(padapter, preorder_ctrl, false)==true)
 	{
 		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
@@ -2770,7 +2743,7 @@ void rtw_reordering_ctrl_timeout_handler
 		return;
 	}
 
-	//DBG_8192D("+rtw_reordering_ctrl_timeout_handler()=>\n");
+	/* DBG_8192D("+rtw_reordering_ctrl_timeout_handler()=>\n"); */
 
 	spin_lock_bh(&ppending_recvframe_queue->lock);
 
@@ -2785,12 +2758,12 @@ void rtw_reordering_ctrl_timeout_handler
 int process_recv_indicatepkts(struct rtw_adapter *padapter, union recv_frame *prframe)
 {
 	int retval = _SUCCESS;
-	//struct recv_priv *precvpriv = &padapter->recvpriv;
-	//struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	/* struct recv_priv *precvpriv = &padapter->recvpriv; */
+	/* struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib; */
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 #ifdef CONFIG_TDLS
 	struct sta_info *psta = prframe->u.hdr.psta;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 #ifdef CONFIG_80211N_HT
 
@@ -2800,14 +2773,14 @@ int process_recv_indicatepkts(struct rtw
 	if ((phtpriv->ht_option==true) ||
 		((psta->tdls_sta_state & TDLS_LINKED_STATE) &&
 		 (psta->htpriv.ht_option==true) &&
-		 (psta->htpriv.ampdu_enable==true))) //B/G/N Mode
+		 (psta->htpriv.ampdu_enable==true))) /* B/G/N Mode */
 #else
-	if (phtpriv->ht_option==true)  //B/G/N Mode
-#endif //CONFIG_TDLS
+	if (phtpriv->ht_option==true)  /* B/G/N Mode */
+#endif /* CONFIG_TDLS */
 	{
-		//prframe->u.hdr.preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority];
+		/* prframe->u.hdr.preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority]; */
 
-		if (recv_indicatepkt_reorder(padapter, prframe)!=_SUCCESS)// including perform A-MPDU Rx Ordering Buffer Control
+		if (recv_indicatepkt_reorder(padapter, prframe)!=_SUCCESS)/*  including perform A-MPDU Rx Ordering Buffer Control */
 		{
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_8192D("DBG_RX_DROP_FRAME %s recv_indicatepkt_reorder error!\n", __func__);
@@ -2821,7 +2794,7 @@ int process_recv_indicatepkts(struct rtw
 			}
 		}
 	}
-	else //B/G mode
+	else /* B/G mode */
 #endif
 	{
 		retval=wlanhdr_to_ethhdr (prframe);
@@ -2836,7 +2809,7 @@ int process_recv_indicatepkts(struct rtw
 
 		if ((padapter->bDriverStopped ==false)&&(padapter->bSurpriseRemoved==false))
 		{
-			//indicate this recv_frame
+			/* indicate this recv_frame */
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_notice_, ("@@@@ process_recv_indicatepkts- recv_func recv_indicatepkt\n"));
 			rtw_recv_indicatepkt(padapter, prframe);
 
@@ -2865,10 +2838,10 @@ int recv_func_prehandle(struct rtw_adapt
 
 #ifdef CONFIG_MP_INCLUDED
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-#endif //CONFIG_MP_INCLUDED
+#endif /* CONFIG_MP_INCLUDED */
 
 #ifdef CONFIG_MP_INCLUDED
-	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true))//&&(padapter->mppriv.check_mp_pkt == 0))
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true))/* padapter->mppriv.check_mp_pkt == 0)) */
 	{
 		if (pattrib->crc_err == 1)
 			padapter->mppriv.rx_crcerrpktcount++;
@@ -2878,18 +2851,18 @@ int recv_func_prehandle(struct rtw_adapt
 		if (check_fwstate(pmlmepriv, WIFI_MP_LPBK_STATE) == false) {
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("MP - Not in loopback mode , drop pkt\n"));
 			ret = _FAIL;
-			rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
+			rtw_free_recvframe(rframe, pfree_recv_queue);/* free this recv_frame */
 			goto exit;
 		}
 	}
 #endif
 
-	//check the frame crtl field and decache
+	/* check the frame crtl field and decache */
 	ret = validate_recv_frame(padapter, rframe);
 	if (ret != _SUCCESS)
 	{
 		RT_TRACE(_module_rtl871x_recv_c_, _drv_info_, ("recv_func: validate_recv_frame fail! drop pkt\n"));
-		rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
+		rtw_free_recvframe(rframe, pfree_recv_queue);/* free this recv_frame */
 		goto exit;
 	}
 
@@ -2907,15 +2880,15 @@ int recv_func_posthandle(struct rtw_adap
 
 #ifdef CONFIG_MP_INCLUDED
 	struct mlme_priv *pmlmepriv = &padapter->mlmepriv;
-#endif //CONFIG_MP_INCLUDED
+#endif /* CONFIG_MP_INCLUDED */
 
 #ifdef CONFIG_TDLS
 	u8 *psnap_type, *pcategory;
 	struct sta_info *ptdls_sta = NULL;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 
-	// DATA FRAME
+	/*  DATA FRAME */
 	rtw_led_control(padapter, LED_CTL_RX);
 
 	prframe = decryptor(padapter, prframe);
@@ -2929,17 +2902,17 @@ int recv_func_posthandle(struct rtw_adap
 	}
 
 #ifdef CONFIG_TDLS
-	//check TDLS frame
+	/* check TDLS frame */
 	psnap_type = get_recvframe_data(orig_prframe);
 	psnap_type+=pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
 	pcategory = psnap_type + ETH_TYPE_LEN + PAYLOAD_TYPE_LEN;
 
 	if ((_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_TDLS, ETH_TYPE_LEN)) &&
 		((*pcategory==RTW_WLAN_CATEGORY_TDLS) || (*pcategory==RTW_WLAN_CATEGORY_P2P))) {
-		ret = OnTDLS(padapter, prframe);	//all of functions will return _FAIL
+		ret = OnTDLS(padapter, prframe);	/* all of functions will return _FAIL */
 		goto _exit_recv_func;
 	}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	prframe = recvframe_chk_defrag(padapter, prframe);
 	if (prframe==NULL)	{
@@ -2966,7 +2939,7 @@ int recv_func_posthandle(struct rtw_adap
 	count_rx_stats(padapter, prframe, ptdls_sta);
 #else
 	count_rx_stats(padapter, prframe, NULL);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 #ifdef CONFIG_80211N_HT
 
@@ -2977,11 +2950,11 @@ int recv_func_posthandle(struct rtw_adap
 		#ifdef DBG_RX_DROP_FRAME
 		DBG_8192D("DBG_RX_DROP_FRAME %s recv_func: process_recv_indicatepkts fail!\n", __func__);
 		#endif
-		rtw_free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+		rtw_free_recvframe(orig_prframe, pfree_recv_queue);/* free this recv_frame */
 		goto _recv_data_drop;
 	}
 
-#else // CONFIG_80211N_HT
+#else /*  CONFIG_80211N_HT */
 
 	if (!pattrib->amsdu)
 	{
@@ -2992,14 +2965,14 @@ int recv_func_posthandle(struct rtw_adap
 			#ifdef DBG_RX_DROP_FRAME
 			DBG_8192D("DBG_RX_DROP_FRAME %s wlanhdr_to_ethhdr: drop pkt\n", __func__);
 			#endif
-			rtw_free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue);/* free this recv_frame */
 			goto _recv_data_drop;
 		}
 
 		if ((padapter->bDriverStopped == false) && (padapter->bSurpriseRemoved == false))
 		{
 			RT_TRACE(_module_rtl871x_recv_c_, _drv_alert_, ("@@@@ recv_func: recv_func rtw_recv_indicatepkt\n"));
-			//indicate this recv_frame
+			/* indicate this recv_frame */
 			ret = rtw_recv_indicatepkt(padapter, prframe);
 			if (ret != _SUCCESS)
 			{
@@ -3018,7 +2991,7 @@ int recv_func_posthandle(struct rtw_adap
 				padapter->bDriverStopped, padapter->bSurpriseRemoved);
 			#endif
 			ret = _FAIL;
-			rtw_free_recvframe(orig_prframe, pfree_recv_queue); //free this recv_frame
+			rtw_free_recvframe(orig_prframe, pfree_recv_queue); /* free this recv_frame */
 		}
 
 	}
@@ -3041,7 +3014,7 @@ int recv_func_posthandle(struct rtw_adap
 		#endif
 		goto _recv_data_drop;
 	}
-#endif // CONFIG_80211N_HT
+#endif /*  CONFIG_80211N_HT */
 
 _exit_recv_func:
 	return ret;
@@ -3102,7 +3075,7 @@ s32 rtw_recv_entry(union recv_frame *pre
 
 _func_enter_;
 
-//	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("+rtw_recv_entry\n"));
+/* 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("+rtw_recv_entry\n")); */
 
 	padapter = precvframe->u.hdr.adapter;
 
@@ -3128,7 +3101,7 @@ _recv_entry_drop:
 	padapter->mppriv.rx_pktloss = precvpriv->rx_drop;
 #endif
 
-	//RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("_recv_entry_drop\n"));
+	/* RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("_recv_entry_drop\n")); */
 
 _func_exit_;
 
@@ -3145,28 +3118,28 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 	u8 avg_signal_qual = 0;
 	u32 num_signal_strength = 0;
 	u32 num_signal_qual = 0;
-	u8 _alpha = 3; // this value is based on converging_constant = 5000 and sampling_interval = 1000
+	u8 _alpha = 3; /*  this value is based on converging_constant = 5000 and sampling_interval = 1000 */
 
 	if (adapter->recvpriv.is_signal_dbg) {
-		//update the user specific value, signal_strength_dbg, to signal_strength, rssi
+		/* update the user specific value, signal_strength_dbg, to signal_strength, rssi */
 		adapter->recvpriv.signal_strength= adapter->recvpriv.signal_strength_dbg;
 		adapter->recvpriv.rssi=(s8)translate_percentage_to_dbm((u8)adapter->recvpriv.signal_strength_dbg);
 	} else {
-		if (recvpriv->signal_strength_data.update_req == 0) {// update_req is clear, means we got rx
+		if (recvpriv->signal_strength_data.update_req == 0) {/*  update_req is clear, means we got rx */
 			avg_signal_strength = recvpriv->signal_strength_data.avg_val;
 			num_signal_strength = recvpriv->signal_strength_data.total_num;
-			// after avg_vals are accquired, we can re-stat the signal values
+			/*  after avg_vals are accquired, we can re-stat the signal values */
 			recvpriv->signal_strength_data.update_req = 1;
 		}
 
-		if (recvpriv->signal_qual_data.update_req == 0) {// update_req is clear, means we got rx
+		if (recvpriv->signal_qual_data.update_req == 0) {/*  update_req is clear, means we got rx */
 			avg_signal_qual = recvpriv->signal_qual_data.avg_val;
 			num_signal_qual = recvpriv->signal_qual_data.total_num;
-			// after avg_vals are accquired, we can re-stat the signal values
+			/*  after avg_vals are accquired, we can re-stat the signal values */
 			recvpriv->signal_qual_data.update_req = 1;
 		}
 
-		//update value of signal_strength, rssi, signal_qual
+		/* update value of signal_strength, rssi, signal_qual */
 		if (check_fwstate(&adapter->mlmepriv, _FW_UNDER_SURVEY) == false) {
 			tmp_s = (avg_signal_strength+(_alpha-1)*recvpriv->signal_strength);
 			if (tmp_s %_alpha)
@@ -3203,4 +3176,4 @@ void rtw_signal_stat_timer_hdl(RTW_TIMER
 	}
 	rtw_set_signal_stat_timer(recvpriv);
 }
-#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+#endif /* CONFIG_NEW_SIGNAL_STAT_PROCESS */
--- a/drivers/staging/rtl8192du/core/rtw_security.c
+++ b/drivers/staging/rtl8192du/core/rtw_security.c
@@ -26,7 +26,7 @@
 #include <osdep_intf.h>
 
 
-//=====WEP related=====
+/* WEP related===== */
 
 #define CRC32_POLY 0x04c11db7
 
@@ -161,7 +161,7 @@ _func_exit_;
 	Need to consider the fragment  situation
 */
 void rtw_wep_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe)
-{																	// exclude ICV
+{ /*  exclude ICV */
 
 	unsigned char	crc[4];
 	struct arc4context	 mycontext;
@@ -169,7 +169,7 @@ void rtw_wep_encrypt(struct rtw_adapter
 	int	curfragnum,length;
 	u32	keylength;
 
-	u8	*pframe, *payload,*iv;    //,*wepkey
+	u8	*pframe, *payload,*iv;    /* wepkey */
 	u8	wepkey[16];
 	struct	pkt_attrib	 *pattrib = &((struct xmit_frame*)pxmitframe)->attrib;
 	struct	security_priv	*psecuritypriv=&padapter->securitypriv;
@@ -188,7 +188,7 @@ _func_enter_;
 	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_OFFSET;
 #endif
 
-	//start to encrypt each fragment
+	/* start to encrypt each fragment */
 	if ((pattrib->encrypt==_WEP40_)||(pattrib->encrypt==_WEP104_))
 	{
 		keylength=psecuritypriv->dot11DefKeylen[psecuritypriv->dot11PrivacyKeyIndex];
@@ -201,7 +201,7 @@ _func_enter_;
 			payload=pframe+pattrib->iv_len+pattrib->hdrlen;
 
 			if ((curfragnum+1)==pattrib->nr_frags)
-			{	//the last fragment
+			{	/* the last fragment */
 
 				length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
 
@@ -234,7 +234,7 @@ _func_exit_;
 
 void rtw_wep_decrypt(struct rtw_adapter  *padapter, u8 *precvframe)
 {
-	// exclude ICV
+	/*  exclude ICV */
 	u8	crc[4];
 	struct arc4context	 mycontext;
 	int	length;
@@ -248,25 +248,25 @@ _func_enter_;
 
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 
-	//start to decrypt recvframe
+	/* start to decrypt recvframe */
 	if ((prxattrib->encrypt==_WEP40_)||(prxattrib->encrypt==_WEP104_))
 	{
 		iv=pframe+prxattrib->hdrlen;
-		//keyindex=(iv[3]&0x3);
+		/* keyindex=(iv[3]&0x3); */
 		keyindex = prxattrib->key_index;
 		keylength=psecuritypriv->dot11DefKeylen[keyindex];
 		memcpy(&wepkey[0], iv, 3);
-		//memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength);
+		/* memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength); */
 		memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[keyindex].skey[0],keylength);
 		length= ((union recv_frame *)precvframe)->u.hdr.len-prxattrib->hdrlen-prxattrib->iv_len;
 
 		payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
 
-		//decrypt payload include icv
+		/* decrypt payload include icv */
 		arcfour_init(&mycontext, wepkey,3+keylength);
 		arcfour_encrypt(&mycontext, payload, payload,  length);
 
-		//calculate icv and compare the icv
+		/* calculate icv and compare the icv */
 		*((unsigned long *)crc)=le32_to_cpu(getcrc32(payload,length-4));
 
 		if (crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
@@ -282,10 +282,10 @@ _func_exit_;
 	return;
 }
 
-//3		=====TKIP related=====
+/* 3		=====TKIP related===== */
 
 static u32 secmicgetuint32(u8 * p)
-// Convert from Byte[] to Us4Byte32 in a portable way
+/*  Convert from Byte[] to Us4Byte32 in a portable way */
 {
 	s32 i;
 	u32 res = 0;
@@ -299,7 +299,7 @@ _func_exit_;
 }
 
 static void secmicputuint32(u8 * p, u32 val)
-// Convert from Us4Byte32 to Byte[] in a portable way
+/*  Convert from Us4Byte32 to Byte[] in a portable way */
 {
 	long i;
 _func_enter_;
@@ -313,7 +313,7 @@ _func_exit_;
 
 static void secmicclear(struct mic_data *pmicdata)
 {
-// Reset the state to the empty message.
+/*  Reset the state to the empty message. */
 _func_enter_;
 	pmicdata->L = pmicdata->K0;
 	pmicdata->R = pmicdata->K1;
@@ -324,11 +324,11 @@ _func_exit_;
 
 void rtw_secmicsetkey(struct mic_data *pmicdata, u8 * key)
 {
-	// Set the key
+	/*  Set the key */
 _func_enter_;
 	pmicdata->K0 = secmicgetuint32(key);
 	pmicdata->K1 = secmicgetuint32(key + 4);
-	// and reset the message
+	/*  and reset the message */
 	secmicclear(pmicdata);
 _func_exit_;
 }
@@ -336,10 +336,10 @@ _func_exit_;
 void rtw_secmicappendbyte(struct mic_data *pmicdata, u8 b)
 {
 _func_enter_;
-	// Append the byte to our word-sized buffer
+	/*  Append the byte to our word-sized buffer */
 	pmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);
 	pmicdata->nBytesInM++;
-	// Process the word if it is full.
+	/*  Process the word if it is full. */
 	if (pmicdata->nBytesInM >= 4)
 	{
 		pmicdata->L ^= pmicdata->M;
@@ -351,7 +351,7 @@ _func_enter_;
 		pmicdata->L += pmicdata->R;
 		pmicdata->R ^= ROR32(pmicdata->L, 2);
 		pmicdata->L += pmicdata->R;
-		// Clear the buffer
+		/*  Clear the buffer */
 		pmicdata->M = 0;
 		pmicdata->nBytesInM = 0;
 	}
@@ -361,7 +361,7 @@ _func_exit_;
 void rtw_secmicappend(struct mic_data *pmicdata, u8 * src, u32 nbytes)
 {
 _func_enter_;
-	// This is simple
+	/*  This is simple */
 	while (nbytes > 0)
 	{
 		rtw_secmicappendbyte(pmicdata, *src++);
@@ -373,21 +373,21 @@ _func_exit_;
 void rtw_secgetmic(struct mic_data *pmicdata, u8 * dst)
 {
 _func_enter_;
-	// Append the minimum padding
+	/*  Append the minimum padding */
 	rtw_secmicappendbyte(pmicdata, 0x5a);
 	rtw_secmicappendbyte(pmicdata, 0);
 	rtw_secmicappendbyte(pmicdata, 0);
 	rtw_secmicappendbyte(pmicdata, 0);
 	rtw_secmicappendbyte(pmicdata, 0);
-	// and then zeroes until the length is a multiple of 4
+	/*  and then zeroes until the length is a multiple of 4 */
 	while (pmicdata->nBytesInM != 0)
 	{
 		rtw_secmicappendbyte(pmicdata, 0);
 	}
-	// The appendByte function has already computed the result.
+	/*  The appendByte function has already computed the result. */
 	secmicputuint32(dst, pmicdata->L);
 	secmicputuint32(dst+4, pmicdata->R);
-	// Reset to the empty message.
+	/*  Reset to the empty message. */
 	secmicclear(pmicdata);
 _func_exit_;
 }
@@ -402,16 +402,16 @@ _func_enter_;
 	priority[0]=pri;
 
 	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
-	if (header[1]&1) {   //ToDS==1
-			rtw_secmicappend(&micdata, &header[16], 6);  //DA
-		if (header[1]&2)  //From Ds==1
+	if (header[1]&1) {   /* ToDS==1 */
+			rtw_secmicappend(&micdata, &header[16], 6);  /* DA */
+		if (header[1]&2)  /* From Ds==1 */
 			rtw_secmicappend(&micdata, &header[24], 6);
 		else
 			rtw_secmicappend(&micdata, &header[10], 6);
 	}
-	else {	//ToDS==0
-		rtw_secmicappend(&micdata, &header[4], 6);   //DA
-		if (header[1]&2)  //From Ds==1
+	else {	/* ToDS==0 */
+		rtw_secmicappend(&micdata, &header[4], 6);   /* DA */
+		if (header[1]&2)  /* From Ds==1 */
 			rtw_secmicappend(&micdata, &header[16], 6);
 		else
 			rtw_secmicappend(&micdata, &header[10], 6);
@@ -637,9 +637,9 @@ _func_exit_;
 }
 
 
-//The hlen isn't include the IV
+/* The hlen isn't include the IV */
 u32	rtw_tkip_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe)
-{																	// exclude ICV
+{																	/*  exclude ICV */
 	u16	pnl;
 	u32	pnh;
 	u8	rc4key[16];
@@ -668,7 +668,7 @@ _func_enter_;
 	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_OFFSET;
 #endif
 
-	//4 start to encrypt each fragment
+	/* 4 start to encrypt each fragment */
 	if (pattrib->encrypt==_TKIP_) {
 		if (pattrib->psta)
 		{
@@ -706,7 +706,7 @@ _func_enter_;
 
 				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);
 
-				if ((curfragnum+1)==pattrib->nr_frags) {	//4 the last fragment
+				if ((curfragnum+1)==pattrib->nr_frags) {	/* 4 the last fragment */
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
 					RT_TRACE(_module_rtl871x_security_c_,_drv_info_,("pattrib->iv_len =%x, pattrib->icv_len =%x\n", pattrib->iv_len,pattrib->icv_len));
 					*((u32 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
@@ -742,9 +742,9 @@ _func_exit_;
 }
 
 
-//The hlen isn't include the IV
+/* The hlen isn't include the IV */
 u32 rtw_tkip_decrypt(struct rtw_adapter *padapter, u8 *precvframe)
-{																	// exclude ICV
+{																	/*  exclude ICV */
 	u16 pnl;
 	u32 pnh;
 	u8   rc4key[16];
@@ -759,14 +759,14 @@ u32 rtw_tkip_decrypt(struct rtw_adapter
 	struct	sta_info		*stainfo;
 	struct	rx_pkt_attrib	 *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
 	struct	security_priv	*psecuritypriv=&padapter->securitypriv;
-//	struct	recv_priv		*precvpriv=&padapter->recvpriv;
+/* 	struct	recv_priv		*precvpriv=&padapter->recvpriv; */
 	u32		res=_SUCCESS;
 
 _func_enter_;
 
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
 
-	//4 start to decrypt recvframe
+	/* 4 start to decrypt recvframe */
 	if (prxattrib->encrypt==_TKIP_) {
 		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0]);
 		if (stainfo!=NULL) {
@@ -778,8 +778,8 @@ _func_enter_;
 					DBG_8192D("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__func__);
 					goto exit;
 				}
-				//DBG_8192D("rx bc/mc packets, to perform sw rtw_tkip_decrypt\n");
-				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
+				/* DBG_8192D("rx bc/mc packets, to perform sw rtw_tkip_decrypt\n"); */
+				/* prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey; */
 				prwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;
 				prwskeylen=16;
 			}
@@ -802,7 +802,7 @@ _func_enter_;
 			phase1((u16 *)&ttkey[0],prwskey,&prxattrib->ta[0],pnh);
 			phase2(&rc4key[0],prwskey,(unsigned short *)&ttkey[0],pnl);
 
-			//4 decrypt payload include icv
+			/* 4 decrypt payload include icv */
 
 			arcfour_init(&mycontext, rc4key,16);
 			arcfour_encrypt(&mycontext, payload, payload, length);
@@ -830,7 +830,7 @@ exit:
 }
 
 
-//3			=====AES related=====
+/* 3			=====AES related===== */
 
 
 
@@ -1206,7 +1206,6 @@ _func_enter_;
     mic_header2[4] = mpdu[20];
     mic_header2[5] = mpdu[21];
 
-    //mic_header2[6] = mpdu[22] & 0xf0;   /* SC */
     mic_header2[6] = 0x00;
     mic_header2[7] = 0x00; /* mpdu[23]; */
 
@@ -1294,7 +1293,6 @@ _func_exit_;
 static int aes_cipher(u8 *key, uint	hdrlen,
 			u8 *pframe, uint plen)
 {
-//	/*static*/ unsigned char	message[MAX_MSG_SIZE];
 	uint	qc_exists, a4_exists, i, j, payload_remainder,
 		num_blocks, payload_index;
 
@@ -1309,7 +1307,7 @@ static int aes_cipher(u8 *key, uint	hdrl
 	u8 aes_out[16];
 	u8 padded_buffer[16];
 	u8 mic[8];
-//	uint	offset = 0;
+/* 	uint	offset = 0; */
 	uint	frtype  = GetFrameType(pframe);
 	uint	frsubtype  = GetFrameSubType(pframe);
 
@@ -1365,7 +1363,7 @@ _func_enter_;
                         mic_iv,
                         qc_exists,
                         a4_exists,
-                        pframe,	 //message,
+                        pframe,	 /* message, */
                         plen,
                         pn_vector
                        );
@@ -1373,11 +1371,11 @@ _func_enter_;
     construct_mic_header1(
                             mic_header1,
                             hdrlen,
-                            pframe	//message
+                            pframe	/* message */
                            );
     construct_mic_header2(
                             mic_header2,
-                            pframe,	//message,
+                            pframe,	/* message, */
                             a4_exists,
                             qc_exists
                            );
@@ -1398,7 +1396,7 @@ _func_enter_;
 
 	for (i = 0; i < num_blocks; i++)
     {
-        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);//bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);/* bitwise_xor(aes_out, &message[payload_index], chain_buffer); */
 
         payload_index += 16;
         aes128k128d(key, chain_buffer, aes_out);
@@ -1410,7 +1408,7 @@ _func_enter_;
         for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
         for (j = 0; j < payload_remainder; j++)
         {
-            padded_buffer[j] = pframe[payload_index++];//padded_buffer[j] = message[payload_index++];
+            padded_buffer[j] = pframe[payload_index++];/* padded_buffer[j] = message[payload_index++]; */
         }
         bitwise_xor(aes_out, padded_buffer, chain_buffer);
         aes128k128d(key, chain_buffer, aes_out);
@@ -1421,7 +1419,7 @@ _func_enter_;
 
     /* Insert MIC into payload */
     for (j = 0; j < 8; j++)
-	pframe[payload_index+j] = mic[j];	//message[payload_index+j] = mic[j];
+	pframe[payload_index+j] = mic[j];	/* message[payload_index+j] = mic[j]; */
 
 	payload_index = hdrlen + 8;
 	for (i=0; i< num_blocks; i++)
@@ -1430,12 +1428,12 @@ _func_enter_;
                                 ctr_preload,
                                 a4_exists,
                                 qc_exists,
-                                pframe,	//message,
+                                pframe,	/* message, */
                                 pn_vector,
                                 i+1);
         aes128k128d(key, ctr_preload, aes_out);
-        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);//bitwise_xor(aes_out, &message[payload_index], chain_buffer);
-        for (j=0; j<16;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<16;j++) message[payload_index++] = chain_buffer[j];
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);/* bitwise_xor(aes_out, &message[payload_index], chain_buffer); */
+        for (j=0; j<16;j++) pframe[payload_index++] = chain_buffer[j];/* for (j=0; j<16;j++) message[payload_index++] = chain_buffer[j]; */
     }
 
     if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
@@ -1444,18 +1442,18 @@ _func_enter_;
                                 ctr_preload,
                                 a4_exists,
                                 qc_exists,
-                                pframe,	//message,
+                                pframe,	/* message, */
                                 pn_vector,
                                 num_blocks+1);
 
         for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
         for (j = 0; j < payload_remainder; j++)
         {
-            padded_buffer[j] = pframe[payload_index+j];//padded_buffer[j] = message[payload_index+j];
+            padded_buffer[j] = pframe[payload_index+j];/* padded_buffer[j] = message[payload_index+j]; */
         }
         aes128k128d(key, ctr_preload, aes_out);
         bitwise_xor(aes_out, padded_buffer, chain_buffer);
-        for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<payload_remainder;j++) message[payload_index++] = chain_buffer[j];
+        for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];/* for (j=0; j<payload_remainder;j++) message[payload_index++] = chain_buffer[j]; */
     }
 
     /* Encrypt the MIC */
@@ -1463,19 +1461,19 @@ _func_enter_;
                         ctr_preload,
                         a4_exists,
                         qc_exists,
-                        pframe,	//message,
+                        pframe,	/* message, */
                         pn_vector,
                         0);
 
     for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
     for (j = 0; j < 8; j++)
     {
-        padded_buffer[j] = pframe[j+hdrlen+8+plen];//padded_buffer[j] = message[j+hdrlen+8+plen];
+        padded_buffer[j] = pframe[j+hdrlen+8+plen];/* padded_buffer[j] = message[j+hdrlen+8+plen]; */
     }
 
     aes128k128d(key, ctr_preload, aes_out);
     bitwise_xor(aes_out, padded_buffer, chain_buffer);
-    for (j=0; j<8;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
+    for (j=0; j<8;j++) pframe[payload_index++] = chain_buffer[j];/* for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j]; */
 _func_exit_;
 	return _SUCCESS;
 }
@@ -1484,22 +1482,21 @@ _func_exit_;
 
 
 u32	rtw_aes_encrypt(struct rtw_adapter *padapter, u8 *pxmitframe)
-{	// exclude ICV
+{	/*  exclude ICV */
 
 
 	/*static*/
-//	unsigned char	message[MAX_MSG_SIZE];
 
 	/* Intermediate Buffers */
 	int	curfragnum,length;
 	u32	prwskeylen;
-	u8	*pframe,*prwskey;	//, *payload,*iv
+	u8	*pframe,*prwskey;	/*  *payload,*iv */
 	struct	sta_info		*stainfo;
 	struct	pkt_attrib	 *pattrib = &((struct xmit_frame *)pxmitframe)->attrib;
 	struct	security_priv	*psecuritypriv=&padapter->securitypriv;
 	struct	xmit_priv		*pxmitpriv=&padapter->xmitpriv;
 
-//	uint	offset = 0;
+/* 	uint	offset = 0; */
 	u32 res=_SUCCESS;
 _func_enter_;
 
@@ -1513,7 +1510,7 @@ _func_enter_;
 	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + TXDESC_OFFSET;
 #endif
 
-	//4 start to encrypt each fragment
+	/* 4 start to encrypt each fragment */
 	if ((pattrib->encrypt==_AES_)) {
 		if (pattrib->psta)
 		{
@@ -1536,7 +1533,7 @@ _func_enter_;
 				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
 			}
 
-#ifdef CONFIG_TDLS	//swencryption
+#ifdef CONFIG_TDLS	/* swencryption */
 			{
 				struct	sta_info		*ptdls_sta;
 				ptdls_sta=rtw_get_stainfo(&padapter->stapriv ,&pattrib->dst[0]);
@@ -1546,12 +1543,12 @@ _func_enter_;
 					prwskey=&ptdls_sta->tpk.tk[0];
 				}
 			}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 			prwskeylen=16;
 
 			for (curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++) {
-				if ((curfragnum+1)==pattrib->nr_frags) {	//4 the last fragment
+				if ((curfragnum+1)==pattrib->nr_frags) {	/* 4 the last fragment */
 					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
 
 					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
@@ -1599,9 +1596,6 @@ static int aes_decipher(u8 *key, uint	hd
 	u8 aes_out[16];
 	u8 padded_buffer[16];
 	u8 mic[8];
-
-
-//	uint	offset = 0;
 	uint	frtype  = GetFrameType(pframe);
 	uint	frsubtype  = GetFrameSubType(pframe);
 _func_enter_;
@@ -1616,9 +1610,9 @@ _func_enter_;
 	memset((void *)aes_out, 0, 16);
 	memset((void *)padded_buffer, 0, 16);
 
-	//start to decrypt the payload
+	/* start to decrypt the payload */
 
-	num_blocks = (plen-8) / 16; //(plen including llc, payload_length and mic)
+	num_blocks = (plen-8) / 16; /* plen including llc, payload_length and mic) */
 
 	payload_remainder = (plen-8) % 16;
 
@@ -1659,9 +1653,9 @@ _func_enter_;
 		qc_exists = 0;
 
 
-	// now, decrypt pframe with hdrlen offset and plen long
+	/*  now, decrypt pframe with hdrlen offset and plen long */
 
-	payload_index = hdrlen + 8; // 8 is for extiv
+	payload_index = hdrlen + 8; /*  8 is for extiv */
 
 	for (i=0; i< num_blocks; i++)
     {
@@ -1701,9 +1695,9 @@ _func_enter_;
         for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];
     }
 
-	//start to calculate the mic
+	/* start to calculate the mic */
 
-	memcpy((void *)message, pframe, (hdrlen +plen+8)); //8 is for ext iv len
+	memcpy((void *)message, pframe, (hdrlen +plen+8)); /* 8 is for ext iv len */
 
 
 	pn_vector[0]=pframe[hdrlen];
@@ -1831,7 +1825,7 @@ _func_enter_;
     bitwise_xor(aes_out, padded_buffer, chain_buffer);
     for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
 
-	//compare the mic
+	/* compare the mic */
 	for (i=0;i<8;i++) {
 		if (pframe[hdrlen+8+plen-8+i] != message[hdrlen+8+plen-8+i])
 		{
@@ -1856,36 +1850,28 @@ _func_exit_;
 }
 
 u32	rtw_aes_decrypt(struct rtw_adapter *padapter, u8 *precvframe)
-{	// exclude ICV
-
-
-	/*static*/
-//	unsigned char	message[MAX_MSG_SIZE];
-
+{	/*  exclude ICV */
 
 	/* Intermediate Buffers */
 
 
 	int	length;
-	u8	*pframe,*prwskey;	//, *payload,*iv
+	u8	*pframe,*prwskey;	/*  *payload,*iv */
 	struct	sta_info		*stainfo;
 	struct	rx_pkt_attrib	 *prxattrib = &((union recv_frame *)precvframe)->u.hdr.attrib;
 	struct	security_priv	*psecuritypriv=&padapter->securitypriv;
-//	struct	recv_priv		*precvpriv=&padapter->recvpriv;
+/* 	struct	recv_priv		*precvpriv=&padapter->recvpriv; */
 	u32	res=_SUCCESS;
 _func_enter_;
 	pframe=(unsigned char *)((union recv_frame*)precvframe)->u.hdr.rx_data;
-	//4 start to encrypt each fragment
+	/* 4 start to encrypt each fragment */
 	if ((prxattrib->encrypt==_AES_)) {
 		stainfo=rtw_get_stainfo(&padapter->stapriv ,&prxattrib->ta[0]);
 		if (stainfo!=NULL) {
 			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_decrypt: stainfo!=NULL!!!\n"));
 
-			if (IS_MCAST(prxattrib->ra))
-			{
-				//in concurrent we should use sw descrypt in group key, so we remove this message
-				//DBG_8192D("rx bc/mc packets, to perform sw rtw_aes_decrypt\n");
-				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
+			if (IS_MCAST(prxattrib->ra)) {
+				/* in concurrent we should use sw descrypt in group key, so we remove this message */
 				if (psecuritypriv->binstallGrpkey==false) {
 					res=_FAIL;
 					DBG_8192D("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__func__);
@@ -2783,15 +2769,15 @@ int tdls_verify_mic(u8 *kck, u8 trans_se
 	rx_ftie = ftie+4;
 
 	if (os_memcmp(mic, rx_ftie, 16) == 0) {
-		//Valid MIC
+		/* Valid MIC */
 		return 1;
 	}
 
-	//Invalid MIC
+	/* Invalid MIC */
 	DBG_8192D("[%s] Invalid MIC\n", __func__);
 	return 0;
 }
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 void rtw_use_tkipkey_handler(void *FunctionContext)
 {
--- a/drivers/staging/rtl8192du/core/rtw_sreset.c
+++ b/drivers/staging/rtl8192du/core/rtw_sreset.c
@@ -70,7 +70,7 @@ u8 sreset_get_wifi_status(_adapter *pada
 	}
 	DBG_8192C("==> %s wifi_status(0x%x)\n",__func__,status);
 
-	//status restore
+	/* status restore */
 	psrtpriv->Wifi_Error_Status = WIFI_STATUS_SUCCESS;
 
 	return status;
--- a/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
+++ b/drivers/staging/rtl8192du/core/rtw_sta_mgt.c
@@ -69,7 +69,7 @@ _func_enter_;
 
 	psta->under_exist_checking = 0;
 	psta->keep_alive_trycnt = 0;
-#endif	// CONFIG_AP_MODE
+#endif	/*  CONFIG_AP_MODE */
 
 _func_exit_;
 }
@@ -124,14 +124,12 @@ _func_enter_;
 	pstapriv->asoc_list_cnt = 0;
 	pstapriv->auth_list_cnt = 0;
 
-	pstapriv->auth_to = 3; // 3*2 = 6 sec
+	pstapriv->auth_to = 3; /*  3*2 = 6 sec */
 	pstapriv->assoc_to = 3;
-	//pstapriv->expire_to = 900;// 900*2 = 1800 sec = 30 min, expire after no any traffic.
-	//pstapriv->expire_to = 30;// 30*2 = 60 sec = 1 min, expire after no any traffic.
 #ifdef CONFIG_ACTIVE_KEEP_ALIVE_CHECK
-	pstapriv->expire_to = 3; // 3*2 = 6 sec
+	pstapriv->expire_to = 3; /*  3*2 = 6 sec */
 #else
-	pstapriv->expire_to = 60;// 60*2 = 120 sec = 2 min, expire after no any traffic.
+	pstapriv->expire_to = 60;/*  60*2 = 120 sec = 2 min, expire after no any traffic. */
 #endif
 	pstapriv->max_num_sta = NUM_STA;
 
@@ -199,7 +197,7 @@ _func_exit_;
 }
 
 
-// this function is used to free the memory of lock || sema for all stainfos
+/*  this function is used to free the memory of lock || sema for all stainfos */
 void rtw_mfree_all_stainfo(struct sta_priv *pstapriv)
 {
 	struct list_head *plist, *phead;
@@ -231,7 +229,7 @@ void rtw_mfree_sta_priv_lock(struct	sta_
 	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
 #endif
 
-	 rtw_mfree_all_stainfo(pstapriv); //be done before free sta_hash_lock
+	 rtw_mfree_all_stainfo(pstapriv); /* be done before free sta_hash_lock */
 
 	_rtw_spinlock_free(&pstapriv->free_sta_queue.lock);
 
@@ -290,7 +288,7 @@ _func_exit_;
 }
 
 
-//struct	sta_info *rtw_alloc_stainfo(_queue *pfree_sta_queue, unsigned char *hwaddr)
+/* struct	sta_info *rtw_alloc_stainfo(_queue *pfree_sta_queue, unsigned char *hwaddr) */
 struct	sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, u8 *hwaddr)
 {
 	uint tmp_aid;
@@ -346,10 +344,10 @@ _func_enter_;
 
 		spin_unlock_bh(&(pstapriv->sta_hash_lock));
 
-// Commented by Albert 2009/08/13
-// For the SMC router, the sequence number of first packet of WPS handshake will be 0.
-// In this case, this packet will be dropped by recv_decache function if we use the 0x00 as the default value for tid_rxseq variable.
-// So, we initialize the tid_rxseq variable as the 0xffff.
+/*  Commented by Albert 2009/08/13 */
+/*  For the SMC router, the sequence number of first packet of WPS handshake will be 0. */
+/*  In this case, this packet will be dropped by recv_decache function if we use the 0x00 as the default value for tid_rxseq variable. */
+/*  So, we initialize the tid_rxseq variable as the 0xffff. */
 
 		for (i = 0; i < 16; i++)
                      memcpy(&psta->sta_recvpriv.rxcache.tid_rxseq[ i ], &wRxSeqInitialValue, 2);
@@ -367,9 +365,9 @@ _func_enter_;
 		init_off_ch_timer(pstapriv->padapter, psta);
 		init_handshake_timer(pstapriv->padapter, psta);
 		init_tdls_alive_timer(pstapriv->padapter, psta);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
-		//for A-MPDU Rx reordering buffer control
+		/* for A-MPDU Rx reordering buffer control */
 		for (i=0; i < 16 ; i++)
 		{
 			preorder_ctrl = &psta->recvreorder_ctrl[i];
@@ -384,8 +382,8 @@ _func_enter_;
 				preorder_ctrl->indicate_seq);
 			#endif
 			preorder_ctrl->wend_b= 0xffff;
-			//preorder_ctrl->wsize_b = (NR_RECVBUFF-2);
-			preorder_ctrl->wsize_b = 64;//64;
+			/* preorder_ctrl->wsize_b = (NR_RECVBUFF-2); */
+			preorder_ctrl->wsize_b = 64;/* 64; */
 
 			_rtw_init_queue(&preorder_ctrl->pending_recvframe_queue);
 
@@ -393,7 +391,7 @@ _func_enter_;
 		}
 
 
-		//init for DM
+		/* init for DM */
 		psta->rssi_stat.UndecoratedSmoothedPWDB = 0;
 		psta->rssi_stat.UndecoratedSmoothedCCK = (-1);
 
@@ -410,7 +408,7 @@ _func_exit_;
 }
 
 
-// using pstapriv->sta_hash_lock to protect
+/*  using pstapriv->sta_hash_lock to protect */
 u32	rtw_free_stainfo(struct rtw_adapter *padapter , struct sta_info *psta)
 {
 	int i;
@@ -459,7 +457,7 @@ _func_enter_;
 	pstapriv->asoc_sta_count --;
 
 
-	// re-init sta_info; 20061114
+	/*  re-init sta_info; 20061114 */
 	_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
 	_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
 
@@ -472,9 +470,9 @@ _func_enter_;
 	_cancel_timer_ex(&psta->off_ch_timer);
 	_cancel_timer_ex(&psta->alive_timer1);
 	_cancel_timer_ex(&psta->alive_timer2);
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
-	//for A-MPDU Rx reordering buffer control, cancel reordering_ctrl_timer
+	/* for A-MPDU Rx reordering buffer control, cancel reordering_ctrl_timer */
 	for (i=0; i < 16 ; i++)
 	{
 		struct list_head *phead, *plist;
@@ -537,7 +535,7 @@ _func_enter_;
 	pstapriv->sta_dz_bitmap &=~BIT(psta->aid);
 	pstapriv->tim_bitmap &=~BIT(psta->aid);
 
-	//rtw_indicate_sta_disassoc_event(padapter, psta);
+	/* rtw_indicate_sta_disassoc_event(padapter, psta); */
 
 	if ((psta->aid >0)&&(pstapriv->sta_aid[psta->aid - 1] == psta))
 	{
@@ -545,11 +543,11 @@ _func_enter_;
 		psta->aid = 0;
 	}
 
-#endif	// CONFIG_NATIVEAP_MLME
+#endif	/*  CONFIG_NATIVEAP_MLME */
 
 	psta->under_exist_checking = 0;
 
-#endif	// CONFIG_AP_MODE
+#endif	/*  CONFIG_AP_MODE */
 
 	spin_lock_bh(&(pfree_sta_queue->lock));
 	rtw_list_insert_tail(&psta->list, get_list_head(pfree_sta_queue));
@@ -562,7 +560,7 @@ _func_exit_;
 	return _SUCCESS;
 }
 
-// free all stainfo which in sta_hash[all]
+/*  free all stainfo which in sta_hash[all] */
 void rtw_free_all_stainfo(struct rtw_adapter *padapter)
 {
 	struct list_head *plist, *phead;
@@ -634,7 +632,7 @@ _func_enter_;
 		psta = LIST_CONTAINOR(plist, struct sta_info, hash_list);
 
 		if ((_rtw_memcmp(psta->hwaddr, addr, ETH_ALEN))== true)
-		{ // if found the matched address
+		{ /*  if found the matched address */
 			break;
 		}
 		psta=NULL;
@@ -665,7 +663,7 @@ _func_enter_;
 		goto exit;
 	}
 
-	// default broadcast & multicast use macid 1
+	/*  default broadcast & multicast use macid 1 */
 	psta->mac_id = 1;
 
 	ptxservq= &(psta->sta_xmitpriv.be_q);
@@ -718,9 +716,9 @@ u8 rtw_access_ctrl(struct rtw_adapter *p
 	spin_unlock_bh(&(pacl_node_q->lock));
 
 
-	if (pacl_list->mode == 1)//accept unless in deny list
+	if (pacl_list->mode == 1)/* accept unless in deny list */
 		res = (match == true) ?  false:true;
-	else if (pacl_list->mode == 2)//deny unless in accept list
+	else if (pacl_list->mode == 2)/* deny unless in accept list */
 		res = (match == true) ?  true:false;
 	else
 		 res = true;
--- a/drivers/staging/rtl8192du/core/rtw_tdls.c
+++ b/drivers/staging/rtl8192du/core/rtw_tdls.c
@@ -42,13 +42,13 @@ void rtw_reset_tdls_info(_adapter* padap
 	ptdlsinfo->clear_cam= 0;
 	ptdlsinfo->ch_sensing = 0;
 	ptdlsinfo->cur_channel = 0;
-	ptdlsinfo->candidate_ch = 1;	//when inplement channel switching, default candidate channel is 1
+	ptdlsinfo->candidate_ch = 1;	/* when inplement channel switching, default candidate channel is 1 */
 	ptdlsinfo->watchdog_count = 0;
 	ptdlsinfo->dev_discovered = 0;
 
 #ifdef CONFIG_WFD
 	ptdlsinfo->wfd_info = &padapter->wfd_info;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 }
 
 int rtw_init_tdls_info(_adapter* padapter)
@@ -89,7 +89,7 @@ void issue_nulldata_to_TDLS_peer_STA(_ad
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -100,7 +100,7 @@ void issue_nulldata_to_TDLS_peer_STA(_ad
 
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
-//	SetToDs(fctrl);
+/* 	SetToDs(fctrl); */
 	if (power_mode)
 	{
 		SetPwrMgt(fctrl);
@@ -150,11 +150,11 @@ s32 update_tdls_attrib(_adapter *padapte
 	pattrib->psta = psta;
 
 	pattrib->ack_policy = 0;
-	// get ether_hdr_len
-	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4): 14; //vlan tag
+	/*  get ether_hdr_len */
+	pattrib->pkt_hdrlen = ETH_HLEN;/* pattrib->ether_type == 0x8100) ? (14 + 4): 14; vlan tag */
 
 	if (pqospriv->qos_option &&  psta->qos_option) {
-		pattrib->priority = 1;	//tdls management frame should be AC_BK
+		pattrib->priority = 1;	/* tdls management frame should be AC_BK */
 		pattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;
 		pattrib->subtype = WIFI_QOS_DATA_TYPE;
 	} else {
@@ -163,16 +163,12 @@ s32 update_tdls_attrib(_adapter *padapte
 		pattrib->priority = 0;
 	}
 
-	if (psta->ieee8021x_blocked == true)
-	{
+	if (psta->ieee8021x_blocked == true) {
 		pattrib->encrypt = 0;
-	}
-	else
-	{
+	} else {
 		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
 
-		switch (psecuritypriv->dot11AuthAlgrthm)
-		{
+		switch (psecuritypriv->dot11AuthAlgrthm) {
 			case dot11AuthAlgrthm_Open:
 			case dot11AuthAlgrthm_Shared:
 			case dot11AuthAlgrthm_Auto:
@@ -221,7 +217,7 @@ s32 update_tdls_attrib(_adapter *padapte
 		pattrib->bswenc = false;
 	}
 
-	//qos_en, ht_en, init rate, ,bw, ch_offset, sgi
+	/* qos_en, ht_en, init rate, ,bw, ch_offset, sgi */
 	pattrib->qos_en = psta->qos_option;
 	pattrib->ht_en = psta->htpriv.ht_option;
 	pattrib->raid = psta->raid;
@@ -230,11 +226,11 @@ s32 update_tdls_attrib(_adapter *padapte
 	pattrib->sgi= psta->htpriv.sgi;
 	pattrib->ampdu_en = false;
 
-	//if (pattrib->ht_en && psta->htpriv.ampdu_enable)
-	//{
-	//	if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
-	//		pattrib->ampdu_en = true;
-	//}
+	/* if (pattrib->ht_en && psta->htpriv.ampdu_enable) */
+	/*  */
+	/* 	if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority)) */
+	/* 		pattrib->ampdu_en = true; */
+	/*  */
 
 exit:
 
@@ -246,17 +242,17 @@ void free_tdls_sta(_adapter *padapter, s
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
 	struct sta_priv *pstapriv = &padapter->stapriv;
 
-	//free peer sta_info
+	/* free peer sta_info */
 	spin_lock_bh(&(pstapriv->sta_hash_lock));
 	if (ptdlsinfo->sta_cnt != 0)
 		ptdlsinfo->sta_cnt--;
 	spin_unlock_bh(&(pstapriv->sta_hash_lock));
-	if (ptdlsinfo->sta_cnt < (NUM_STA - 2))	// -2: AP + BC/MC sta
+	if (ptdlsinfo->sta_cnt < (NUM_STA - 2))	/*  -2: AP + BC/MC sta */
 	{
 		ptdlsinfo->sta_maximum = false;
 		memset(&ptdlsinfo->ss_record, 0x00, sizeof(struct tdls_ss_record));
 	}
-	//ready to clear cam
+	/* ready to clear cam */
 	if (ptdls_sta->mac_id!=0) {
 		ptdlsinfo->clear_cam=ptdls_sta->mac_id;
 		rtw_setstakey_cmd(padapter, (u8 *)ptdls_sta, true);
@@ -272,7 +268,7 @@ void free_tdls_sta(_adapter *padapter, s
 	rtw_free_stainfo(padapter,  ptdls_sta);
 }
 
-// cam entry will be the same as mac_id
+/*  cam entry will be the same as mac_id */
 void rtw_tdls_set_mac_id(struct tdls_info *ptdlsinfo, struct sta_info *ptdls_sta)
 {
 	if (ptdls_sta->mac_id==0)
@@ -283,7 +279,7 @@ void rtw_tdls_set_mac_id(struct tdls_inf
 	}
 }
 
-//TDLS encryption(if needed) will always be CCMP
+/* TDLS encryption(if needed) will always be CCMP */
 void rtw_tdls_set_key(_adapter *adapter, struct rx_pkt_attrib *prx_pkt_attrib, struct sta_info *ptdls_sta)
 {
 	if (prx_pkt_attrib->encrypt)
@@ -321,20 +317,20 @@ void rtw_tdls_process_ht_cap(_adapter *a
 		}
 	}
 
-	//HT related cap
+	/* HT related cap */
 	if (ptdls_sta->htpriv.ht_option)
 	{
-		//check if sta supports rx ampdu
+		/* check if sta supports rx ampdu */
 		if (adapter->registrypriv.ampdu_enable==1)
 			ptdls_sta->htpriv.ampdu_enable = true;
 
-		//check if sta support s Short GI
+		/* check if sta support s Short GI */
 		if (ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40))
 		{
 			ptdls_sta->htpriv.sgi = true;
 		}
 
-		// bwmode would still followed AP's setting
+		/*  bwmode would still followed AP's setting */
 		if (ptdls_sta->htpriv.ht_cap.cap_info & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH))
 		{
 			ptdls_sta->htpriv.bwmode = adapter->mlmeextpriv.cur_bwmode;
@@ -348,7 +344,7 @@ u8 *rtw_tdls_set_ht_cap(_adapter *padapt
 	struct rtw_ieee80211_ht_cap ht_capie;
 	u8 rf_type;
 
-	//HT capabilities
+	/* HT capabilities */
 	memset(&ht_capie, 0, sizeof(struct rtw_ieee80211_ht_cap));
 
 	ht_capie.cap_info = IEEE80211_HT_CAP_SUP_WIDTH |IEEE80211_HT_CAP_SGI_20 |IEEE80211_HT_CAP_SM_PS |
@@ -368,14 +364,14 @@ u8 *rtw_tdls_set_ht_cap(_adapter *padapt
 	switch (rf_type)
 	{
 		case RF_1T1R:
-			ht_capie.cap_info |= 0x0100;//RX STBC One spatial stream
+			ht_capie.cap_info |= 0x0100;/* RX STBC One spatial stream */
 			memcpy(ht_capie.supp_mcs_set, MCS_rate_1R, 16);
 			break;
 
 		case RF_2T2R:
 		case RF_1T2R:
 		default:
-			ht_capie.cap_info|= 0x0200;//RX STBC two spatial stream
+			ht_capie.cap_info|= 0x0200;/* RX STBC two spatial stream */
 			memcpy(ht_capie.supp_mcs_set, MCS_rate_2R, 16);
 			break;
 	}
@@ -386,12 +382,12 @@ u8 *rtw_tdls_set_ht_cap(_adapter *padapt
 
 u8 *rtw_tdls_set_sup_ch(struct mlme_ext_priv *pmlmeext, u8 *pframe, struct pkt_attrib *pattrib)
 {
-	u8 sup_ch[ 30 * 2 ] = { 0x00 }, sup_ch_idx = 0, idx_5g = 2;	//For supported channel
+	u8 sup_ch[ 30 * 2 ] = { 0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
 	do{
 		if (pmlmeext->channel_set[sup_ch_idx].ChannelNum <= 14)
 		{
-			sup_ch[0] = 1;	//First channel number
-			sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	//Number of channel
+			sup_ch[0] = 1;	/* First channel number */
+			sup_ch[1] = pmlmeext->channel_set[sup_ch_idx].ChannelNum;	/* Number of channel */
 		}
 		else
 		{
@@ -411,8 +407,8 @@ void rtw_tdls_process_wfd_ie(struct tdls
 	u8	wfd_ie[ 128 ] = { 0x00 };
 	u32	wfd_ielen = 0;
 	u32	wfd_offset = 0;
-	//	Try to get the TCP port information when receiving the negotiation response.
-	//
+	/* 	Try to get the TCP port information when receiving the negotiation response. */
+	/*  */
 
 	wfd_offset = 0;
 	wfd_offset = rtw_get_wfd_ie(ptr + wfd_offset, length - wfd_offset, wfd_ie, &wfd_ielen);
@@ -460,7 +456,7 @@ void issue_tunneled_probe_req(_adapter *
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -503,7 +499,7 @@ void issue_tunneled_probe_rsp(_adapter *
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -530,7 +526,7 @@ exit:
 
 	return;
 }
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 void issue_tdls_setup_req(_adapter *padapter, u8 *mac_addr)
 {
@@ -542,7 +538,7 @@ void issue_tdls_setup_req(_adapter *pada
 	struct sta_priv *pstapriv = &padapter->stapriv;
 	struct sta_info *ptdls_sta= NULL;
 	static u8 dialogtoken = 0;
-	u32 timeout_interval= TPK_RESEND_COUNT * 1000;	//retry timer should set at least 301 sec, using TPK_count counting 301 times.
+	u32 timeout_interval= TPK_RESEND_COUNT * 1000;	/* retry timer should set at least 301 sec, using TPK_count counting 301 times. */
 
 	if (ptdlsinfo->ap_prohibited == true)
 		goto exit;
@@ -552,7 +548,7 @@ void issue_tdls_setup_req(_adapter *pada
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -567,7 +563,7 @@ void issue_tdls_setup_req(_adapter *pada
 
 	update_tdls_attrib(padapter, pattrib);
 
-	//init peer sta_info
+	/* init peer sta_info */
 	ptdls_sta = rtw_get_stainfo(pstapriv, mac_addr);
 	if (ptdls_sta==NULL)
 	{
@@ -578,7 +574,7 @@ void issue_tdls_setup_req(_adapter *pada
 			if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 				ptdlsinfo->sta_cnt++;
 			spin_unlock_bh(&(pstapriv->sta_hash_lock));
-			if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	// -2: AP + BC/MC sta
+			if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	/*  -2: AP + BC/MC sta */
 			{
 				ptdlsinfo->sta_maximum  = true;
 			}
@@ -593,7 +589,7 @@ void issue_tdls_setup_req(_adapter *pada
 
 	if (ptdls_sta) {
 		ptdls_sta->tdls_sta_state |= TDLS_RESPONDER_STATE;
-		//for tdls; ptdls_sta->aid is used to fill dialogtoken
+		/* for tdls; ptdls_sta->aid is used to fill dialogtoken */
 		ptdls_sta->dialog = dialogtoken;
 		dialogtoken = (dialogtoken+1)%256;
 		ptdls_sta->TDLS_PeerKey_Lifetime = timeout_interval;
@@ -635,7 +631,7 @@ void issue_tdls_teardown(_adapter *padap
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -689,7 +685,7 @@ void issue_tdls_dis_req(_adapter *padapt
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -735,7 +731,7 @@ void issue_tdls_setup_rsp(_adapter *pada
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -777,7 +773,7 @@ void issue_tdls_setup_cfm(_adapter *pada
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -805,7 +801,7 @@ exit:
 	return;
 }
 
-//TDLS Discovery Response frame is a management action frame
+/* TDLS Discovery Response frame is a management action frame */
 void issue_tdls_dis_rsp(_adapter *padapter, union recv_frame *precv_frame, u8 dialog)
 {
 	struct xmit_frame		*pmgntframe;
@@ -823,7 +819,7 @@ void issue_tdls_dis_rsp(_adapter *padapt
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 	update_mgntframe_attrib(padapter, pattrib);
 
@@ -835,7 +831,7 @@ void issue_tdls_dis_rsp(_adapter *padapt
 	fctrl = &(pwlanhdr->frame_ctl);
 	*(fctrl) = 0;
 
-	//	unicast probe request frame
+	/* 	unicast probe request frame */
 	memcpy(pwlanhdr->addr1, rx_pkt_pattrib->src, ETH_ALEN);
 	memcpy(pattrib->dst, pwlanhdr->addr1, ETH_ALEN);
 
@@ -876,7 +872,7 @@ void issue_tdls_peer_traffic_indication(
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -889,10 +885,10 @@ void issue_tdls_peer_traffic_indication(
 	memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
 	memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
 
-	//for tdls; pattrib->nr_frags is used to fill dialogtoken
+	/* for tdls; pattrib->nr_frags is used to fill dialogtoken */
 	ptdls_sta->dialog = dialogtoken;
 	dialogtoken = (dialogtoken+1)%256;
-	//PTI frame's priority should be AC_VO
+	/* PTI frame's priority should be AC_VO */
 	pattrib->priority = 7;
 
 	update_tdls_attrib(padapter, pattrib);
@@ -921,7 +917,7 @@ void issue_tdls_ch_switch_req(_adapter *
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -962,7 +958,7 @@ void issue_tdls_ch_switch_rsp(_adapter *
 		return;
 	}
 
-	//update attribute
+	/* update attribute */
 	pattrib = &pmgntframe->attrib;
 
 	pmgntframe->frame_tag = DATA_FRAMETAG;
@@ -1001,7 +997,7 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 	int UndecoratedSmoothedPWDB;
 
 
-	//WFDTDLS: for sigma test, not to setup direct link automatically
+	/* WFDTDLS: for sigma test, not to setup direct link automatically */
 	ptdlsinfo->dev_discovered = 1;
 
 #ifdef CONFIG_TDLS_AUTOSETUP
@@ -1012,7 +1008,7 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 	{
 		ptdls_sta->tdls_sta_state |= TDLS_ALIVE_STATE;
 
-		//Record the tdls sta with lowest signal strength
+		/* Record the tdls sta with lowest signal strength */
 		if ((ptdlsinfo->sta_maximum == true) && (ptdls_sta->alive_count >= 1))
 		{
 			if (_rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN))
@@ -1037,7 +1033,7 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 		{
 			if (_rtw_memcmp(ptdlsinfo->ss_record.macaddr, empty_addr, ETH_ALEN))
 			{
-				//All traffics are busy, do not set up another direct link.
+				/* All traffics are busy, do not set up another direct link. */
 				return _FAIL;
 			}
 			else
@@ -1061,7 +1057,7 @@ int On_TDLS_Dis_Rsp(_adapter *adapter, u
 			issue_tdls_setup_req(adapter, psa);
 		}
 	}
-#endif //CONFIG_TDLS_AUTOSETUP
+#endif /* CONFIG_TDLS_AUTOSETUP */
 
 	return _SUCCESS;
 }
@@ -1082,7 +1078,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 	u16 j;
 	u8 SNonce[32];
 	u32 *timeout_interval;
-	int parsing_length;	//frame body length, without icv_len
+	int parsing_length;	/* frame body length, without icv_len */
 	PNDIS_802_11_VARIABLE_IEs	pIE;
 	u8 FIXED_IE = 5;
 	unsigned char		supportRate[16];
@@ -1111,17 +1107,17 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		ptdls_sta = rtw_alloc_stainfo(pstapriv, psa);
 	} else {
 		if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) {
-			//If the direct link is already set up
-			//Process as re-setup after tear down
+			/* If the direct link is already set up */
+			/* Process as re-setup after tear down */
 			DBG_871X("re-setup a direct link\n");
 		}
-		//already receiving TDLS setup request
+		/* already receiving TDLS setup request */
 		else if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE) {
 			DBG_871X("receive duplicated TDLS setup request frame in handshaking\n");
 			goto exit;
 		}
-		//When receiving and sending setup_req to the same link at the same time, STA with higher MAC_addr would be initiator
-		//following is to check out MAC_addr
+		/* When receiving and sending setup_req to the same link at the same time, STA with higher MAC_addr would be initiator */
+		/* following is to check out MAC_addr */
 		else if (ptdls_sta->tdls_sta_state & TDLS_RESPONDER_STATE) {
 			DBG_871X("receive setup_req after sending setup_req\n");
 			for (i=0;i<6;i++) {
@@ -1139,10 +1135,10 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 
 	if (ptdls_sta)
 	{
-		ptdls_sta->dialog = *(ptr+2);	//copy dialog token
+		ptdls_sta->dialog = *(ptr+2);	/* copy dialog token */
 		ptdls_sta->stat_code = 0;
 
-		//parsing information element
+		/* parsing information element */
 		for (j=FIXED_IE; j<parsing_length;) {
 			pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
@@ -1167,7 +1163,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 					rsnie_have=1;
 					if (prx_pkt_attrib->encrypt) {
 						prsnie=(u8*)pIE;
-						//check whether initiator STA has CCMP pairwise_cipher.
+						/* check whether initiator STA has CCMP pairwise_cipher. */
 						ppairwise_cipher=prsnie+10;
 						memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 1);
 						for (k=0;k<pairwise_count;k++) {
@@ -1175,7 +1171,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 								ccmp_have=1;
 						}
 						if (ccmp_have==0) {
-							//invalid contents of RSNIE
+							/* invalid contents of RSNIE */
 							ptdls_sta->stat_code=72;
 						}
 					}
@@ -1202,7 +1198,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 				case _LINK_ID_IE_:
 					if (_rtw_memcmp(get_bssid(pmlmepriv), pIE->data, 6) == false)
 					{
-						//not in the same BSS
+						/* not in the same BSS */
 						ptdls_sta->stat_code=7;
 					}
 					break;
@@ -1214,25 +1210,25 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 
 		}
 
-		//update station supportRate
+		/* update station supportRate */
 		ptdls_sta->bssratelen = supportRateNum;
 		memcpy(ptdls_sta->bssrateset, supportRate, supportRateNum);
 
-		//check status code
-		//if responder STA has/hasn't security on AP, but request hasn't/has RSNIE, it should reject
+		/* check status code */
+		/* if responder STA has/hasn't security on AP, but request hasn't/has RSNIE, it should reject */
 		if (ptdls_sta->stat_code == 0)
 		{
 			if (rsnie_have && (prx_pkt_attrib->encrypt==0)) {
-				//security disabled
+				/* security disabled */
 				ptdls_sta->stat_code = 5;
 			} else if (rsnie_have==0 && (prx_pkt_attrib->encrypt)) {
-				//request haven't RSNIE
+				/* request haven't RSNIE */
 				ptdls_sta->stat_code = 38;
 			}
 
 #ifdef CONFIG_WFD
-			//WFD test plan version 0.18.2 test item 5.1.5
-			//SoUT does not use TDLS if AP uses weak security
+			/* WFD test plan version 0.18.2 test item 5.1.5 */
+			/* SoUT does not use TDLS if AP uses weak security */
 			if (adapter->wdinfo.wfd_tdls_enable)
 			{
 				if (rsnie_have && (prx_pkt_attrib->encrypt != _AES_))
@@ -1240,7 +1236,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 					ptdls_sta->stat_code = 5;
 				}
 			}
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 		}
 
 		ptdls_sta->tdls_sta_state|= TDLS_INITIATOR_STATE;
@@ -1252,14 +1248,14 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 		if (!(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE))
 			ptdlsinfo->sta_cnt++;
 		spin_unlock_bh(&(pstapriv->sta_hash_lock));
-		if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	// -2: AP + BC/MC sta
+		if (ptdlsinfo->sta_cnt == (NUM_STA - 2))	/*  -2: AP + BC/MC sta */
 		{
 			ptdlsinfo->sta_maximum = true;
 		}
 
 #ifdef CONFIG_WFD
 		rtw_tdls_process_wfd_ie(ptdlsinfo, ptr + FIXED_IE, parsing_length - FIXED_IE);
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 	}
 	else
@@ -1273,7 +1269,7 @@ int On_TDLS_Setup_Req(_adapter *adapter,
 	{
 		_set_timer(&ptdls_sta->handshake_timer, TDLS_HANDSHAKE_TIME);
 	}
-	else		//status code!=0 ; setup unsuccess
+	else		/* status code!=0 ; setup unsuccess */
 	{
 		free_tdls_sta(adapter, ptdls_sta);
 	}
@@ -1292,7 +1288,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 	struct rx_pkt_attrib	*prx_pkt_attrib = &precv_frame->u.hdr.attrib;
 	u8 *psa;
 	u16 stat_code;
-	int parsing_length;	//frame body length, without icv_len
+	int parsing_length;	/* frame body length, without icv_len */
 	PNDIS_802_11_VARIABLE_IEs	pIE;
 	u8 FIXED_IE =7;
 	u8  *pftie, *ptimeout_ie, *plinkid_ie, *prsnie, *pftie_mic, *ppairwise_cipher;
@@ -1330,7 +1326,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 
 	stat_code = 0;
 
-	//parsing information element
+	/* parsing information element */
 	for (j=FIXED_IE; j<parsing_length;)
 	{
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
@@ -1354,7 +1350,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 				break;
 			case _RSN_IE_2_:
 				prsnie=(u8*)pIE;
-				//check whether responder STA has CCMP pairwise_cipher.
+				/* check whether responder STA has CCMP pairwise_cipher. */
 				ppairwise_cipher=prsnie+10;
 				memcpy(&pairwise_count, (u16*)(ppairwise_cipher-2), 2);
 				for (k=0;k<pairwise_count;k++) {
@@ -1390,13 +1386,13 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 
 	}
 
-	//update station supportRate
+	/* update station supportRate */
 	ptdls_sta->bssratelen = supportRateNum;
 	memcpy(ptdls_sta->bssrateset, supportRate, supportRateNum);
 
 #ifdef CONFIG_WFD
 	rtw_tdls_process_wfd_ie(ptdlsinfo, ptr + FIXED_IE, parsing_length - FIXED_IE);
-#endif // CONFIG_WFD
+#endif /*  CONFIG_WFD */
 
 	if (stat_code != 0)
 	{
@@ -1410,7 +1406,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 			{
 				wpa_tdls_generate_tpk(adapter, ptdls_sta);
 				ptdls_sta->stat_code=0;
-				if (tdls_verify_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie)==0)	//0: Invalid, 1: valid
+				if (tdls_verify_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie)==0)	/* 0: Invalid, 1: valid */
 				{
 					free_tdls_sta(adapter, ptdls_sta);
 					return _FAIL;
@@ -1418,7 +1414,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 			}
 			else
 			{
-				ptdls_sta->stat_code=72;	//invalide contents of RSNIE
+				ptdls_sta->stat_code=72;	/* invalide contents of RSNIE */
 			}
 
 		} else {
@@ -1439,7 +1435,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 			_cancel_timer_ex(&ptdls_sta->handshake_timer);
 #ifdef CONFIG_TDLS_AUTOCHECKALIVE
 			_set_timer(&ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
-#endif //CONFIG_TDLS_AUTOSETUP
+#endif /* CONFIG_TDLS_AUTOSETUP */
 		}
 
 		rtw_tdls_set_mac_id(ptdlsinfo, ptdls_sta);
@@ -1448,7 +1444,7 @@ int On_TDLS_Setup_Rsp(_adapter *adapter,
 		rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_WRCR);
 
 	}
-	else //status code!=0 ; setup unsuccessful
+	else /* status code!=0 ; setup unsuccessful */
 	{
 		free_tdls_sta(adapter, ptdls_sta);
 	}
@@ -1492,7 +1488,7 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 	}
 
 	if (prx_pkt_attrib->encrypt) {
-		//parsing information element
+		/* parsing information element */
 		for (j=FIXED_IE; j<parsing_length;) {
 			pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
@@ -1522,8 +1518,8 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 
 		}
 
-		//verify mic in FTIE MIC field
-		if (tdls_verify_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie)==0) {	//0: Invalid, 1: Valid
+		/* verify mic in FTIE MIC field */
+		if (tdls_verify_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie)==0) {	/* 0: Invalid, 1: Valid */
 			free_tdls_sta(adapter, ptdls_sta);
 			return _FAIL;
 		}
@@ -1537,7 +1533,7 @@ int On_TDLS_Setup_Cfm(_adapter *adapter,
 		_cancel_timer_ex(&ptdls_sta->handshake_timer);
 #ifdef CONFIG_TDLS_AUTOCHECKALIVE
 		_set_timer(&ptdls_sta->alive_timer1, TDLS_ALIVE_TIMER_PH1);
-#endif //CONFIG_TDLS_AUTOCHECKALIVE
+#endif /* CONFIG_TDLS_AUTOCHECKALIVE */
 	}
 
 	rtw_tdls_set_mac_id(ptdlsinfo, ptdls_sta);
@@ -1554,7 +1550,7 @@ int On_TDLS_Dis_Req(_adapter *adapter, u
 	struct sta_priv *pstapriv = &adapter->stapriv;
 	struct sta_info *psta_ap;
 	u8 *ptr = precv_frame->u.hdr.rx_data;
-	int parsing_length;	//frame body length, without icv_len
+	int parsing_length;	/* frame body length, without icv_len */
 	PNDIS_802_11_VARIABLE_IEs	pIE;
 	u8 FIXED_IE = 3, *dst, *pdialog = NULL;
 	u16 j;
@@ -1571,7 +1567,7 @@ int On_TDLS_Dis_Req(_adapter *adapter, u
 			-1
 			-FIXED_IE;
 
-	//parsing information element
+	/* parsing information element */
 	for (j=FIXED_IE; j<parsing_length;) {
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
@@ -1597,7 +1593,7 @@ int On_TDLS_Dis_Req(_adapter *adapter, u
 
 	}
 
-	//check frame contents
+	/* check frame contents */
 
 	issue_tdls_dis_rsp(adapter, precv_frame, *(pdialog));
 
@@ -1634,44 +1630,44 @@ u8 TDLS_check_ch_state(uint state) {
 		(state & TDLS_AT_OFF_CH_STATE) &&
 		(state & TDLS_PEER_AT_OFF_STATE)) {
 		if (state & TDLS_PEER_SLEEP_STATE)
-			return 2;	//U-APSD + ch. switch
+			return 2;	/* U-APSD + ch. switch */
 		else
-			return 1;	//ch. switch
+			return 1;	/* ch. switch */
 	} else
 		return 0;
 }
 
-//we process buffered data for 1. U-APSD, 2. ch. switch, 3. U-APSD + ch. switch here
+/* we process buffered data for 1. U-APSD, 2. ch. switch, 3. U-APSD + ch. switch here */
 int On_TDLS_Peer_Traffic_Rsp(_adapter *adapter, union recv_frame *precv_frame)
 {
 	struct tdls_info *ptdlsinfo = &adapter->tdlsinfo;
 	struct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;
 	struct rx_pkt_attrib	*pattrib = & precv_frame->u.hdr.attrib;
 	struct sta_priv *pstapriv = &adapter->stapriv;
-	//get peer sta infomation
+	/* get peer sta infomation */
 	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->src);
 	u8 wmmps_ac=0, state=TDLS_check_ch_state(ptdls_sta->tdls_sta_state);
 	int i;
 
 	ptdls_sta->sta_stats.rx_data_pkts++;
 
-	//receive peer traffic response frame, sleeping STA wakes up
-	//ptdls_sta->tdls_sta_state &= ~(TDLS_PEER_SLEEP_STATE);
+	/* receive peer traffic response frame, sleeping STA wakes up */
+	/* ptdls_sta->tdls_sta_state &= ~(TDLS_PEER_SLEEP_STATE); */
 	process_wmmps_data(adapter, precv_frame);
 
-	// if noticed peer STA wakes up by receiving peer traffic response
-	// and we want to do channel swtiching, then we will transmit channel switch request first
+	/*  if noticed peer STA wakes up by receiving peer traffic response */
+	/*  and we want to do channel swtiching, then we will transmit channel switch request first */
 	if (ptdls_sta->tdls_sta_state & TDLS_APSD_CHSW_STATE) {
 		issue_tdls_ch_switch_req(adapter, pattrib->src);
 		ptdls_sta->tdls_sta_state &= ~(TDLS_APSD_CHSW_STATE);
 		return  _FAIL;
 	}
 
-	//check 4-AC queue bit
+	/* check 4-AC queue bit */
 	if (ptdls_sta->uapsd_vo || ptdls_sta->uapsd_vi || ptdls_sta->uapsd_be || ptdls_sta->uapsd_bk)
 		wmmps_ac=1;
 
-	//if it's a direct link and have buffered frame
+	/* if it's a direct link and have buffered frame */
 	if (ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE) {
 		if (wmmps_ac && state)
 		{
@@ -1683,7 +1679,7 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 			xmitframe_phead = get_list_head(&ptdls_sta->sleep_q);
 			xmitframe_plist = get_next(xmitframe_phead);
 
-			//transmit buffered frames
+			/* transmit buffered frames */
 			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
 			{
 				pxmitframe = LIST_CONTAINOR(xmitframe_plist, struct xmit_frame, list);
@@ -1698,7 +1694,6 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 					pxmitframe->attrib.mdata = 0;
 					pxmitframe->attrib.eosp = 1;
 				}
-				//pxmitframe->attrib.triggered = 1;	//maybe doesn't need in TDLS
 				if (rtw_hal_xmit(adapter, pxmitframe) == true)
 				{
 					rtw_os_xmit_complete(adapter, pxmitframe);
@@ -1709,8 +1704,8 @@ int On_TDLS_Peer_Traffic_Rsp(_adapter *a
 			if (ptdls_sta->sleepq_len==0)
 			{
 				DBG_871X("no buffered packets for tdls to xmit\n");
-				//on U-APSD + CH. switch state, when there is no buffered date to xmit,
-				// we should go back to base channel
+				/* on U-APSD + CH. switch state, when there is no buffered date to xmit, */
+				/*  we should go back to base channel */
 				if (state==2) {
 					rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_CS_OFF);
 				} else if (ptdls_sta->tdls_sta_state&TDLS_SW_OFF_STATE) {
@@ -1764,7 +1759,7 @@ int On_TDLS_Ch_Switch_Req(_adapter *adap
 
 	ptdls_sta->off_ch = *(ptr+2);
 
-	//parsing information element
+	/* parsing information element */
 	for (j=FIXED_IE; j<parsing_length;) {
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
@@ -1787,7 +1782,7 @@ int On_TDLS_Ch_Switch_Req(_adapter *adap
 
 	}
 
-	//todo: check status
+	/* todo: check status */
 	ptdls_sta->stat_code=0;
 	ptdls_sta->tdls_sta_state |= TDLS_CH_SWITCH_ON_STATE;
 
@@ -1824,8 +1819,8 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 	psa = get_sa(ptr);
 	ptdls_sta = rtw_get_stainfo(pstapriv, psa);
 
-	//if channel switch is running and receiving Unsolicited TDLS Channel Switch Response,
-	//it will go back to base channel and terminate this channel switch procedure
+	/* if channel switch is running and receiving Unsolicited TDLS Channel Switch Response, */
+	/* it will go back to base channel and terminate this channel switch procedure */
 	if (ptdls_sta->tdls_sta_state & TDLS_CH_SWITCH_ON_STATE) {
 		if (pmlmeext->cur_channel==ptdls_sta->off_ch) {
 			DBG_871X("back to base channel %x\n", pmlmeext->cur_channel);
@@ -1838,7 +1833,7 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 		return _FAIL;
 	}
 
-	//avoiding duplicated or unconditional ch. switch. rsp
+	/* avoiding duplicated or unconditional ch. switch. rsp */
 	if ((ptdls_sta->tdls_sta_state & TDLS_CH_SW_INITIATOR_STATE) != TDLS_CH_SW_INITIATOR_STATE)
 		return _FAIL;
 
@@ -1858,7 +1853,7 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 		return _FAIL;
 	}
 
-	//parsing information element
+	/* parsing information element */
 	for (j=FIXED_IE; j<parsing_length;) {
 		pIE = (PNDIS_802_11_VARIABLE_IEs)(ptr+ j);
 
@@ -1886,7 +1881,7 @@ int On_TDLS_Ch_Switch_Rsp(_adapter *adap
 	ptdls_sta->tdls_sta_state &= ~(TDLS_CH_SW_INITIATOR_STATE);
 	ptdls_sta->tdls_sta_state |=TDLS_CH_SWITCH_ON_STATE;
 
-	//goto set_channel_workitem_callback()
+	/* goto set_channel_workitem_callback() */
 	ptdls_sta->option=6;
 	rtw_tdls_cmd(adapter, ptdls_sta->hwaddr, TDLS_OFF_CH);
 
@@ -1901,58 +1896,58 @@ void wfd_ie_tdls(_adapter * padapter, u8
 	u8 wfdie[ MAX_WFD_IE_LEN] = { 0x00 };
 	u32 wfdielen = 0;
 
-	//	WFD OUI
+	/* 	WFD OUI */
 	wfdielen = 0;
 	wfdie[ wfdielen++ ] = 0x50;
 	wfdie[ wfdielen++ ] = 0x6F;
 	wfdie[ wfdielen++ ] = 0x9A;
-	wfdie[ wfdielen++ ] = 0x0A;	//	WFA WFD v1.0
+	wfdie[ wfdielen++ ] = 0x0A;	/* 	WFA WFD v1.0 */
 
-	//	Commented by Albert 20110825
-	//	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes
-	//	1. WFD Device Information
-	//	2. Associated BSSID (Optional)
-	//	3. Local IP Adress (Optional)
+	/* 	Commented by Albert 20110825 */
+	/* 	According to the WFD Specification, the negotiation request frame should contain 3 WFD attributes */
+	/* 	1. WFD Device Information */
+	/* 	2. Associated BSSID (Optional) */
+	/* 	3. Local IP Adress (Optional) */
 
-	//	WFD Device Information ATTR
-	//	Type:
+	/* 	WFD Device Information ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_DEVICE_INFO;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value1:
-	//	WFD device information
-	//	WFD primary sink + available for WFD session + Preferred TDLS + WSD (WFD Service Discovery)
+	/* 	Value1: */
+	/* 	WFD device information */
+	/* 	WFD primary sink + available for WFD session + Preferred TDLS + WSD (WFD Service Discovery) */
 	RTW_PUT_BE16(wfdie + wfdielen, WFD_DEVINFO_PSINK | WFD_DEVINFO_SESSION_AVAIL
 								| WFD_DEVINFO_PC_TDLS | WFD_DEVINFO_WSD);
 	wfdielen += 2;
 
-	//	Value2:
-	//	Session Management Control Port
-	//	Default TCP port for RTSP messages is 554
+	/* 	Value2: */
+	/* 	Session Management Control Port */
+	/* 	Default TCP port for RTSP messages is 554 */
 	RTW_PUT_BE16(wfdie + wfdielen, pwfd_info->rtsp_ctrlport);
 	wfdielen += 2;
 
-	//	Value3:
-	//	WFD Device Maximum Throughput
-	//	300Mbps is the maximum throughput
+	/* 	Value3: */
+	/* 	WFD Device Maximum Throughput */
+	/* 	300Mbps is the maximum throughput */
 	RTW_PUT_BE16(wfdie + wfdielen, 300);
 	wfdielen += 2;
 
-	//	Associated BSSID ATTR
-	//	Type:
+	/* 	Associated BSSID ATTR */
+	/* 	Type: */
 	wfdie[ wfdielen++ ] = WFD_ATTR_ASSOC_BSSID;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0006);
 	wfdielen += 2;
 
-	//	Value:
-	//	Associated BSSID
+	/* 	Value: */
+	/* 	Associated BSSID */
 	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
 	{
 		memcpy(wfdie + wfdielen, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN);
@@ -1962,25 +1957,25 @@ void wfd_ie_tdls(_adapter * padapter, u8
 		memset(wfdie + wfdielen, 0x00, ETH_ALEN);
 	}
 
-	//	Local IP Address ATTR
+	/* 	Local IP Address ATTR */
 	wfdie[ wfdielen++ ] = WFD_ATTR_LOCAL_IP_ADDR;
 
-	//	Length:
-	//	Note: In the WFD specification, the size of length field is 2.
+	/* 	Length: */
+	/* 	Note: In the WFD specification, the size of length field is 2. */
 	RTW_PUT_BE16(wfdie + wfdielen, 0x0005);
 	wfdielen += 2;
 
-	//	Version:
-	//	0x01: Version1;IPv4
+	/* 	Version: */
+	/* 	0x01: Version1;IPv4 */
 	wfdie[ wfdielen++ ] = 0x01;
 
-	//	IPv4 Address
+	/* 	IPv4 Address */
 	memcpy(wfdie + wfdielen, pwfd_info->ip_address, 4);
 	wfdielen += 4;
 
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, wfdielen, (unsigned char *) wfdie, pktlen);
 }
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 void rtw_build_tdls_setup_req_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
 {
@@ -1993,7 +1988,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	u8 payload_type = 0x02;
 	u8 category = RTW_WLAN_CATEGORY_TDLS;
 	u8 action = TDLS_SETUP_REQUEST;
-	u8 bssrate[NDIS_802_11_LENGTH_RATES_EX]; //Use NDIS_802_11_LENGTH_RATES_EX in order to call func.rtw_set_supported_rate
+	u8 bssrate[NDIS_802_11_LENGTH_RATES_EX]; /* Use NDIS_802_11_LENGTH_RATES_EX in order to call func.rtw_set_supported_rate */
 	int	bssrate_len = 0, i = 0 ;
 	u8 more_supportedrates = 0;
 	unsigned int ie_len;
@@ -2001,11 +1996,11 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	u8 link_id_addr[18] = {0};
 	u8 iedata=0;
-	u8 sup_ch[ 30 * 2 ] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	//For supported channel
-	u8 timeout_itvl[5];	//set timeout interval to maximum value
+	u8 sup_ch[ 30 * 2 ] = {0x00 }, sup_ch_idx = 0, idx_5g = 2;	/* For supported channel */
+	u8 timeout_itvl[5];	/* set timeout interval to maximum value */
 	u32 time;
 
-	//SNonce
+	/* SNonce */
 	if (pattrib->encrypt) {
 		for (i=0;i<8;i++) {
 			time=rtw_get_current_time();
@@ -2013,14 +2008,14 @@ void rtw_build_tdls_setup_req_ies(_adapt
 		}
 	}
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, action, dialog token
+	/* category, action, dialog token */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
 
-	//capability
+	/* capability */
 	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
 
 	if (pattrib->encrypt)
@@ -2028,7 +2023,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 	pframe += 2;
 	pattrib->pktlen += 2;
 
-	//supported rates
+	/* supported rates */
 	rtw_set_supported_rate(bssrate, WIRELESS_11BG_24N);
 	bssrate_len = IEEE80211_CCK_RATE_LEN + IEEE80211_NUM_OFDM_RATESLEN;
 
@@ -2042,54 +2037,54 @@ void rtw_build_tdls_setup_req_ies(_adapt
 		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
 	}
 
-	//country(optional)
-	//extended supported rates
+	/* country(optional) */
+	/* extended supported rates */
 	if (more_supportedrates==1) {
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
-	//supported channels
+	/* supported channels */
 	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
 
-	//	SRC IE
+	/* 	SRC IE */
 	pframe = rtw_set_ie(pframe, _SRC_IE_, 16, TDLS_SRC, &(pattrib->pktlen));
 
-	//RSNIE
+	/* RSNIE */
 	if (pattrib->encrypt)
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 
-	//extended capabilities
+	/* extended capabilities */
 	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
 
-	//QoS capability(WMM_IE)
+	/* QoS capability(WMM_IE) */
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
 
 
 	if (pattrib->encrypt) {
-		//FTIE
-		memset(pframe, 0, 84);	//All fields except SNonce shall be set to 0
-		memset(pframe, _FTIE_, 1);	//version
-		memset((pframe+1), 82, 1);	//length
+		/* FTIE */
+		memset(pframe, 0, 84);	/* All fields except SNonce shall be set to 0 */
+		memset(pframe, _FTIE_, 1);	/* version */
+		memset((pframe+1), 82, 1);	/* length */
 		memcpy((pframe+52), ptdls_sta->SNonce, 32);
 		pframe += 84;
 		pattrib->pktlen += 84;
 
-		//Timeout interval
+		/* Timeout interval */
 		timeout_itvl[0]=0x02;
 		memcpy(timeout_itvl+1, (u8 *)(&ptdls_sta->TDLS_PeerKey_Lifetime), 4);
 		pframe = rtw_set_ie(pframe, _TIMEOUT_ITVL_IE_, 5, timeout_itvl,  &(pattrib->pktlen));
 	}
 
-	//Sup_reg_classes(optional)
-	//HT capabilities
+	/* Sup_reg_classes(optional) */
+	/* HT capabilities */
 	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
 
-	//20/40 BSS coexistence
+	/* 20/40 BSS coexistence */
 	if (pmlmepriv->num_FortyMHzIntolerant>0)
-		iedata |= BIT(2);//20 MHz BSS Width Request
+		iedata |= BIT(2);/* 20 MHz BSS Width Request */
 	pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
 
-	//Link identifier
+	/* Link identifier */
 	memcpy(link_id_addr, pattrib->ra, 6);
 	memcpy((link_id_addr+6), pattrib->src, 6);
 	memcpy((link_id_addr+12), pattrib->dst, 6);
@@ -2097,7 +2092,7 @@ void rtw_build_tdls_setup_req_ies(_adapt
 
 #ifdef CONFIG_WFD
 	wfd_ie_tdls(padapter, pframe, &(pattrib->pktlen));
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 }
 
 void rtw_build_tdls_setup_rsp_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
@@ -2119,9 +2114,9 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	u8 link_id_addr[18] = {0};
 	u8 iedata=0;
-	u8 timeout_itvl[5];	//setup response timeout interval will copy from request
-	u8 ANonce[32];	//maybe it can put in ontdls_req
-	u8 k;		//for random ANonce
+	u8 timeout_itvl[5];	/* setup response timeout interval will copy from request */
+	u8 ANonce[32];	/* maybe it can put in ontdls_req */
+	u8 k;		/* for random ANonce */
 	u8  *pftie, *ptimeout_ie, *plinkid_ie, *prsnie, *pftie_mic;
 	u32 time;
 
@@ -2140,23 +2135,23 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 		}
 	}
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, action, status code
+	/* category, action, status code */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 2, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 
-	if (ptdls_sta->stat_code!=0)	//invalid setup request
+	if (ptdls_sta->stat_code!=0)	/* invalid setup request */
 	{
 		DBG_871X("ptdls_sta->stat_code:%04x\n", ptdls_sta->stat_code);
 		return;
 	}
 
-	//dialog token
+	/* dialog token */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
 
-	//capability
+	/* capability */
 	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
 
 	if (pattrib->encrypt)
@@ -2164,7 +2159,7 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 	pframe += 2;
 	pattrib->pktlen += 2;
 
-	//supported rates
+	/* supported rates */
 	rtw_set_supported_rate(bssrate, WIRELESS_11BG_24N);
 	bssrate_len = IEEE80211_CCK_RATE_LEN + IEEE80211_NUM_OFDM_RATESLEN;
 
@@ -2178,74 +2173,74 @@ void rtw_build_tdls_setup_rsp_ies(_adapt
 		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
 	}
 
-	//country(optional)
-	//extended supported rates
+	/* country(optional) */
+	/* extended supported rates */
 	if (more_supportedrates==1) {
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
-	//supported channels
+	/* supported channels */
 	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
 
-	// SRC IE
+	/*  SRC IE */
 	pframe = rtw_set_ie(pframe, _SRC_IE_ , 16, TDLS_SRC, &(pattrib->pktlen));
 
-	//RSNIE
+	/* RSNIE */
 	if (pattrib->encrypt) {
 		prsnie = pframe;
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 	}
 
-	//extended capabilities
+	/* extended capabilities */
 	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
 
-	//QoS capability(WMM_IE)
+	/* QoS capability(WMM_IE) */
 	pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 7, TDLS_WMMIE,  &(pattrib->pktlen));
 
 	if (pattrib->encrypt) {
 		wpa_tdls_generate_tpk(padapter, ptdls_sta);
 
-		//FTIE
+		/* FTIE */
 		pftie = pframe;
 		pftie_mic = pframe+4;
-		memset(pframe, 0, 84);	//All fields except SNonce shall be set to 0
-		memset(pframe, _FTIE_, 1);	//version
-		memset((pframe+1), 82, 1);	//length
+		memset(pframe, 0, 84);	/* All fields except SNonce shall be set to 0 */
+		memset(pframe, _FTIE_, 1);	/* version */
+		memset((pframe+1), 82, 1);	/* length */
 		memcpy((pframe+20), ptdls_sta->ANonce, 32);
 		memcpy((pframe+52), ptdls_sta->SNonce, 32);
 		pframe += 84;
 		pattrib->pktlen += 84;
 
-		//Timeout interval
+		/* Timeout interval */
 		ptimeout_ie = pframe;
 		timeout_itvl[0]=0x02;
 		memcpy(timeout_itvl+1, (u8 *)(&ptdls_sta->TDLS_PeerKey_Lifetime), 4);
 		pframe = rtw_set_ie(pframe, _TIMEOUT_ITVL_IE_, 5, timeout_itvl,  &(pattrib->pktlen));
 	}
 
-	//Sup_reg_classes(optional)
-	//HT capabilities
+	/* Sup_reg_classes(optional) */
+	/* HT capabilities */
 	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
 
-	//20/40 BSS coexistence
+	/* 20/40 BSS coexistence */
 	if (pmlmepriv->num_FortyMHzIntolerant>0)
-		iedata |= BIT(2);//20 MHz BSS Width Request
+		iedata |= BIT(2);/* 20 MHz BSS Width Request */
 	pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
 
-	//Link identifier
+	/* Link identifier */
 	plinkid_ie = pframe;
 	memcpy(link_id_addr, pattrib->ra, 6);
 	memcpy((link_id_addr+6), pattrib->dst, 6);
 	memcpy((link_id_addr+12), pattrib->src, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
 
-	//fill FTIE mic
+	/* fill FTIE mic */
 	if (pattrib->encrypt)
 		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 2, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
 
 #ifdef CONFIG_WFD
 	wfd_ie_tdls(padapter, pframe, &(pattrib->pktlen));
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 }
 
 void rtw_build_tdls_setup_cfm_ies(_adapter * padapter, struct xmit_frame * pxmitframe, u8 *pframe)
@@ -2261,42 +2256,42 @@ void rtw_build_tdls_setup_cfm_ies(_adapt
 	u8 more_supportedrates = 0;
 	unsigned int ie_len;
 	unsigned char *p;
-	u8 timeout_itvl[5];	//set timeout interval to maximum value
+	u8 timeout_itvl[5];	/* set timeout interval to maximum value */
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	u8	link_id_addr[18] = {0};
 	u8  *pftie, *ptimeout_ie, *plinkid_ie, *prsnie, *pftie_mic;
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, action, status code, dialog token
+	/* category, action, status code, dialog token */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 2, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
 
-	if (ptdls_sta->stat_code!=0)	//invalid setup request
+	if (ptdls_sta->stat_code!=0)	/* invalid setup request */
 		return;
 
-	//RSNIE
+	/* RSNIE */
 	if (pattrib->encrypt) {
 		prsnie = pframe;
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 	}
 
-	//EDCA param set; WMM param ele.
+	/* EDCA param set; WMM param ele. */
 	if (pattrib->encrypt) {
-		//FTIE
+		/* FTIE */
 		pftie = pframe;
 		pftie_mic = pframe+4;
-		memset(pframe, 0, 84);	//All fields except SNonce shall be set to 0
-		memset(pframe, _FTIE_, 1);	//version
-		memset((pframe+1), 82, 1);	//length
+		memset(pframe, 0, 84);	/* All fields except SNonce shall be set to 0 */
+		memset(pframe, _FTIE_, 1);	/* version */
+		memset((pframe+1), 82, 1);	/* length */
 		memcpy((pframe+20), ptdls_sta->ANonce, 32);
 		memcpy((pframe+52), ptdls_sta->SNonce, 32);
 		pframe += 84;
 		pattrib->pktlen += 84;
 
-		//Timeout interval
+		/* Timeout interval */
 		ptimeout_ie = pframe;
 		timeout_itvl[0]=0x02;
 		memcpy(timeout_itvl+1, (u8 *)(&ptdls_sta->TDLS_PeerKey_Lifetime), 4);
@@ -2305,15 +2300,15 @@ void rtw_build_tdls_setup_cfm_ies(_adapt
 		pframe = rtw_set_ie(pframe, _TIMEOUT_ITVL_IE_, 5, timeout_itvl,  &(pattrib->pktlen));
 	}
 
-	//HT operation; todo
-	//Link identifier
+	/* HT operation; todo */
+	/* Link identifier */
 	plinkid_ie = pframe;
 	memcpy(link_id_addr, pattrib->ra, 6);
 	memcpy((link_id_addr+6), pattrib->src, 6);
 	memcpy((link_id_addr+12), pattrib->dst, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
 
-	//fill FTIE mic
+	/* fill FTIE mic */
 	if (pattrib->encrypt)
 		wpa_tdls_ftie_mic(ptdls_sta->tpk.kck, 3, plinkid_ie, prsnie, ptimeout_ie, pftie, pftie_mic);
 }
@@ -2329,14 +2324,14 @@ void rtw_build_tdls_teardown_ies(_adapte
 	struct sta_info *ptdls_sta = rtw_get_stainfo(&(padapter->stapriv) , pattrib->dst);
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, action, reason code
+	/* category, action, reason code */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 
-	//Link identifier
+	/* Link identifier */
 	if (ptdls_sta->tdls_sta_state & TDLS_INITIATOR_STATE) {
 		memcpy(link_id_addr, pattrib->ra, 6);
 		memcpy((link_id_addr+6), pattrib->src, 6);
@@ -2358,15 +2353,15 @@ void rtw_build_tdls_dis_req_ies(_adapter
 	u8	link_id_addr[18] = {0};
 	static u8 dialogtoken=0;
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, action, reason code
+	/* category, action, reason code */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialogtoken), &(pattrib->pktlen));
 	dialogtoken = (dialogtoken+1)%256;
 
-	//Link identifier
+	/* Link identifier */
 	memcpy(link_id_addr, pattrib->ra, 6);
 	memcpy((link_id_addr+6), pattrib->src, 6);
 	memcpy((link_id_addr+12), pattrib->dst, 6);
@@ -2389,15 +2384,15 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	struct mlme_priv		*pmlmepriv = &padapter->mlmepriv;
 	u8 link_id_addr[18] = {0};
 	u8 iedata=0;
-	u8 timeout_itvl[5];	//set timeout interval to maximum value
+	u8 timeout_itvl[5];	/* set timeout interval to maximum value */
 	u32 timeout_interval= TPK_RESEND_COUNT * 1000;
 
-	//category, action, dialog token
+	/* category, action, dialog token */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(dialog), &(pattrib->pktlen));
 
-	//capability
+	/* capability */
 	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
 
 	if (pattrib->encrypt)
@@ -2405,7 +2400,7 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 	pframe += 2;
 	pattrib->pktlen += 2;
 
-	//supported rates
+	/* supported rates */
 	rtw_set_supported_rate(bssrate, WIRELESS_11BG_24N);
 	bssrate_len = IEEE80211_CCK_RATE_LEN + IEEE80211_NUM_OFDM_RATESLEN;
 
@@ -2419,45 +2414,45 @@ void rtw_build_tdls_dis_rsp_ies(_adapter
 		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
 	}
 
-	//extended supported rates
+	/* extended supported rates */
 	if (more_supportedrates==1) {
 		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
 	}
 
-	//supported channels
+	/* supported channels */
 	pframe = rtw_tdls_set_sup_ch(pmlmeext, pframe, pattrib);
 
-	//RSNIE
+	/* RSNIE */
 	if (pattrib->encrypt)
 		pframe = rtw_set_ie(pframe, _RSN_IE_2_, 20, TDLS_RSNIE, &(pattrib->pktlen));
 
-	//extended capability
+	/* extended capability */
 	pframe = rtw_set_ie(pframe, _EXT_CAP_IE_ , 5, TDLS_EXT_CAPIE, &(pattrib->pktlen));
 
 	if (pattrib->encrypt) {
-		//FTIE
-		memset(pframe, 0, 84);	//All fields shall be set to 0
-		memset(pframe, _FTIE_, 1);	//version
-		memset((pframe+1), 82, 1);	//length
+		/* FTIE */
+		memset(pframe, 0, 84);	/* All fields shall be set to 0 */
+		memset(pframe, _FTIE_, 1);	/* version */
+		memset((pframe+1), 82, 1);	/* length */
 		pframe += 84;
 		pattrib->pktlen += 84;
 
-		//Timeout interval
+		/* Timeout interval */
 		timeout_itvl[0]=0x02;
 		memcpy(timeout_itvl+1, &timeout_interval, 4);
 		pframe = rtw_set_ie(pframe, _TIMEOUT_ITVL_IE_, 5, timeout_itvl,  &(pattrib->pktlen));
 	}
 
-	//Sup_reg_classes(optional)
-	//HT capabilities
+	/* Sup_reg_classes(optional) */
+	/* HT capabilities */
 	pframe = rtw_tdls_set_ht_cap(padapter, pframe, pattrib);
 
-	//20/40 BSS coexistence
+	/* 20/40 BSS coexistence */
 	if (pmlmepriv->num_FortyMHzIntolerant>0)
-		iedata |= BIT(2);//20 MHz BSS Width Request
+		iedata |= BIT(2);/* 20 MHz BSS Width Request */
 	pframe = rtw_set_ie(pframe, EID_BSSCoexistence, 1, &iedata, &(pattrib->pktlen));
 
-	//Link identifier
+	/* Link identifier */
 	memcpy(link_id_addr, pattrib->ra, 6);
 	memcpy((link_id_addr+6), pattrib->dst, 6);
 	memcpy((link_id_addr+12), pattrib->src, 6);
@@ -2476,21 +2471,21 @@ void rtw_build_tdls_peer_traffic_indicat
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 	struct sta_info *ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, action, reason code
+	/* category, action, reason code */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdls_sta->dialog), &(pattrib->pktlen));
 
-	//Link identifier
+	/* Link identifier */
 	memcpy(link_id_addr, pattrib->ra, 6);
 	memcpy((link_id_addr+6), pattrib->src, 6);
 	memcpy((link_id_addr+12), pattrib->dst, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
 
-	//PTI control
-	//PU buffer status
+	/* PTI control */
+	/* PU buffer status */
 	if (ptdls_sta->uapsd_bk&BIT(1))
 		AC_queue=BIT(0);
 	if (ptdls_sta->uapsd_be&BIT(1))
@@ -2515,25 +2510,25 @@ void rtw_build_tdls_ch_switch_req_ies(_a
 	u8 ch_switch_timing[4] = {0};
 	u16 switch_time= CH_SWITCH_TIME, switch_timeout=CH_SWITCH_TIMEOUT;
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, action, target_ch
+	/* category, action, target_ch */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(ptdlsinfo->candidate_ch), &(pattrib->pktlen));
 
-	//Link identifier
+	/* Link identifier */
 	memcpy(link_id_addr, pattrib->ra, 6);
 	memcpy((link_id_addr+6), pattrib->src, 6);
 	memcpy((link_id_addr+12), pattrib->dst, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
 
-	//ch switch timing
+	/* ch switch timing */
 	memcpy(ch_switch_timing, &switch_time, 2);
 	memcpy(ch_switch_timing+2, &switch_timeout, 2);
 	pframe = rtw_set_ie(pframe, _CH_SWITCH_TIMING_,  4, ch_switch_timing, &(pattrib->pktlen));
 
-	//update ch switch attrib to sta_info
+	/* update ch switch attrib to sta_info */
 	ptdls_sta->off_ch=ptdlsinfo->candidate_ch;
 	ptdls_sta->ch_switch_time=switch_time;
 	ptdls_sta->ch_switch_timeout=switch_timeout;
@@ -2552,20 +2547,20 @@ void rtw_build_tdls_ch_switch_rsp_ies(_a
 	struct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;
 	u8 ch_switch_timing[4] = {0};
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, action, status_code
+	/* category, action, status_code */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 2, (u8 *)&ptdls_sta->stat_code, &(pattrib->pktlen));
 
-	//Link identifier
+	/* Link identifier */
 	memcpy(link_id_addr, pattrib->ra, 6);
 	memcpy((link_id_addr+6), pattrib->src, 6);
 	memcpy((link_id_addr+12), pattrib->dst, 6);
 	pframe = rtw_set_ie(pframe, _LINK_ID_IE_,  18, link_id_addr, &(pattrib->pktlen));
 
-	//ch switch timing
+	/* ch switch timing */
 	memcpy(ch_switch_timing, &ptdls_sta->ch_switch_time, 2);
 	memcpy(ch_switch_timing+2, &ptdls_sta->ch_switch_timeout, 2);
 	pframe = rtw_set_ie(pframe, _CH_SWITCH_TIMING_,  4, ch_switch_timing, &(pattrib->pktlen));
@@ -2583,9 +2578,9 @@ void rtw_build_tunneled_probe_req_ies(_a
 	u8 probe_req = 4;
 	u8 wfdielen = 0;
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, OUI, frame_body_type
+	/* category, OUI, frame_body_type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 3, WFA_OUI, &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(probe_req), &(pattrib->pktlen));
@@ -2615,9 +2610,9 @@ void rtw_build_tunneled_probe_rsp_ies(_a
 	u8 probe_rsp = 5;
 	u8 wfdielen = 0;
 
-	//payload type
+	/* payload type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(payload_type), &(pattrib->pktlen));
-	//category, OUI, frame_body_type
+	/* category, OUI, frame_body_type */
 	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 3, WFA_OUI, &(pattrib->pktlen));
 	pframe = rtw_set_fixed_ie(pframe, 1, &(probe_rsp), &(pattrib->pktlen));
@@ -2635,15 +2630,15 @@ void rtw_build_tunneled_probe_rsp_ies(_a
 		pattrib->pktlen += wfdielen;
 	}
 }
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 
 void _TPK_timer_hdl(void *FunctionContext)
 {
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
 
 	ptdls_sta->TPK_count++;
-	//TPK_timer set 1000 as default
-	//retry timer should set at least 301 sec.
+	/* TPK_timer set 1000 as default */
+	/* retry timer should set at least 301 sec. */
 	if (ptdls_sta->TPK_count==TPK_RESEND_COUNT) {
 		ptdls_sta->TPK_count=0;
 		issue_tdls_setup_req(ptdls_sta->padapter, ptdls_sta->hwaddr);
@@ -2659,9 +2654,9 @@ void init_TPK_timer(_adapter *padapter,
 	_init_timer(&psta->TPK_timer, padapter->pnetdev, _TPK_timer_hdl, psta);
 }
 
-// TDLS_DONE_CH_SEN: channel sensing and report candidate channel
-// TDLS_OFF_CH: first time set channel to off channel
-// TDLS_BASE_CH: when go back to the channel linked with AP, send null data to peer STA as an indication
+/*  TDLS_DONE_CH_SEN: channel sensing and report candidate channel */
+/*  TDLS_OFF_CH: first time set channel to off channel */
+/*  TDLS_BASE_CH: when go back to the channel linked with AP, send null data to peer STA as an indication */
 void _ch_switch_timer_hdl(void *FunctionContext)
 {
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
@@ -2727,7 +2722,7 @@ void init_handshake_timer(_adapter *pada
 	_init_timer(&psta->handshake_timer, padapter->pnetdev, _tdls_handshake_timer_hdl, psta);
 }
 
-//Check tdls peer sta alive.
+/* Check tdls peer sta alive. */
 void _tdls_alive_timer_phase1_hdl(void *FunctionContext)
 {
 	struct sta_info *ptdls_sta = (struct sta_info *)FunctionContext;
@@ -2834,21 +2829,21 @@ u32 update_mask_tdls(_adapter *padapter,
 	struct wlan_bssid_ex *pcur_network = (struct wlan_bssid_ex *)&pmlmepriv->cur_network.network;
 
 	psta_ht = &psta->htpriv;
-	//b/g mode ra_bitmap
+	/* b/g mode ra_bitmap */
 	for (i=0; i<sizeof(psta->bssrateset); i++)
 	{
 		if (psta->bssrateset[i])
 			tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
 	}
 
-	//n mode ra_bitmap
+	/* n mode ra_bitmap */
 	if (psta_ht->ht_option)
 	{
 		rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 		if (rf_type == RF_2T2R)
-			limit=16;// 2R
+			limit=16;/*  2R */
 		else
-			limit=8;//  1R
+			limit=8;/*   1R */
 
 		for (i=0; i<limit; i++) {
 			if (psta_ht->ht_cap.supp_mcs_set[i/8] & BIT(i%8))
@@ -2857,7 +2852,7 @@ u32 update_mask_tdls(_adapter *padapter,
 	}
 
 	if (pcur_network->Configuration.DSConfig > 14) {
-		// 5G band
+		/*  5G band */
 		if (tx_ra_bitmap & 0xffff000)
 			sta_band |= WIRELESS_11_5N | WIRELESS_11A;
 		else
@@ -2876,4 +2871,4 @@ u32 update_mask_tdls(_adapter *padapter,
 	return tx_ra_bitmap;
 }
 
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
--- a/drivers/staging/rtl8192du/core/rtw_wlan_util.c
+++ b/drivers/staging/rtl8192du/core/rtw_wlan_util.c
@@ -43,7 +43,7 @@ unsigned char REALTEK_96B_IE[] = {0x00,
 extern unsigned char	MCS_rate_2R[16];
 #ifdef CONFIG_DISABLE_MCS13TO15
 extern unsigned char	MCS_rate_2R_MCS13TO15_OFF[16];
-#endif //CONFIG_DISABLE_MCS13TO15
+#endif /* CONFIG_DISABLE_MCS13TO15 */
 extern unsigned char	MCS_rate_1R[16];
 extern unsigned char RTW_WPA_OUI[];
 extern unsigned char WPA_TKIP_CIPHER[4];
@@ -51,7 +51,7 @@ extern unsigned char RSN_TKIP_CIPHER[4];
 
 #define R2T_PHY_DELAY	(0)
 
-//#define WAIT_FOR_BCN_TO_MIN	(3000)
+/* define WAIT_FOR_BCN_TO_MIN	(3000) */
 #define WAIT_FOR_BCN_TO_MIN	(6000)
 #define WAIT_FOR_BCN_TO_MAX	(20000)
 
@@ -314,7 +314,7 @@ void UpdateBrateTbl(
 	u8	i;
 	u8	rate;
 
-	// 1M, 2M, 5.5M, 11M, 6M, 12M, 24M are mandatory.
+	/*  1M, 2M, 5.5M, 11M, 6M, 12M, 24M are mandatory. */
 	for (i=0;i<NDIS_802_11_LENGTH_RATES_EX;i++)
 	{
 		rate = mBratesOS[i] & 0x7f;
@@ -460,21 +460,21 @@ void SelectChannel(struct rtw_adapter *p
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	//saved channel info
+	/* saved channel info */
 	rtw_set_oper_ch(padapter, channel);
 	dc_SelectChannel(padapter, channel);
-#else //CONFIG_DUALMAC_CONCURRENT
+#else /* CONFIG_DUALMAC_CONCURRENT */
 
 	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex));
 
-	//saved channel info
+	/* saved channel info */
 	rtw_set_oper_ch(padapter, channel);
 
 	rtw_hal_set_chan(padapter, channel);
 
 	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex));
 
-#endif // CONFIG_DUALMAC_CONCURRENT
+#endif /*  CONFIG_DUALMAC_CONCURRENT */
 }
 
 void SetBWMode(struct rtw_adapter *padapter, unsigned short bwmode, unsigned char channel_offset)
@@ -482,15 +482,15 @@ void SetBWMode(struct rtw_adapter *padap
 	struct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;
 
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	//saved bw info
+	/* saved bw info */
 	rtw_set_oper_bw(padapter, bwmode);
 	rtw_set_oper_choffset(padapter, channel_offset);
 	dc_SetBWMode(padapter, bwmode, channel_offset);
-#else //CONFIG_DUALMAC_CONCURRENT
+#else /* CONFIG_DUALMAC_CONCURRENT */
 
 	_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setbw_mutex));
 
-	//saved bw info
+	/* saved bw info */
 	rtw_set_oper_bw(padapter, bwmode);
 	rtw_set_oper_choffset(padapter, channel_offset);
 
@@ -498,7 +498,7 @@ void SetBWMode(struct rtw_adapter *padap
 
 	_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setbw_mutex));
 
-#endif // CONFIG_DUALMAC_CONCURRENT
+#endif /*  CONFIG_DUALMAC_CONCURRENT */
 }
 
 void set_channel_bwmode(struct rtw_adapter *padapter, unsigned char channel, unsigned char channel_offset, unsigned short bwmode)
@@ -513,37 +513,37 @@ void set_channel_bwmode(struct rtw_adapt
 
 	if ((bwmode == HT_CHANNEL_WIDTH_20)||(channel_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE))
 	{
-		//SelectChannel(padapter, channel);
+		/* SelectChannel(padapter, channel); */
 		center_ch = channel;
 	}
 	else
 	{
-		//switch to the proper channel
+		/* switch to the proper channel */
 		if (channel_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
 		{
-			//SelectChannel(padapter, channel + 2);
+			/* SelectChannel(padapter, channel + 2); */
 			center_ch = channel + 2;
 		}
 		else
 		{
-			//SelectChannel(padapter, channel - 2);
+			/* SelectChannel(padapter, channel - 2); */
 			center_ch = channel - 2;
 		}
 	}
 
-	//set Channel , must be independant for correct co_ch value/
+	/* set Channel , must be independant for correct co_ch value/ */
 #ifdef CONFIG_DUALMAC_CONCURRENT
-	//saved channel/bw info
+	/* saved channel/bw info */
 	rtw_set_oper_ch(padapter, channel);
 	rtw_set_oper_bw(padapter, bwmode);
 	rtw_set_oper_choffset(padapter, channel_offset);
-	dc_SelectChannel(padapter, center_ch);// set center channel
-#else //CONFIG_DUALMAC_CONCURRENT
+	dc_SelectChannel(padapter, center_ch);/*  set center channel */
+#else /* CONFIG_DUALMAC_CONCURRENT */
 
 	if (!mutex_is_locked(&(adapter_to_dvobj(padapter)->hw_init_mutex)))
 		_enter_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex));
 
-	//saved channel/bw info
+	/* saved channel/bw info */
 	rtw_set_oper_ch(padapter, channel);
 	rtw_set_oper_bw(padapter, bwmode);
 	rtw_set_oper_choffset(padapter, channel_offset);
@@ -553,10 +553,10 @@ void set_channel_bwmode(struct rtw_adapt
 	if (!mutex_is_locked(&(adapter_to_dvobj(padapter)->hw_init_mutex)))
 		_exit_critical_mutex(&(adapter_to_dvobj(padapter)->setch_mutex));
 
-#endif // CONFIG_DUALMAC_CONCURRENT
+#endif /*  CONFIG_DUALMAC_CONCURRENT */
 
 
-	//set BandWidth
+	/* set BandWidth */
 	SetBWMode(padapter, bwmode, channel_offset);
 }
 
@@ -674,7 +674,7 @@ void invalidate_cam_all(struct rtw_adapt
 void write_cam(struct rtw_adapter *padapter, u8 entry, u16 ctrl, u8 *mac, u8 *key)
 {
 	unsigned int	i, val, addr;
-	//unsigned int    cmd;
+	/* unsigned int    cmd; */
 	int j;
 	u32	cam_val[2];
 
@@ -704,12 +704,12 @@ void write_cam(struct rtw_adapter *padap
 
 		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_WRITE, (u8 *)cam_val);
 
-		//rtw_write32(padapter, WCAMI, val);
+		/* rtw_write32(padapter, WCAMI, val); */
 
-		//cmd = CAM_POLLINIG | CAM_WRITE | (addr + j);
-		//rtw_write32(padapter, RWCAM, cmd);
+		/* cmd = CAM_POLLINIG | CAM_WRITE | (addr + j); */
+		/* rtw_write32(padapter, RWCAM, cmd); */
 
-		//DBG_8192D("%s=> cam write: %x, %x\n",__func__, cmd, val);
+		/* DBG_8192D("%s=> cam write: %x, %x\n",__func__, cmd, val); */
 
 	}
 }
@@ -750,7 +750,7 @@ void flush_all_cam_entry(struct rtw_adap
 
 	struct mlme_priv *pmlmepriv = &(padapter->mlmepriv);
 
-	//if (check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_))
+	/* if (check_buddy_mlmeinfo_state(padapter, _HW_STATE_NOLINK_)) */
 	if (check_buddy_fwstate(padapter, _FW_LINKED) == false)
 	{
 		rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
@@ -761,32 +761,32 @@ void flush_all_cam_entry(struct rtw_adap
 		{
 			struct sta_priv	*pstapriv = &padapter->stapriv;
 			struct sta_info	*psta;
-			u8 cam_id;//cam_entry
+			u8 cam_id;/* cam_entry */
 
 			psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress);
 			if (psta) {
 				if (psta->state & WIFI_AP_STATE)
-				{}   //clear cam when ap free per sta_info
+				{}   /* clear cam when ap free per sta_info */
 				else {
 					if (psta->mac_id==2)
 						cam_id = 5;
 					else
 						cam_id = 4;
 				}
-				//clear_cam_entry(padapter, cam_id);
+				/* clear_cam_entry(padapter, cam_id); */
 				rtw_clearstakey_cmd(padapter, (u8*)psta, cam_id, false);
 			}
 		}
 		else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
 		{
-			//clear cam when ap free per sta_info
+			/* clear cam when ap free per sta_info */
 		}
 	}
-#else //CONFIG_CONCURRENT_MODE
+#else /* CONFIG_CONCURRENT_MODE */
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_CAM_INVALID_ALL, 0);
 
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 	memset((u8 *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
 }
@@ -829,7 +829,7 @@ int WFD_info_handler(struct rtw_adapter
 
 int WMM_param_handler(struct rtw_adapter *padapter, struct ndis_802_11_variable_ies *pIE)
 {
-	//struct registry_priv	*pregpriv = &padapter->registrypriv;
+	/* struct registry_priv	*pregpriv = &padapter->registrypriv; */
 	struct mlme_priv	*pmlmepriv = &(padapter->mlmepriv);
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
@@ -843,26 +843,6 @@ int WMM_param_handler(struct rtw_adapter
 	pmlmeinfo->WMM_enable = 1;
 	memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
 	return true;
-
-	/*if (pregpriv->wifi_spec == 1)
-	{
-		if (pmlmeinfo->WMM_enable == 1)
-		{
-			//todo: compare the parameter set count & decide wheher to update or not
-			return _FAIL;
-		}
-		else
-		{
-			pmlmeinfo->WMM_enable = 1;
-			_rtwmemcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
-			return true;
-		}
-	}
-	else
-	{
-		pmlmeinfo->WMM_enable = 0;
-		return _FAIL;
-	}*/
 }
 
 void WMMOnAssocRsp(struct rtw_adapter *padapter)
@@ -892,7 +872,7 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 		ACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;
 		ACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;
 
-		//AIFS = AIFSN * slot time + SIFS - r2t phy delay
+		/* AIFS = AIFSN * slot time + SIFS - r2t phy delay */
 		AIFS = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 0x0f) * pmlmeinfo->slotTime + aSifsTime;
 
 		ECWMin = (pmlmeinfo->WMM_param.ac_param[i].CW & 0x0f);
@@ -910,7 +890,7 @@ void WMMOnAssocRsp(struct rtw_adapter *p
 
 			case 0x1:
 				rtw_hal_set_hwreg(padapter, HW_VAR_AC_PARAM_BK, (u8 *)(&acParm));
-				//acm_mask |= (ACM? BIT(0):0);
+				/* acm_mask |= (ACM? BIT(0):0); */
 				break;
 
 			case 0x2:
@@ -998,7 +978,7 @@ static void bwmode_update_check(struct r
 		pmlmeext->cur_bwmode = new_bwmode;
 		pmlmeext->cur_ch_offset = new_ch_offset;
 
-		//update HT info also
+		/* update HT info also */
 		HT_info_handler(padapter, pIE);
 	}
 	else
@@ -1013,10 +993,7 @@ static void bwmode_update_check(struct r
 		struct wlan_bssid_ex	*cur_network = &(pmlmeinfo->network);
 		struct sta_priv	*pstapriv = &padapter->stapriv;
 
-		//set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
-
-
-		//update ap's stainfo
+		/* update ap's stainfo */
 		psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
 		if (psta)
 		{
@@ -1024,7 +1001,7 @@ static void bwmode_update_check(struct r
 
 			if (phtpriv_sta->ht_option)
 			{
-				// bwmode
+				/*  bwmode */
 				phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
 				phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
 			}
@@ -1036,8 +1013,6 @@ static void bwmode_update_check(struct r
 
 		}
 
-		//pmlmeinfo->bwmode_updated = false;//bwmode_updated done, reset it!
-
 	}
 }
 
@@ -1062,13 +1037,13 @@ void HT_caps_handler(struct rtw_adapter
 	{
 		if (i != 2)
 		{
-			//	Commented by Albert 2010/07/12
-			//	Got the endian issue here.
+			/* 	Commented by Albert 2010/07/12 */
+			/* 	Got the endian issue here. */
 			pmlmeinfo->HT_caps.u.HT_cap[i] &= (pIE->data[i]);
 		}
 		else
 		{
-			//modify from  fw by Thomas 2010/11/17
+			/* modify from  fw by Thomas 2010/11/17 */
 			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3) > (pIE->data[i] & 0x3))
 			{
 				max_AMPDU_len = (pIE->data[i] & 0x3);
@@ -1091,15 +1066,15 @@ void HT_caps_handler(struct rtw_adapter
 		}
 	}
 
-	//	Commented by Albert 2010/07/12
-	//	Have to handle the endian issue after copying.
-	//	HT_ext_caps didn't be used yet.
+	/* 	Commented by Albert 2010/07/12 */
+	/* 	Have to handle the endian issue after copying. */
+	/* 	HT_ext_caps didn't be used yet. */
 	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info);
 	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps);
 
 	rtw_hal_get_hwreg(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));
 
-	//update the MCS rates
+	/* update the MCS rates */
 	for (i = 0; i < 16; i++)
 	{
 		if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
@@ -1115,7 +1090,7 @@ void HT_caps_handler(struct rtw_adapter
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
 			#else
 			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
-			#endif //CONFIG_DISABLE_MCS13TO15
+			#endif /* CONFIG_DISABLE_MCS13TO15 */
 		}
 	        #ifdef RTL8192C_RECONFIG_TO_1T1R
 		{
@@ -1156,7 +1131,7 @@ void HTOnAssocRsp(struct rtw_adapter *pa
 {
 	unsigned char		max_AMPDU_len;
 	unsigned char		min_MPDU_spacing;
-	//struct registry_priv	 *pregpriv = &padapter->registrypriv;
+	/* struct registry_priv	 *pregpriv = &padapter->registrypriv; */
 	struct mlme_ext_priv	*pmlmeext = &padapter->mlmeextpriv;
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 
@@ -1169,11 +1144,11 @@ void HTOnAssocRsp(struct rtw_adapter *pa
 	else
 	{
 		pmlmeinfo->HT_enable = 0;
-		//set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+		/* set_channel_bwmode(padapter, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode); */
 		return;
 	}
 
-	//handle A-MPDU parameter field
+	/* handle A-MPDU parameter field */
 	/*
 		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
 		AMPDU_para [4:2]:Min MPDU Start Spacing
@@ -1207,12 +1182,12 @@ void VCS_update(struct rtw_adapter *pada
 
 	switch (pregpriv->vrtl_carrier_sense)/* 0:off 1:on 2:auto */
 	{
-		case 0: //off
+		case 0: /* off */
 			psta->rtsen = 0;
 			psta->cts2self = 0;
 			break;
 
-		case 1: //on
+		case 1: /* on */
 			if (pregpriv->vcs_type == 1) /* 1:RTS/CTS 2:CTS to self */
 			{
 				psta->rtsen = 1;
@@ -1225,7 +1200,7 @@ void VCS_update(struct rtw_adapter *pada
 			}
 			break;
 
-		case 2: //auto
+		case 2: /* auto */
 		default:
 			if ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1)))
 			{
@@ -1252,7 +1227,7 @@ void VCS_update(struct rtw_adapter *pada
 #ifdef CONFIG_TDLS
 int check_ap_tdls_prohibited(u8 *pframe, u8 pkt_len)
 {
-	u8 tdls_prohibited_bit = 0x40; //bit(38); TDLS_prohibited
+	u8 tdls_prohibited_bit = 0x40; /* bit(38); TDLS_prohibited */
 
 	if (pkt_len < 5)
 	{
@@ -1265,7 +1240,7 @@ int check_ap_tdls_prohibited(u8 *pframe,
 
 	return false;
 }
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 void update_beacon_info(struct rtw_adapter *padapter, u8 *pframe, uint pkt_len, struct sta_info *psta)
 {
@@ -1275,8 +1250,8 @@ void update_beacon_info(struct rtw_adapt
 
 #ifdef CONFIG_TDLS
 	struct tdls_info *ptdlsinfo = &padapter->tdlsinfo;
-	u8 tdls_prohibited[] = { 0x00, 0x00, 0x00, 0x00, 0x10 }; //bit(38): TDLS_prohibited
-#endif //CONFIG_TDLS
+	u8 tdls_prohibited[] = { 0x00, 0x00, 0x00, 0x00, 0x10 }; /* bit(38): TDLS_prohibited */
+#endif /* CONFIG_TDLS */
 
 	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
 
@@ -1284,7 +1259,7 @@ void update_beacon_info(struct rtw_adapt
 		pIE = (struct ndis_802_11_variable_ies *)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
 
 		switch (pIE->ElementID) {
-		case _HT_EXTRA_INFO_IE_:	//HT info
+		case _HT_EXTRA_INFO_IE_:	/* HT info */
 			bwmode_update_check(padapter, pIE);
 			break;
 		case _ERPINFO_IE_:
@@ -1296,7 +1271,7 @@ void update_beacon_info(struct rtw_adapt
 			if (check_ap_tdls_prohibited(pIE->data, pIE->Length) == true)
 				ptdlsinfo->ap_prohibited = true;
 			break;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 		default:
 			break;
 		}
@@ -1333,7 +1308,7 @@ void process_csa_ie(struct rtw_adapter *
 		i += (pIE->Length + 2);
 	}
 }
-#endif //CONFIG_DFS
+#endif /* CONFIG_DFS */
 
 unsigned int is_ap_in_tkip(struct rtw_adapter *padapter)
 {
@@ -1549,11 +1524,11 @@ void enable_rate_adaptive(struct rtw_ada
 
 void set_sta_rate(struct rtw_adapter *padapter, struct sta_info *psta)
 {
-	//rate adaptive
+	/* rate adaptive */
 	enable_rate_adaptive(padapter, psta->mac_id);
 }
 
-// Update RRSR and Rate for USERATE
+/*  Update RRSR and Rate for USERATE */
 void update_tx_basic_rate(struct rtw_adapter *padapter, u8 wirelessmode)
 {
 	unsigned char supported_rates[NDIS_802_11_LENGTH_RATES_EX];
@@ -1561,20 +1536,20 @@ void update_tx_basic_rate(struct rtw_ada
 #ifdef CONFIG_P2P
 	struct wifidirect_info*	pwdinfo = &padapter->wdinfo;
 
-	//	Added by Albert 2011/03/22
-	//	In the P2P mode, the driver should not support the b mode.
-	//	So, the Tx packet shouldn't use the CCK rate
+	/* 	Added by Albert 2011/03/22 */
+	/* 	In the P2P mode, the driver should not support the b mode. */
+	/* 	So, the Tx packet shouldn't use the CCK rate */
 	if (!rtw_p2p_chk_state(pwdinfo, P2P_STATE_NONE))
 		return;
-#endif //CONFIG_P2P
+#endif /* CONFIG_P2P */
 #ifdef CONFIG_INTEL_WIDI
 	if (padapter->mlmepriv.widi_state != INTEL_WIDI_STATE_NONE)
 		return;
-#endif //CONFIG_INTEL_WIDI
+#endif /* CONFIG_INTEL_WIDI */
 
 	memset(supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);
 
-	//clear B mod if current channel is in 5G band, avoid tx cck rate in 5G band.
+	/* clear B mod if current channel is in 5G band, avoid tx cck rate in 5G band. */
 	if (pmlmeext->cur_channel > 14)
 		wirelessmode &= ~(WIRELESS_11B);
 
@@ -1674,13 +1649,13 @@ void update_IOT_info(struct rtw_adapter
 		case ralinkAP:
 			pmlmeinfo->turboMode_cts2self = 0;
 			pmlmeinfo->turboMode_rtsen = 1;
-			//disable high power
+			/* disable high power */
 			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
 			break;
 		case realtekAP:
-			//rtw_write16(padapter, 0x4cc, 0xffff);
-			//rtw_write16(padapter, 0x546, 0x01c0);
-			//disable high power
+			/* rtw_write16(padapter, 0x4cc, 0xffff); */
+			/* rtw_write16(padapter, 0x546, 0x01c0); */
+			/* disable high power */
 			Switch_DM_Func(padapter, (~DYNAMIC_FUNC_HP), false);
 			break;
 		default:
@@ -1696,12 +1671,12 @@ void update_capinfo(struct rtw_adapter *
 	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
 	bool		ShortPreamble;
 
-	// Check preamble mode, 2005.01.06, by rcnjko.
-	// Mark to update preamble value forever, 2008.03.18 by lanhsin
-	//if (pMgntInfo->RegPreambleMode == PREAMBLE_AUTO)
+	/*  Check preamble mode, 2005.01.06, by rcnjko. */
+	/*  Mark to update preamble value forever, 2008.03.18 by lanhsin */
+	/* if (pMgntInfo->RegPreambleMode == PREAMBLE_AUTO) */
 	{
-		if (updateCap & cShortPreamble) { // Short Preamble
-			if (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) // PREAMBLE_LONG or PREAMBLE_AUTO
+		if (updateCap & cShortPreamble) { /*  Short Preamble */
+			if (pmlmeinfo->preamble_mode != PREAMBLE_SHORT) /*  PREAMBLE_LONG or PREAMBLE_AUTO */
 			{
 				ShortPreamble = true;
 				pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
@@ -1709,8 +1684,8 @@ void update_capinfo(struct rtw_adapter *
 			}
 		}
 		else
-		{ // Long Preamble
-			if (pmlmeinfo->preamble_mode != PREAMBLE_LONG)  // PREAMBLE_SHORT or PREAMBLE_AUTO
+		{ /*  Long Preamble */
+			if (pmlmeinfo->preamble_mode != PREAMBLE_LONG)  /*  PREAMBLE_SHORT or PREAMBLE_AUTO */
 			{
 				ShortPreamble = false;
 				pmlmeinfo->preamble_mode = PREAMBLE_LONG;
@@ -1720,23 +1695,23 @@ void update_capinfo(struct rtw_adapter *
 	}
 
 	if (updateCap & cIBSS) {
-		//Filen: See 802.11-2007 p.91
+		/* Filen: See 802.11-2007 p.91 */
 		pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
 	}
 	else
 	{
-		//Filen: See 802.11-2007 p.90
+		/* Filen: See 802.11-2007 p.90 */
 		if (pmlmeext->cur_wireless_mode & (WIRELESS_11G | WIRELESS_11_24N))
 		{
 			if ((updateCap & cShortSlotTime) /* && (!(pMgntInfo->pHTInfo->RT2RT_HT_Mode & RT_HT_CAP_USE_LONG_PREAMBLE)) */)
-			{ // Short Slot Time
+			{ /*  Short Slot Time */
 				if (pmlmeinfo->slotTime != SHORT_SLOT_TIME)
 				{
 					pmlmeinfo->slotTime = SHORT_SLOT_TIME;
 				}
 			}
 			else
-			{ // Long Slot Time
+			{ /*  Long Slot Time */
 				if (pmlmeinfo->slotTime != NON_SHORT_SLOT_TIME)
 				{
 					pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
@@ -1749,7 +1724,7 @@ void update_capinfo(struct rtw_adapter *
 		}
 		else
 		{
-			//B Mode
+			/* B Mode */
 			pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
 		}
 	}
@@ -1768,7 +1743,7 @@ void update_wireless_mode(struct rtw_ada
 	unsigned char			*rate = cur_network->SupportedRates;
 #ifdef CONFIG_CONCURRENT_MODE
 	struct rtw_adapter *pbuddy_adapter = padapter->pbuddy_adapter;
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 
 	ratelen = rtw_get_rateset_len(cur_network->SupportedRates);
 
@@ -1809,22 +1784,14 @@ void update_wireless_mode(struct rtw_ada
 
 	pmlmeext->cur_wireless_mode = network_type & padapter->registrypriv.wireless_mode;
 
-	//For STA mode, driver need to modify initial data rate, or MAC will use wrong tx rate.
-	//Modified by Thomas 2012-12-3
+	/* For STA mode, driver need to modify initial data rate, or MAC will use wrong tx rate. */
+	/* Modified by Thomas 2012-12-3 */
 	mask = update_supported_rate(cur_network->SupportedRates, ratelen);
 	init_rate = get_highest_rate_idx(mask)&0x3f;
 	rtw_hal_set_hwreg(padapter, HW_VAR_INIT_DATA_RATE,  (u8 *)&init_rate);
 
-/*
-	if ((pmlmeext->cur_wireless_mode==WIRELESS_11G) ||
-		(pmlmeext->cur_wireless_mode==WIRELESS_11BG))//WIRELESS_MODE_G)
-		SIFS_Timer = 0x0a0a;//CCK
-	else
-		SIFS_Timer = 0x0e0e;//pHalData->SifsTime; //OFDM
-*/
-
-	SIFS_Timer = 0x0a0a0808; //0x0808 -> for CCK, 0x0a0a -> for OFDM
-                             //change this value if having IOT issues.
+	SIFS_Timer = 0x0a0a0808; /* 0x0808 -> for CCK, 0x0a0a -> for OFDM */
+                             /* change this value if having IOT issues. */
 
 	rtw_hal_set_hwreg(padapter, HW_VAR_RESP_SIFS,  (u8 *)&SIFS_Timer);
 
@@ -1836,7 +1803,7 @@ void update_wireless_mode(struct rtw_ada
 #ifdef CONFIG_CONCURRENT_MODE
 		if (pbuddy_adapter && (pmlmeext->cur_wireless_mode & WIRELESS_11A))
 			update_mgnt_tx_rate(pbuddy_adapter, IEEE80211_OFDM_RATE_6MB);
-#endif //CONFIG_CONCURRENT_MODE
+#endif /* CONFIG_CONCURRENT_MODE */
 	}
 }
 
@@ -1852,7 +1819,7 @@ void update_bmc_sta_support_rate(struct
 
 	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
 	{
-		// Only B, B/G, and B/G/N AP could use CCK rate
+		/*  Only B, B/G, and B/G/N AP could use CCK rate */
 		memcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates), rtw_basic_rate_cck, 4);
 	}
 	else
@@ -1955,7 +1922,7 @@ int rtw_handle_dualmac(struct rtw_adapte
 	if (init) {
 		if ((dvobj->NumInterfaces == 2) && (adapter->registrypriv.mac_phy_mode != 1)) {
 			dvobj->DualMacMode = true;
-			// temply disable IPS For 92D-VC
+			/*  temply disable IPS For 92D-VC */
 			adapter->registrypriv.ips_mode = IPS_NONE;
 		}
 
@@ -1972,19 +1939,19 @@ int rtw_handle_dualmac(struct rtw_adapte
 		} else {
 			adapter->pbuddy_adapter = pbuddy_padapter;
 			pbuddy_padapter->pbuddy_adapter = adapter;
-			// clear global value
+			/*  clear global value */
 			pbuddy_padapter = NULL;
 			DBG_8192D("%s(): pbuddy_padapter exist, Exchange Information\n",__func__);
 		}
 
 		if (dvobj->InterfaceNumber == 0) {
-			//set adapter_type/iface type
+			/* set adapter_type/iface type */
 			adapter->isprimary = true;
 			adapter->adapter_type = PRIMARY_ADAPTER;
 			adapter->iface_type = IFACE_PORT0;
 			DBG_8192D("%s(): PRIMARY_ADAPTER\n",__func__);
 		} else {
-			//set adapter_type/iface type
+			/* set adapter_type/iface type */
 			adapter->isprimary = false;
 			adapter->adapter_type = SECONDARY_ADAPTER;
 			adapter->iface_type = IFACE_PORT1;
--- a/drivers/staging/rtl8192du/core/rtw_xmit.c
+++ b/drivers/staging/rtl8192du/core/rtw_xmit.c
@@ -52,8 +52,8 @@ _func_enter_;
 
 	_rtw_spinlock_init(&psta_xmitpriv->lock);
 
-	//for (i = 0 ; i < MAX_NUMBLKS; i++)
-	//	_init_txservq(&(psta_xmitpriv->blk_q[i]));
+	/* for (i = 0 ; i < MAX_NUMBLKS; i++) */
+	/* 	_init_txservq(&(psta_xmitpriv->blk_q[i])); */
 
 	_init_txservq(&psta_xmitpriv->be_q);
 	_init_txservq(&psta_xmitpriv->bk_q);
@@ -74,8 +74,8 @@ s32	_rtw_init_xmit_priv(struct xmit_priv
 
 _func_enter_;
 
-	// We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc().
-	//memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));
+	/*  We don't need to memset padapter->XXX to zero, because adapter is allocated by rtw_zvmalloc(). */
+	/* memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv)); */
 
 	_rtw_spinlock_init(&pxmitpriv->lock);
 	_rtw_init_sema(&pxmitpriv->xmit_sema, 0);
@@ -87,8 +87,8 @@ _func_enter_;
 
 	pxmitpriv->adapter = padapter;
 
-	//for (i = 0 ; i < MAX_NUMBLKS; i++)
-	//	_rtw_init_queue(&pxmitpriv->blk_strms[i]);
+	/* for (i = 0 ; i < MAX_NUMBLKS; i++) */
+	/* 	_rtw_init_queue(&pxmitpriv->blk_strms[i]); */
 
 	_rtw_init_queue(&pxmitpriv->be_pending);
 	_rtw_init_queue(&pxmitpriv->bk_pending);
@@ -96,8 +96,8 @@ _func_enter_;
 	_rtw_init_queue(&pxmitpriv->vo_pending);
 	_rtw_init_queue(&pxmitpriv->bm_pending);
 
-	//_rtw_init_queue(&pxmitpriv->legacy_dz_queue);
-	//_rtw_init_queue(&pxmitpriv->apsd_queue);
+	/* _rtw_init_queue(&pxmitpriv->legacy_dz_queue); */
+	/* _rtw_init_queue(&pxmitpriv->apsd_queue); */
 
 	_rtw_init_queue(&pxmitpriv->free_xmit_queue);
 
@@ -117,8 +117,8 @@ _func_enter_;
 		goto exit;
 	}
 	pxmitpriv->pxmit_frame_buf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_frame_buf), 4);
-	//pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 -
-	//						((SIZE_PTR) (pxmitpriv->pallocated_frame_buf) &3);
+	/* pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 - */
+	/* 						((SIZE_PTR) (pxmitpriv->pallocated_frame_buf) &3); */
 
 	pxframe = (struct xmit_frame*) pxmitpriv->pxmit_frame_buf;
 
@@ -144,7 +144,7 @@ _func_enter_;
 	pxmitpriv->frag_len = MAX_FRAG_THRESHOLD;
 
 
-	//init xmit_buf
+	/* init xmit_buf */
 	_rtw_init_queue(&pxmitpriv->free_xmitbuf_queue);
 	_rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue);
 
@@ -157,8 +157,8 @@ _func_enter_;
 	}
 
 	pxmitpriv->pxmitbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmitbuf), 4);
-	//pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 -
-	//						((SIZE_PTR) (pxmitpriv->pallocated_xmitbuf) &3);
+	/* pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 - */
+	/* 						((SIZE_PTR) (pxmitpriv->pallocated_xmitbuf) &3); */
 
 	pxmitbuf = (struct xmit_buf*)pxmitpriv->pxmitbuf;
 
@@ -170,18 +170,6 @@ _func_enter_;
 		pxmitbuf->padapter = padapter;
 		pxmitbuf->ext_tag = false;
 
-/*
-		pxmitbuf->pallocated_buf = rtw_zmalloc(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ);
-		if (pxmitbuf->pallocated_buf == NULL)
-		{
-			res = _FAIL;
-			goto exit;
-		}
-
-		pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);
-		//pxmitbuf->pbuf = pxmitbuf->pallocated_buf + XMITBUF_ALIGN_SZ -((SIZE_PTR) (pxmitbuf->pallocated_buf) &(XMITBUF_ALIGN_SZ-1));
-*/
-
 		if ((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,(MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ))) == _FAIL) {
 			res= _FAIL;
 			goto exit;
@@ -200,7 +188,7 @@ _func_enter_;
 
 	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
 
-	// Init xmit extension buff
+	/*  Init xmit extension buff */
 	_rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue);
 
 	pxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(NR_XMIT_EXTBUFF * sizeof(struct xmit_buf) + 4);
@@ -223,17 +211,6 @@ _func_enter_;
 		pxmitbuf->padapter = padapter;
 		pxmitbuf->ext_tag = true;
 
-/*
-		pxmitbuf->pallocated_buf = rtw_zmalloc(MAX_XMIT_EXTBUF_SZ);
-		if (pxmitbuf->pallocated_buf == NULL)
-		{
-			res = _FAIL;
-			goto exit;
-		}
-
-		pxmitbuf->pbuf = (u8 *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitbuf->pallocated_buf), 4);
-*/
-
 		if ((res=rtw_os_xmit_resource_alloc(padapter, pxmitbuf,MAX_XMIT_EXTBUF_SZ + XMITBUF_ALIGN_SZ)) == _FAIL) {
 			res= _FAIL;
 			goto exit;
@@ -256,7 +233,7 @@ _func_enter_;
 
 	_rtw_init_sema(&(pxmitpriv->tx_retevt), 0);
 
-	//per AC pending irp
+	/* per AC pending irp */
 	pxmitpriv->beq_cnt = 0;
 	pxmitpriv->bkq_cnt = 0;
 	pxmitpriv->viq_cnt = 0;
@@ -290,8 +267,8 @@ void  rtw_mfree_xmit_priv_lock (struct x
 	_rtw_spinlock_free(&pxmitpriv->vo_pending.lock);
 	_rtw_spinlock_free(&pxmitpriv->bm_pending.lock);
 
-	//_rtw_spinlock_free(&pxmitpriv->legacy_dz_queue.lock);
-	//_rtw_spinlock_free(&pxmitpriv->apsd_queue.lock);
+	/* _rtw_spinlock_free(&pxmitpriv->legacy_dz_queue.lock); */
+	/* _rtw_spinlock_free(&pxmitpriv->apsd_queue.lock); */
 
 	_rtw_spinlock_free(&pxmitpriv->free_xmit_queue.lock);
 	_rtw_spinlock_free(&pxmitpriv->free_xmitbuf_queue.lock);
@@ -337,7 +314,7 @@ void _rtw_free_xmit_priv (struct xmit_pr
 		rtw_vmfree(pxmitpriv->pallocated_xmitbuf, NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
 	}
 
-	// free xmit extension buff
+	/*  free xmit extension buff */
 	_rtw_spinlock_free(&pxmitpriv->free_xmit_extbuf_queue.lock);
 
 	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
@@ -376,15 +353,15 @@ static void update_attrib_vcs_info(struc
 	{
 		sz = padapter->xmitpriv.frag_len;
 	}
-	else //no frag
+	else /* no frag */
 	{
 		sz = pattrib->last_txcmdsz;
 	}
 
-	// (1) RTS_Threshold is compared to the MPDU, not MSDU.
-	// (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame.
-	//		Other fragments are protected by previous fragment.
-	//		So we only need to check the length of first fragment.
+	/*  (1) RTS_Threshold is compared to the MPDU, not MSDU. */
+	/*  (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame. */
+	/* 		Other fragments are protected by previous fragment. */
+	/* 		So we only need to check the length of first fragment. */
 	if (pmlmeext->cur_wireless_mode < WIRELESS_11_24N  || padapter->registrypriv.wifi_spec) {
 		if (sz > padapter->registrypriv.rts_thresh) {
 			pattrib->vcs_mode = RTS_CTS;
@@ -398,7 +375,7 @@ static void update_attrib_vcs_info(struc
 		}
 	} else {
 		while (true) {
-			//IOT action
+			/* IOT action */
 			if ((pmlmeinfo->assoc_AP_vendor == atherosAP) && (pattrib->ampdu_en==true) &&
 				(padapter->securitypriv.dot11PrivacyAlgrthm == _AES_))
 			{
@@ -407,7 +384,7 @@ static void update_attrib_vcs_info(struc
 			}
 
 
-			//check ERP protection
+			/* check ERP protection */
 			if (psta->rtsen || psta->cts2self) {
 				if (psta->rtsen)
 					pattrib->vcs_mode = RTS_CTS;
@@ -417,7 +394,7 @@ static void update_attrib_vcs_info(struc
 				break;
 			}
 
-			//check HT op mode
+			/* check HT op mode */
 			if (pattrib->ht_en) {
 				u8 HTOpMode = pmlmeinfo->HT_protection;
 				if ((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||
@@ -427,16 +404,16 @@ static void update_attrib_vcs_info(struc
 				}
 			}
 
-			//check rts
+			/* check rts */
 			if (sz > padapter->registrypriv.rts_thresh)
 			{
 				pattrib->vcs_mode = RTS_CTS;
 				break;
 			}
 
-			//to do list: check MIMO power save condition.
+			/* to do list: check MIMO power save condition. */
 
-			//check AMPDU aggregation for TXOP
+			/* check AMPDU aggregation for TXOP */
 			if (pattrib->ampdu_en==true)
 			{
 				pattrib->vcs_mode = RTS_CTS;
@@ -451,18 +428,12 @@ static void update_attrib_vcs_info(struc
 
 static void update_attrib_phy_info(struct pkt_attrib *pattrib, struct sta_info *psta)
 {
-	/*if (psta->rtsen)
-		pattrib->vcs_mode = RTS_CTS;
-	else if (psta->cts2self)
-		pattrib->vcs_mode = CTS_TO_SELF;
-	else
-		pattrib->vcs_mode = NONE_VCS;*/
 
 	pattrib->mdata = 0;
 	pattrib->eosp = 0;
 	pattrib->triggered=0;
 
-	//qos_en, ht_en, init rate, ,bw, ch_offset, sgi
+	/* qos_en, ht_en, init rate, ,bw, ch_offset, sgi */
 	pattrib->qos_en = psta->qos_option;
 	pattrib->ht_en = psta->htpriv.ht_option;
 	pattrib->raid = psta->raid;
@@ -471,13 +442,6 @@ static void update_attrib_phy_info(struc
 	pattrib->sgi= psta->htpriv.sgi;
 	pattrib->ampdu_en = false;
 
-	//if (pattrib->ht_en && psta->htpriv.ampdu_enable)
-	//{
-	//	if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
-	//		pattrib->ampdu_en = true;
-	//}
-
-
 	pattrib->retry_ctrl = false;
 }
 
@@ -523,14 +487,14 @@ static void set_qos(struct pkt_file *ppk
 	_rtw_open_pktfile(ppktfile->pkt, ppktfile);
 	_rtw_pktfile_read(ppktfile, (unsigned char*)&etherhdr, ETH_HLEN);
 
-	// get UserPriority from IP hdr
+	/*  get UserPriority from IP hdr */
 	if (pattrib->ether_type == 0x0800) {
 		_rtw_pktfile_read(ppktfile, (u8*)&ip_hdr, sizeof(ip_hdr));
-//		UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3;
+/* 		UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3; */
 		UserPriority = ip_hdr.tos >> 5;
 	} else if (pattrib->ether_type == 0x888e) {
-		// "When priority processing of data frames is supported,
-		// a STA's SME should send EAPOL-Key frames at the highest priority."
+		/*  "When priority processing of data frames is supported, */
+		/*  a STA's SME should send EAPOL-Key frames at the highest priority." */
 		UserPriority = 7;
 	}
 
@@ -584,27 +548,27 @@ static s32 update_attrib(struct rtw_adap
 
 	if (ETH_P_IP == pattrib->ether_type)
 	{
-		// The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time
-		// to prevent DHCP protocol fail
+		/*  The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time */
+		/*  to prevent DHCP protocol fail */
 		u8 tmp[24];
 		_rtw_pktfile_read(&pktfile, &tmp[0], 24);
 		pattrib->dhcp_pkt = 0;
-		if (pktfile.pkt_len > 282) {//MINIMUM_DHCP_PACKET_SIZE) {
-			if (ETH_P_IP == pattrib->ether_type) {// IP header
+		if (pktfile.pkt_len > 282) {/* MINIMUM_DHCP_PACKET_SIZE) { */
+			if (ETH_P_IP == pattrib->ether_type) {/*  IP header */
 				if (((tmp[21] == 68) && (tmp[23] == 67)) ||
 					((tmp[21] == 67) && (tmp[23] == 68))) {
-					// 68 : UDP BOOTP client
-					// 67 : UDP BOOTP server
+					/*  68 : UDP BOOTP client */
+					/*  67 : UDP BOOTP server */
 					RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("======================update_attrib: get DHCP Packet\n"));
-					// Use low rate to send DHCP packet.
-					//if (pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom)
-					//{
-					//	tcb_desc->DataRate = MgntQuery_TxRateExcludeCCKRates(ieee);//0xc;//ofdm 6m
-					//	tcb_desc->bTxDisableRateFallBack = false;
-					//}
-					//else
-					//	pTcb->DataRate = Adapter->MgntInfo.LowestBasicRate;
-					//RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate));
+					/*  Use low rate to send DHCP packet. */
+					/* if (pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom) */
+					/*  */
+					/* 	tcb_desc->DataRate = MgntQuery_TxRateExcludeCCKRates(ieee); 0xc; ofdm 6m */
+					/* 	tcb_desc->bTxDisableRateFallBack = false; */
+					/*  */
+					/* else */
+					/* 	pTcb->DataRate = Adapter->MgntInfo.LowestBasicRate; */
+					/* RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate)); */
 					pattrib->dhcp_pkt = 1;
 				}
 			}
@@ -617,7 +581,7 @@ static s32 update_attrib(struct rtw_adap
 	}
 
 #ifdef CONFIG_LPS
-	// If EAPOL , ARP , OR DHCP packet, driver must be in active mode.
+	/*  If EAPOL , ARP , OR DHCP packet, driver must be in active mode. */
 	if ((pattrib->ether_type == 0x0806) || (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1))
 	{
 		rtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_SPECIAL_PACKET, 1);
@@ -626,12 +590,12 @@ static s32 update_attrib(struct rtw_adap
 
 	bmcast = IS_MCAST(pattrib->ra);
 
-	// get sta_info
+	/*  get sta_info */
 	if (bmcast) {
 		psta = rtw_get_bcmc_stainfo(padapter);
 	} else {
 		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
-		if (psta == NULL)	{ // if we cannot get psta => drrp the pkt
+		if (psta == NULL)	{ /*  if we cannot get psta => drrp the pkt */
 			RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail, ra:%pM\n", pattrib->ra));
 			#ifdef DBG_TX_DROP_FRAME
 			DBG_8192D("DBG_TX_DROP_FRAME %s get sta_info fail, ra:%pM\n", __func__, pattrib->ra);
@@ -653,7 +617,7 @@ static s32 update_attrib(struct rtw_adap
 	}
 	else
 	{
-		// if we cannot get psta => drop the pkt
+		/*  if we cannot get psta => drop the pkt */
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_alert_, ("\nupdate_attrib => get sta_info fail, ra:%pM\n", pattrib->ra));
 		#ifdef DBG_TX_DROP_FRAME
 		DBG_8192D("DBG_TX_DROP_FRAME %s get sta_info fail, ra:%pM\n", __func__, pattrib->ra);
@@ -663,8 +627,8 @@ static s32 update_attrib(struct rtw_adap
 	}
 
 	pattrib->ack_policy = 0;
-	// get ether_hdr_len
-	pattrib->pkt_hdrlen = ETH_HLEN;//(pattrib->ether_type == 0x8100) ? (14 + 4): 14; //vlan tag
+	/*  get ether_hdr_len */
+	pattrib->pkt_hdrlen = ETH_HLEN;
 
 	pattrib->hdrlen = WLAN_HDR_A3_LEN;
 	pattrib->subtype = WIFI_DATA_TYPE;
@@ -688,10 +652,7 @@ static s32 update_attrib(struct rtw_adap
 		}
 	}
 
-	//pattrib->priority = 5; //force to used VI queue, for testing
-
-	if (psta->ieee8021x_blocked == true)
-	{
+	if (psta->ieee8021x_blocked == true) {
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("\n psta->ieee8021x_blocked == true\n"));
 
 		pattrib->encrypt = 0;
@@ -785,7 +746,7 @@ static s32 update_attrib(struct rtw_adap
 #ifdef CONFIG_CONCURRENT_MODE
 	if ((pattrib->encrypt && bmcast) || (pattrib->encrypt ==_WEP40_) || (pattrib->encrypt ==_WEP104_))
 	{
-		pattrib->bswenc = true;//force using sw enc.
+		pattrib->bswenc = true;/* force using sw enc. */
 	}
 #endif
 
@@ -825,9 +786,9 @@ static s32 xmitframe_addmic(struct rtw_a
 
 _func_enter_;
 
-	if (pattrib->encrypt ==_TKIP_)//if (psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_)
+	if (pattrib->encrypt ==_TKIP_)/* if (psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_) */
 	{
-		//encode mic code
+		/* encode mic code */
 		if (stainfo!= NULL) {
 			u8 null_key[16]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
 
@@ -840,41 +801,41 @@ _func_enter_;
 			if (bmcst)
 			{
 				if (_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16)==true) {
-					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
-					//rtw_msleep_os(10);
+					/* DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n"); */
+					/* rtw_msleep_os(10); */
 					return _FAIL;
 				}
-				//start to calculate the mic code
+				/* start to calculate the mic code */
 				rtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);
 			}
 			else
 			{
 				if (_rtw_memcmp(&stainfo->dot11tkiptxmickey.skey[0],null_key, 16)==true) {
-					//DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
-					//rtw_msleep_os(10);
+					/* DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n"); */
+					/* rtw_msleep_os(10); */
 					return _FAIL;
 				}
-				//start to calculate the mic code
+				/* start to calculate the mic code */
 				rtw_secmicsetkey(&micdata, &stainfo->dot11tkiptxmickey.skey[0]);
 			}
 
-			if (pframe[1]&1) {   //ToDS==1
-				rtw_secmicappend(&micdata, &pframe[16], 6);  //DA
-				if (pframe[1]&2)  //From Ds==1
+			if (pframe[1]&1) {   /* ToDS==1 */
+				rtw_secmicappend(&micdata, &pframe[16], 6);  /* DA */
+				if (pframe[1]&2)  /* From Ds==1 */
 					rtw_secmicappend(&micdata, &pframe[24], 6);
 				else
 				rtw_secmicappend(&micdata, &pframe[10], 6);
 			}
-			else {	//ToDS==0
-				rtw_secmicappend(&micdata, &pframe[4], 6);   //DA
-				if (pframe[1]&2)  //From Ds==1
+			else {	/* ToDS==0 */
+				rtw_secmicappend(&micdata, &pframe[4], 6);   /* DA */
+				if (pframe[1]&2)  /* From Ds==1 */
 					rtw_secmicappend(&micdata, &pframe[16], 6);
 				else
 					rtw_secmicappend(&micdata, &pframe[10], 6);
 
 			}
 
-                    //if (pqospriv->qos_option==1)
+                    /* if (pqospriv->qos_option==1) */
                     if (pattrib->qos_en)
 				priority[0]=(u8)pxmitframe->attrib.priority;
 
@@ -908,7 +869,7 @@ _func_enter_;
 			RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: mic[0]=0x%.2x ,mic[1]=0x%.2x ,mic[2]=0x%.2x ,mic[3]=0x%.2x\n\
   mic[4]=0x%.2x ,mic[5]=0x%.2x ,mic[6]=0x%.2x ,mic[7]=0x%.2x !!!!\n",
 				mic[0],mic[1],mic[2],mic[3],mic[4],mic[5],mic[6],mic[7]));
-			//add mic code  and add the mic code length in last_txcmdsz
+			/* add mic code  and add the mic code length in last_txcmdsz */
 
 			memcpy(payload, &(mic[0]),8);
 			pattrib->last_txcmdsz+=8;
@@ -932,14 +893,14 @@ _func_exit_;
 
 static s32 xmitframe_swencrypt(struct rtw_adapter *padapter, struct xmit_frame *pxmitframe) {
 	struct	pkt_attrib	 *pattrib = &pxmitframe->attrib;
-	//struct	security_priv	*psecuritypriv=&padapter->securitypriv;
+	/* struct	security_priv	*psecuritypriv=&padapter->securitypriv; */
 
 _func_enter_;
 
-	//if ((psecuritypriv->sw_encrypt)||(pattrib->bswenc))
+	/* if ((psecuritypriv->sw_encrypt)||(pattrib->bswenc)) */
 	if (pattrib->bswenc)
 	{
-		//DBG_8192D("start xmitframe_swencrypt\n");
+		/* DBG_8192D("start xmitframe_swencrypt\n"); */
 		RT_TRACE(_module_rtl871x_xmit_c_,_drv_alert_,("### xmitframe_swencrypt\n"));
 		switch (pattrib->encrypt) {
 		case _WEP40_:
@@ -978,7 +939,7 @@ s32 rtw_make_wlanhdr (struct rtw_adapter
 	struct sta_priv		*pstapriv = &padapter->stapriv;
 	struct sta_info *ptdls_sta=NULL, *psta_backup=NULL;
 	u8 direct_link=0;
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	int res = _SUCCESS;
 	u16 *fctrl = &pwlanhdr->frame_ctl;
@@ -1006,28 +967,28 @@ _func_enter_;
 	if (pattrib->subtype & WIFI_DATA_TYPE)
 	{
 		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
-			//to_ds = 1, fr_ds = 0;
+			/* to_ds = 1, fr_ds = 0; */
 #ifdef CONFIG_TDLS
 			if ((ptdlsinfo->setup_state == TDLS_LINKED_STATE)) {
 				ptdls_sta = rtw_get_stainfo(pstapriv, pattrib->dst);
 				if ((ptdls_sta!=NULL)&&(ptdls_sta->tdls_sta_state & TDLS_LINKED_STATE)&&(pattrib->ether_type!=0x0806)) {
-					//TDLS data transfer, ToDS=0, FrDs=0
+					/* TDLS data transfer, ToDS=0, FrDs=0 */
 					memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
 					memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 					memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
 					direct_link=1;
 				} else {
-					// 1.Data transfer to AP
-					// 2.Arp pkt will relayed by AP
+					/*  1.Data transfer to AP */
+					/*  2.Arp pkt will relayed by AP */
 					SetToDs(fctrl);
 					memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
 					memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
 					memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
 				}
 			} else
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 			{
-				//Data transfer to AP
+				/* Data transfer to AP */
 				SetToDs(fctrl);
 				memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
 				memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
@@ -1039,7 +1000,7 @@ _func_enter_;
 
 		}
 		else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true)) {
-			//to_ds = 0, fr_ds = 1;
+			/* to_ds = 0, fr_ds = 1; */
 			SetFrDs(fctrl);
 			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
 			memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);
@@ -1081,9 +1042,9 @@ _func_enter_;
 			SetAckpolicy(qc, pattrib->ack_policy);
 		}
 
-		//TODO: fill HT Control Field
+		/* TODO: fill HT Control Field */
 
-		//Update Seq Num will be handled by f/w
+		/* Update Seq Num will be handled by f/w */
 		{
 			if (psta) {
 #ifdef CONFIG_TDLS
@@ -1092,7 +1053,7 @@ _func_enter_;
 					psta_backup = psta;
 					psta = ptdls_sta;
 				}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 				psta->sta_xmitpriv.txseq_tid[pattrib->priority]++;
 				psta->sta_xmitpriv.txseq_tid[pattrib->priority] &= 0xFFF;
@@ -1102,37 +1063,37 @@ _func_enter_;
 				SetSeqNum(hdr, pattrib->seqnum);
 
 
-				//check if enable ampdu
+				/* check if enable ampdu */
 				if (pattrib->ht_en && psta->htpriv.ampdu_enable)
 				{
 					if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
 					pattrib->ampdu_en = true;
 				}
 
-				//re-check if enable ampdu by BA_starting_seqctrl
+				/* re-check if enable ampdu by BA_starting_seqctrl */
 				if (pattrib->ampdu_en == true)
 				{
 					u16 tx_seq;
 
 					tx_seq = psta->BA_starting_seqctrl[pattrib->priority & 0x0f];
 
-					//check BA_starting_seqctrl
+					/* check BA_starting_seqctrl */
 					if (SN_LESS(pattrib->seqnum, tx_seq))
 					{
-						//DBG_8192D("tx ampdu seqnum(%d) < tx_seq(%d)\n", pattrib->seqnum, tx_seq);
-						pattrib->ampdu_en = false;//AGG BK
+						/* DBG_8192D("tx ampdu seqnum(%d) < tx_seq(%d)\n", pattrib->seqnum, tx_seq); */
+						pattrib->ampdu_en = false;/* AGG BK */
 					}
 					else if (SN_EQUAL(pattrib->seqnum, tx_seq))
 					{
 						psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (tx_seq+1)&0xfff;
 
-						pattrib->ampdu_en = true;//AGG EN
+						pattrib->ampdu_en = true;/* AGG EN */
 					}
 					else
 					{
-						//DBG_8192D("tx ampdu over run\n");
+						/* DBG_8192D("tx ampdu over run\n"); */
 						psta->BA_starting_seqctrl[pattrib->priority & 0x0f] = (pattrib->seqnum+1)&0xfff;
-						pattrib->ampdu_en = true;//AGG EN
+						pattrib->ampdu_en = true;/* AGG EN */
 					}
 
 				}
@@ -1146,8 +1107,8 @@ _func_enter_;
 						pattrib->icv_len=8;
 					}
 
-					//qos_en, ht_en, init rate, ,bw, ch_offset, sgi
-					//pattrib->qos_en = ptdls_sta->qos_option;
+					/* qos_en, ht_en, init rate, ,bw, ch_offset, sgi */
+					/* pattrib->qos_en = ptdls_sta->qos_option; */
 					pattrib->ht_en = ptdls_sta->htpriv.ht_option;
 					pattrib->raid = ptdls_sta->raid;
 					pattrib->bwmode = ptdls_sta->htpriv.bwmode;
@@ -1158,7 +1119,7 @@ _func_enter_;
 
 					psta = psta_backup;
 				}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 			}
 		}
@@ -1256,7 +1217,7 @@ int rtw_build_tdls_ies(struct rtw_adapte
 		case TUNNELED_PROBE_RSP:
 			rtw_build_tunneled_probe_rsp_ies(padapter, pxmitframe, pframe);
 			break;
-#endif //CONFIG_WFD
+#endif /* CONFIG_WFD */
 		default:
 			res=_FAIL;
 			break;
@@ -1288,9 +1249,9 @@ _func_enter_;
 		case TDLS_SETUP_REQUEST:
 		case TDLS_SETUP_RESPONSE:
 		case TDLS_SETUP_CONFIRM:
-		case TDLS_TEARDOWN:	//directly to peer STA or via AP
+		case TDLS_TEARDOWN:	/* directly to peer STA or via AP */
 		case TDLS_PEER_TRAFFIC_INDICATION:
-		case TDLS_PEER_PSM_REQUEST:	//directly to peer STA or via AP
+		case TDLS_PEER_PSM_REQUEST:	/* directly to peer STA or via AP */
 		case TUNNELED_PROBE_REQ:
 		case TUNNELED_PROBE_RSP:
 			SetToDs(fctrl);
@@ -1307,7 +1268,7 @@ _func_enter_;
 			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
 			tdls_seq=1;
 			break;
-		case TDLS_DISCOVERY_REQUEST:	//unicast: directly to peer sta, Bcast: via AP
+		case TDLS_DISCOVERY_REQUEST:	/* unicast: directly to peer sta, Bcast: via AP */
 			if (_rtw_memcmp(pattrib->dst, baddr, ETH_ALEN))
 			{
 				SetToDs(fctrl);
@@ -1338,8 +1299,8 @@ _func_enter_;
 
 	psta = pattrib->psta;
 
-	//  1. update seq_num per link by sta_info
-	//  2. rewrite encrypt to _AES_, also rewrite iv_len, icv_len
+	/*   1. update seq_num per link by sta_info */
+	/*   2. rewrite encrypt to _AES_, also rewrite iv_len, icv_len */
 	if (tdls_seq==1) {
 		ptdls_sta=rtw_get_stainfo(pstapriv, pattrib->dst);
 		if (ptdls_sta) {
@@ -1415,7 +1376,7 @@ _func_enter_;
 	pframe = mem_start;
 	pframe += pattrib->hdrlen;
 
-	//adding icv, if necessary...
+	/* adding icv, if necessary... */
 	if (pattrib->iv_len)
 	{
 		if (psta != NULL)
@@ -1449,7 +1410,7 @@ _func_enter_;
 	llc_sz = rtw_put_snap(pframe, pattrib->ether_type);
 	pframe += llc_sz;
 
-	//pattrib->pktlen will be counted in rtw_build_tdls_ies
+	/* pattrib->pktlen will be counted in rtw_build_tdls_ies */
 	pattrib->pktlen = 0;
 
 	rtw_build_tdls_ies(padapter, pxmitframe, pframe, action);
@@ -1479,7 +1440,7 @@ _func_exit_;
 
 	return res;
 }
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 /*
  * Calculate wlan 802.11 packet MAX size from pkt_attrib
@@ -1489,11 +1450,11 @@ u32 rtw_calculate_wlan_pkt_size_by_attri
 {
 	u32	len = 0;
 
-	len = pattrib->hdrlen + pattrib->iv_len; // WLAN Header and IV
-	len += SNAP_SIZE + sizeof(u16); // LLC
+	len = pattrib->hdrlen + pattrib->iv_len; /*  WLAN Header and IV */
+	len += SNAP_SIZE + sizeof(u16); /*  LLC */
 	len += pattrib->pktlen;
-	if (pattrib->encrypt == _TKIP_) len += 8; // MIC
-	len += pattrib->icv_len; // ICV
+	if (pattrib->encrypt == _TKIP_) len += 8; /*  MIC */
+	len += pattrib->icv_len; /*  ICV */
 
 	return len;
 }
@@ -1521,8 +1482,8 @@ s32 rtw_xmitframe_coalesce(struct rtw_ad
 	u8 *pframe, *mem_start;
 
 	struct sta_info		*psta;
-	//struct sta_priv		*pstapriv = &padapter->stapriv;
-	//struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
+	/* struct sta_priv		*pstapriv = &padapter->stapriv; */
+	/* struct mlme_priv	*pmlmepriv = &padapter->mlmepriv; */
 	struct xmit_priv	*pxmitpriv = &padapter->xmitpriv;
 
 	struct pkt_attrib	*pattrib = &pxmitframe->attrib;
@@ -1564,7 +1525,7 @@ _func_enter_;
 	_rtw_pktfile_read(&pktfile, NULL, pattrib->pkt_hdrlen);
 
 	frg_inx = 0;
-	frg_len = pxmitpriv->frag_len - 4;//2346-4 = 2342
+	frg_len = pxmitpriv->frag_len - 4;/* 2346-4 = 2342 */
 
 	while (1)
 	{
@@ -1579,13 +1540,13 @@ _func_enter_;
 		pframe += pattrib->hdrlen;
 		mpdu_len -= pattrib->hdrlen;
 
-		//adding icv, if necessary...
+		/* adding icv, if necessary... */
 		if (pattrib->iv_len)
 		{
-			//if (check_fwstate(pmlmepriv, WIFI_MP_STATE))
-			//	psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
-			//else
-			//	psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+			/* if (check_fwstate(pmlmepriv, WIFI_MP_STATE)) */
+			/* 	psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv)); */
+			/* else */
+			/* 	psta = rtw_get_stainfo(pstapriv, pattrib->ra); */
 
 			if (psta != NULL)
 			{
@@ -1633,7 +1594,7 @@ _func_enter_;
 
 
 		if (bmcst) {
-			// don't do fragment to broadcat/multicast packets
+			/*  don't do fragment to broadcat/multicast packets */
 			mem_sz = _rtw_pktfile_read(&pktfile, pframe, pattrib->pktlen);
 		} else {
 			mem_sz = _rtw_pktfile_read(&pktfile, pframe, mpdu_len);
@@ -1887,7 +1848,7 @@ struct xmit_buf *rtw_alloc_xmitbuf(struc
 
 _func_enter_;
 
-	//DBG_8192D("+rtw_alloc_xmitbuf\n");
+	/* DBG_8192D("+rtw_alloc_xmitbuf\n"); */
 
 	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, irqL);
 
@@ -1909,7 +1870,7 @@ _func_enter_;
 		#ifdef DBG_XMIT_BUF
 		DBG_8192D("DBG_XMIT_BUF ALLOC no=%d,  free_xmitbuf_cnt=%d\n",pxmitbuf->no, pxmitpriv->free_xmitbuf_cnt);
 		#endif
-		//DBG_8192D("alloc, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt);
+		/* DBG_8192D("alloc, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt); */
 
 		pxmitbuf->priv_data = NULL;
 
@@ -1939,7 +1900,7 @@ s32 rtw_free_xmitbuf(struct xmit_priv *p
 
 _func_enter_;
 
-	//DBG_8192D("+rtw_free_xmitbuf\n");
+	/* DBG_8192D("+rtw_free_xmitbuf\n"); */
 
 	if (pxmitbuf==NULL)
 	{
@@ -1964,7 +1925,7 @@ _func_enter_;
 		rtw_list_insert_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
 
 		pxmitpriv->free_xmitbuf_cnt++;
-		//DBG_8192D("FREE, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt);
+		/* DBG_8192D("FREE, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt); */
 		#ifdef DBG_XMIT_BUF
 		DBG_8192D("DBG_XMIT_BUF FREE no=%d, free_xmitbuf_cnt=%d\n",pxmitbuf->no ,pxmitpriv->free_xmitbuf_cnt);
 		#endif
@@ -2028,12 +1989,12 @@ _func_enter_;
 		pxframe->pxmitbuf = NULL;
 
 		memset(&pxframe->attrib, 0, sizeof(struct pkt_attrib));
-		//pxframe->attrib.psta = NULL;
+		/* pxframe->attrib.psta = NULL; */
 
 		pxframe->frame_tag = DATA_FRAMETAG;
 
 		pxframe->pkt = NULL;
-		pxframe->pkt_offset = 1;//default use pkt_offset to fill tx desc
+		pxframe->pkt_offset = 1;/* default use pkt_offset to fill tx desc */
 
 #ifdef CONFIG_USB_TX_AGGREGATION
 		pxframe->agg_num = 1;
@@ -2132,7 +2093,7 @@ s32 rtw_xmitframe_enqueue(struct rtw_ada
 	{
 		RT_TRACE(_module_rtl871x_xmit_c_, _drv_err_,
 			 ("rtw_xmitframe_enqueue: drop xmit pkt for classifier fail\n"));
-//		pxmitframe->pkt = NULL;
+/* 		pxmitframe->pkt = NULL; */
 		return _FAIL;
 	}
 
@@ -2187,7 +2148,7 @@ _func_enter_;
 	if (pregpriv->wifi_spec==1)
 	{
 		int j, tmp, acirp_cnt[4];
-		//entry indx: 0->vo, 1->vi, 2->be, 3->bk.
+		/* entry indx: 0->vo, 1->vi, 2->be, 3->bk. */
 		acirp_cnt[0] = pxmitpriv->voq_cnt;
 		acirp_cnt[1] = pxmitpriv->viq_cnt;
 		acirp_cnt[2] = pxmitpriv->beq_cnt;
@@ -2232,8 +2193,8 @@ _func_enter_;
 			{
 				phwxmit->accnt--;
 
-				//Remove sta node when there is no pending packets.
-				if (_rtw_queue_empty(pframe_queue)) //must be done after get_next and before break
+				/* Remove sta node when there is no pending packets. */
+				if (_rtw_queue_empty(pframe_queue)) /* must be done after get_next and before break */
 					rtw_list_delete(&ptxservq->tx_pending);
 
 				goto exit;
@@ -2349,43 +2310,43 @@ void rtw_alloc_hwxmits(struct rtw_adapte
 
 	if (pxmitpriv->hwxmit_entry == 5)
 	{
-		//pxmitpriv->bmc_txqueue.head = 0;
-		//hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue;
+		/* pxmitpriv->bmc_txqueue.head = 0; */
+		/* hwxmits[0] .phwtxqueue = &pxmitpriv->bmc_txqueue; */
 		hwxmits[0] .sta_queue = &pxmitpriv->bm_pending;
 
-		//pxmitpriv->vo_txqueue.head = 0;
-		//hwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		/* pxmitpriv->vo_txqueue.head = 0; */
+		/* hwxmits[1] .phwtxqueue = &pxmitpriv->vo_txqueue; */
 		hwxmits[1] .sta_queue = &pxmitpriv->vo_pending;
 
-		//pxmitpriv->vi_txqueue.head = 0;
-		//hwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		/* pxmitpriv->vi_txqueue.head = 0; */
+		/* hwxmits[2] .phwtxqueue = &pxmitpriv->vi_txqueue; */
 		hwxmits[2] .sta_queue = &pxmitpriv->vi_pending;
 
-		//pxmitpriv->bk_txqueue.head = 0;
-		//hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		/* pxmitpriv->bk_txqueue.head = 0; */
+		/* hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue; */
 		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
 
-		//pxmitpriv->be_txqueue.head = 0;
-		//hwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue;
+		/* pxmitpriv->be_txqueue.head = 0; */
+		/* hwxmits[4] .phwtxqueue = &pxmitpriv->be_txqueue; */
 		hwxmits[4] .sta_queue = &pxmitpriv->be_pending;
 
 	}
 	else if (pxmitpriv->hwxmit_entry == 4)
 	{
-		//pxmitpriv->vo_txqueue.head = 0;
-		//hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue;
+		/* pxmitpriv->vo_txqueue.head = 0; */
+		/* hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue; */
 		hwxmits[0] .sta_queue = &pxmitpriv->vo_pending;
 
-		//pxmitpriv->vi_txqueue.head = 0;
-		//hwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue;
+		/* pxmitpriv->vi_txqueue.head = 0; */
+		/* hwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue; */
 		hwxmits[1] .sta_queue = &pxmitpriv->vi_pending;
 
-		//pxmitpriv->be_txqueue.head = 0;
-		//hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue;
+		/* pxmitpriv->be_txqueue.head = 0; */
+		/* hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue; */
 		hwxmits[2] .sta_queue = &pxmitpriv->be_pending;
 
-		//pxmitpriv->bk_txqueue.head = 0;
-		//hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue;
+		/* pxmitpriv->bk_txqueue.head = 0; */
+		/* hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue; */
 		hwxmits[3] .sta_queue = &pxmitpriv->bk_pending;
 	}
 	else
@@ -2410,9 +2371,9 @@ void rtw_init_hwxmits(struct hw_xmit *ph
 _func_enter_;
 	for (i = 0; i < entry; i++, phwxmit++)
 	{
-		//_rtw_spinlock_init(&phwxmit->xmit_lock);
-		//INIT_LIST_HEAD(&phwxmit->pending);
-		//phwxmit->txcmdcnt = 0;
+		/* _rtw_spinlock_init(&phwxmit->xmit_lock); */
+		/* INIT_LIST_HEAD(&phwxmit->pending); */
+		/* phwxmit->txcmdcnt = 0; */
 		phwxmit->accnt = 0;
 	}
 _func_exit_;
@@ -2429,15 +2390,15 @@ int rtw_br_client_tx(struct rtw_adapter
 		unsigned short vlan_hdr=0;
 		void *br_port = NULL;
 
-		//mac_clone_handle_frame(priv, skb);
+		/* mac_clone_handle_frame(priv, skb); */
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 		br_port = padapter->pnetdev->br_port;
-#else   // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 		rcu_read_lock();
 		br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
 		rcu_read_unlock();
-#endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 		spin_lock_bh(&padapter->br_ext_lock);
 		if (	!(skb->data[0] & 1) &&
 				br_port &&
@@ -2456,7 +2417,7 @@ int rtw_br_client_tx(struct rtw_adapter
 					*((unsigned short *)(skb->data+MACADDRLEN*2+2-i*2)) = *((unsigned short *)(skb->data+MACADDRLEN*2-2-i*2));
 				skb_pull(skb, 4);
 			}
-			//if SA == br_mac && skb== IP  => copy SIP to br_ip ?? why
+			/* if SA == br_mac && skb== IP  => copy SIP to br_ip ?? why */
 			if (!memcmp(skb->data+MACADDRLEN, padapter->br_mac, MACADDRLEN) &&
 				(*((unsigned short *)(skb->data+MACADDRLEN*2)) == __constant_htons(ETH_P_IP)))
 				memcpy(padapter->br_ip, skb->data+WLAN_ETHHDR_LEN+12, 4);
@@ -2501,9 +2462,9 @@ int rtw_br_client_tx(struct rtw_adapter
 
 					newskb = skb_copy(skb, GFP_ATOMIC);
 					if (newskb == NULL) {
-						//priv->ext_stats.tx_drops++;
+						/* priv->ext_stats.tx_drops++; */
 						ERR_8192D("TX DROP: skb_copy fail!\n");
-						//goto stop_proc;
+						/* goto stop_proc; */
 						return -1;
 					}
 					dev_kfree_skb_any(skb);
@@ -2523,27 +2484,24 @@ int rtw_br_client_tx(struct rtw_adapter
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
 				res = skb_linearize(skb, GFP_ATOMIC);
-#else	// (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+#else	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)) */
 				res = skb_linearize(skb);
-#endif	// (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+#endif	/*  (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)) */
 				if (res < 0) {
 						ERR_8192D("TX DROP: skb_linearize fail!\n");
-						//goto free_and_stop;
+						/* goto free_and_stop; */
 						return -1;
 				}
 
 				res = nat25_db_handle(padapter, skb, NAT25_INSERT);
 				if (res < 0) {
 					if (res == -2) {
-						//priv->ext_stats.tx_drops++;
+						/* priv->ext_stats.tx_drops++; */
 						ERR_8192D("TX DROP: nat25_db_handle fail!\n");
-						//goto free_and_stop;
+						/* goto free_and_stop; */
 						return -1;
 
 					}
-					// we just print warning message and let it go
-					//DEBUG_WARN("%s()-%d: nat25_db_handle INSERT Warning!\n", __func__, __LINE__);
-					//return -1; // return -1 will cause system crash on 2011/08/30!
 					return 0;
 				}
 			}
@@ -2560,7 +2518,7 @@ int rtw_br_client_tx(struct rtw_adapter
 				*((unsigned short *)(skb->data+MACADDRLEN*2+2)) = vlan_hdr;
 			}
 		}
-		// check if SA is equal to our MAC
+		/*  check if SA is equal to our MAC */
 		if (memcmp(skb->data+MACADDRLEN, GET_MY_HWADDR(padapter), MACADDRLEN)) {
 			ERR_8192D("TX DROP: untransformed frame SA:%02X%02X%02X%02X%02X%02X!\n",
 				skb->data[6],skb->data[7],skb->data[8],skb->data[9],skb->data[10],skb->data[11]);
@@ -2569,7 +2527,7 @@ int rtw_br_client_tx(struct rtw_adapter
 	}
 	return 0;
 }
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 static void do_queue_select(struct rtw_adapter	*padapter, struct pkt_attrib *pattrib)
 {
@@ -2598,7 +2556,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 #ifdef CONFIG_BR_EXT
 	struct mlme_priv	*pmlmepriv = &padapter->mlmepriv;
 	void *br_port = NULL;
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 	s32 res;
 
@@ -2615,11 +2573,11 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
 	br_port = padapter->pnetdev->br_port;
-#else   // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#else   /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 	rcu_read_lock();
 	br_port = rcu_dereference(padapter->pnetdev->rx_handler_data);
 	rcu_read_unlock();
-#endif  // (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35))
+#endif  /*  (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 35)) */
 
 	if (br_port	&& check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) == true)
 	{
@@ -2631,7 +2589,7 @@ s32 rtw_xmit(struct rtw_adapter *padapte
 		}
 	}
 
-#endif	// CONFIG_BR_EXT
+#endif	/*  CONFIG_BR_EXT */
 
 	res = update_attrib(padapter, *ppkt, &pxmitframe->attrib);
 	if (res == _FAIL) {
@@ -2694,7 +2652,7 @@ int xmitframe_enqueue_for_tdls_sleeping_
 			ptdls_sta->sleepq_len++;
 			ptdls_sta->sleepq_ac_len++;
 
-			//indicate 4-AC queue bit in TDLS peer traffic indication
+			/* indicate 4-AC queue bit in TDLS peer traffic indication */
 			switch (pattrib->priority)
 			{
 				case 1:
@@ -2718,7 +2676,7 @@ int xmitframe_enqueue_for_tdls_sleeping_
 
 			if (ptdls_sta->sleepq_len==1)
 			{
-				//transmit TDLS PTI via AP
+				/* transmit TDLS PTI via AP */
 				rtw_tdls_cmd(padapter, ptdls_sta->hwaddr, TDLS_SD_PTI);
 			}
 			ret = true;
@@ -2730,7 +2688,7 @@ int xmitframe_enqueue_for_tdls_sleeping_
 
 	return ret;
 }
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 #if defined(CONFIG_AP_MODE) || defined(CONFIG_TDLS)
 
@@ -2750,7 +2708,7 @@ int xmitframe_enqueue_for_sleeping_sta(s
 		ret = xmitframe_enqueue_for_tdls_sleeping_sta(padapter, pxmitframe);
 		return ret;
 	}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == false)
 	    return ret;
@@ -2769,12 +2727,12 @@ int xmitframe_enqueue_for_sleeping_sta(s
 
 	if (pattrib->triggered==1)
 	{
-		//DBG_8192D("directly xmit pspoll_triggered packet\n");
+		/* DBG_8192D("directly xmit pspoll_triggered packet\n"); */
 
-		//pattrib->triggered=0;
+		/* pattrib->triggered=0; */
 
 		if (bmcst)
-			pattrib->qsel = 0x11;//HIQ
+			pattrib->qsel = 0x11;/* HIQ */
 
 
 		return ret;
@@ -2785,7 +2743,7 @@ int xmitframe_enqueue_for_sleeping_sta(s
 	{
 		spin_lock_bh(&psta->sleep_q.lock);
 
-		if (pstapriv->sta_dz_bitmap)//if anyone sta is in ps mode
+		if (pstapriv->sta_dz_bitmap)/* if anyone sta is in ps mode */
 		{
 			rtw_list_delete(&pxmitframe->list);
 
@@ -2793,10 +2751,10 @@ int xmitframe_enqueue_for_sleeping_sta(s
 
 			psta->sleepq_len++;
 
-			pstapriv->tim_bitmap |= BIT(0);//
+			pstapriv->tim_bitmap |= BIT(0);/*  */
 			pstapriv->sta_dz_bitmap |= BIT(0);
 
-			update_beacon(padapter, _TIM_IE_, NULL, false);//tx bc/mc packets after upate bcn
+			update_beacon(padapter, _TIM_IE_, NULL, false);/* tx bc/mc packets after upate bcn */
 
 			ret = true;
 
@@ -2904,7 +2862,7 @@ void stop_sta_xmit(struct rtw_adapter *p
 
 	pstaxmitpriv = &psta->sta_xmitpriv;
 
-	//for BC/MC Frames
+	/* for BC/MC Frames */
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
 
 
@@ -2914,7 +2872,7 @@ void stop_sta_xmit(struct rtw_adapter *p
 
 #ifdef CONFIG_TDLS
 	if (!(psta->tdls_sta_state & TDLS_LINKED_STATE))
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 	pstapriv->sta_dz_bitmap |= BIT(psta->aid);
 
 
@@ -2939,10 +2897,10 @@ void stop_sta_xmit(struct rtw_adapter *p
 	{
 		if (psta_bmc != NULL)
 		{
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 
 
-	//for BC/MC Frames
+	/* for BC/MC Frames */
 	pstaxmitpriv = &psta_bmc->sta_xmitpriv;
 	dequeue_xmitframes_to_sleeping_queue(padapter, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
 	rtw_list_delete(&(pstaxmitpriv->be_q.tx_pending));
@@ -2951,7 +2909,7 @@ void stop_sta_xmit(struct rtw_adapter *p
 #ifdef CONFIG_TDLS
 		}
 	}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 	spin_unlock_bh(&pxmitpriv->lock);
 }
 
@@ -3038,7 +2996,7 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 			spin_unlock_bh(&psta->sleep_q.lock);
 			return;
 		}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 		pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
 		update_mask = BIT(0);
@@ -3058,12 +3016,12 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 	spin_unlock_bh(&psta->sleep_q.lock);
 
 
-	//for BC/MC Frames
+	/* for BC/MC Frames */
 	psta_bmc = rtw_get_bcmc_stainfo(padapter);
 	if (!psta_bmc)
 		return;
 
-	if ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0)//no any sta in ps mode
+	if ((pstapriv->sta_dz_bitmap&0xfffe) == 0x0)/* no any sta in ps mode */
 	{
 		spin_lock_bh(&psta_bmc->sleep_q.lock);
 
@@ -3102,9 +3060,9 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 			pstapriv->tim_bitmap &= ~BIT(0);
 			pstapriv->sta_dz_bitmap &= ~BIT(0);
 
-			//DBG_8192D("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
-			//upate BCN for TIM IE
-			//update_BCNTIM(padapter);
+			/* DBG_8192D("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap); */
+			/* upate BCN for TIM IE */
+			/* update_BCNTIM(padapter); */
 			update_mask |= BIT(1);
 		}
 
@@ -3115,7 +3073,7 @@ void wakeup_sta_to_xmit(struct rtw_adapt
 
 	if (update_mask)
 	{
-		//update_BCNTIM(padapter);
+		/* update_BCNTIM(padapter); */
 		update_beacon(padapter, _TIM_IE_, NULL, false);
 	}
 }
@@ -3193,14 +3151,14 @@ void xmit_delivery_enabled_frames(struct
 				spin_unlock_bh(&psta->sleep_q.lock);
 				return;
 			}
-#endif //CONFIG_TDLS
+#endif /* CONFIG_TDLS */
 			pstapriv->tim_bitmap &= ~BIT(psta->aid);
 
-			//DBG_8192D("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap);
-			//upate BCN for TIM IE
-			//update_BCNTIM(padapter);
+			/* DBG_8192D("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap); */
+			/* upate BCN for TIM IE */
+			/* update_BCNTIM(padapter); */
 			update_beacon(padapter, _TIM_IE_, NULL, false);
-			//update_mask = BIT(0);
+			/* update_mask = BIT(0); */
 		}
 
 	}
@@ -3349,4 +3307,4 @@ void rtw_ack_tx_done(struct xmit_priv *p
 		DBG_8192D("%s ack_tx not set\n", __func__);
 	}
 }
-#endif //CONFIG_XMIT_ACK
+#endif /* CONFIG_XMIT_ACK */

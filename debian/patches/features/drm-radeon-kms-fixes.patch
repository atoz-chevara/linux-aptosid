diff --git a/drivers/gpu/drm/drm_ttm.c b/drivers/gpu/drm/drm_ttm.c
index dbc0cb3..ae64a83 100644
--- a/drivers/gpu/drm/drm_ttm.c
+++ b/drivers/gpu/drm/drm_ttm.c
@@ -89,14 +89,21 @@ static struct page *drm_ttm_alloc_page(struct drm_ttm *ttm, int cached)
  * Change caching policy for the linear kernel map
  * for range of pages in a ttm.
  */
-static int drm_ttm_set_caching(struct drm_ttm *ttm, int noncached)
+static int drm_ttm_set_caching(struct drm_ttm *ttm, int noncached, int alloc_cached)
 {
 	int i;
 	struct page **cur_page;
+	int ret;
 
 	if ((ttm->page_flags & DRM_TTM_PAGE_UNCACHED) == noncached)
 		return 0;
 
+	{
+		ret = drm_ttm_populate(ttm, alloc_cached);
+		if (ret != 0)
+			return ret;
+	}
+
 	if (noncached)
 		drm_clflush_pages(ttm->pages, ttm->num_pages);
 
@@ -189,7 +196,7 @@ int drm_ttm_destroy(struct drm_ttm *ttm)
 	if (ttm->pages) {
 		if (ttm->page_flags & DRM_TTM_PAGE_USER) {
 			if (ttm->page_flags & DRM_TTM_PAGE_UNCACHED)
-				drm_ttm_set_caching(ttm, 0);
+				drm_ttm_set_caching(ttm, 0, 0);
 
 			drm_ttm_free_user_pages(ttm);
 		} else
@@ -397,7 +404,7 @@ void drm_ttm_fixup_caching(struct drm_ttm *ttm)
 		struct drm_ttm_backend *be = ttm->be;
 		if (be->func->needs_ub_cache_adjust(be))
 			if (ttm->page_flags & DRM_TTM_PAGE_ALLOC_CACHED)
-				drm_ttm_set_caching(ttm, 0);
+				drm_ttm_set_caching(ttm, 0, 1);
 		ttm->state = ttm_unbound;
 	}
 }
@@ -445,7 +452,7 @@ int drm_ttm_bind(struct drm_ttm *ttm, struct drm_bo_mem_reg *bo_mem)
 	be = ttm->be;
 
 	if ((ttm->state == ttm_unbound || ttm->state == ttm_unpopulated) && !cached)
-		drm_ttm_set_caching(ttm, DRM_TTM_PAGE_UNCACHED);
+		drm_ttm_set_caching(ttm, DRM_TTM_PAGE_UNCACHED, cached);
 	else if ((bo_mem->flags & DRM_BO_FLAG_CACHED_MAPPED) &&
 		   bo_driver->ttm_cache_flush)
 		bo_driver->ttm_cache_flush(ttm);
diff --git a/drivers/gpu/drm/radeon/radeon_gem.c b/drivers/gpu/drm/radeon/radeon_gem.c
index a0b0f5b..cb96470 100644
--- a/drivers/gpu/drm/radeon/radeon_gem.c
+++ b/drivers/gpu/drm/radeon/radeon_gem.c
@@ -1446,38 +1446,12 @@ static int radeon_gem_do_relocate(struct drm_gem_object *obj, uint32_t read_doma
 static int radeon_gem_relocate(struct drm_radeon_cs_parser *parser,
 			       uint32_t *reloc, uint32_t *offset)
 {
-	struct drm_device *dev = parser->dev;
 	/* relocate the handle */
-	uint32_t read_domains, write_domain;
-	struct drm_gem_object *obj;
-	int ret = 0;
-	struct drm_radeon_gem_object *obj_priv;
-
-	if (parser->reloc_index == -1) {
-		obj = drm_gem_object_lookup(dev, parser->file_priv, reloc[1]);
-		if (!obj)
-			return -EINVAL;
-		obj_priv = obj->driver_private;
-		if (obj_priv->bo->mem.flags & DRM_BO_FLAG_CLEAN)
-			DRM_ERROR("clean on relocate for %d\n", reloc[1]);
-		read_domains = reloc[2];
-		write_domain = reloc[3];
-
-		ret = radeon_gem_do_relocate(obj, read_domains, write_domain, offset);
-
-		mutex_lock(&dev->struct_mutex);
-		drm_gem_object_unreference(obj);
-		mutex_unlock(&dev->struct_mutex);
-
-	} else {
-		uint32_t handle;
-		/* have to lookup handle in other chunk */
-		ret = radeon_gem_find_reloc(parser, reloc[1], &handle, offset);
-	}
-	return ret;
+	uint32_t handle;
+	/* have to lookup handle in other chunk */
+	return radeon_gem_find_reloc(parser, reloc[1], &handle, offset);
 }
 
-
 int radeon_gem_prelocate(struct drm_radeon_cs_parser *parser)
 {
 	struct drm_device *dev = parser->dev;
From 592b92d0a532c7367164546b513d345b1aae1d46 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Fri, 1 May 2009 02:14:07 +1000
Subject: [PATCH] r300: add other clip regs

---
 drivers/gpu/drm/radeon/r300_cmdbuf.c |    3 +++
 drivers/gpu/drm/radeon/radeon_reg.h  |    3 +++
 2 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/drivers/gpu/drm/radeon/r300_cmdbuf.c b/drivers/gpu/drm/radeon/r300_cmdbuf.c
index 694cf6c..5cf47fd 100644
--- a/drivers/gpu/drm/radeon/r300_cmdbuf.c
+++ b/drivers/gpu/drm/radeon/r300_cmdbuf.c
@@ -309,6 +309,9 @@ void r300_init_reg_flags(struct drm_device *dev)
 	ADD_RANGE_MARK(R300_SC_SCISSOR0, 2, MARK_CHECK_SCISSOR);
 
 	ADD_RANGE(R300_SC_CLIP_0_A, 2);
+	ADD_RANGE(R300_SC_CLIP_1_A, 2);
+	ADD_RANGE(R300_SC_CLIP_2_A, 2);
+	ADD_RANGE(R300_SC_CLIP_3_A, 2);
 	ADD_RANGE(R300_SC_CLIP_RULE, 1);
 	ADD_RANGE(R300_SC_SCREENDOOR, 1);
 
diff --git a/drivers/gpu/drm/radeon/radeon_reg.h b/drivers/gpu/drm/radeon/radeon_reg.h
index 1a5e157..102bdba 100644
--- a/drivers/gpu/drm/radeon/radeon_reg.h
+++ b/drivers/gpu/drm/radeon/radeon_reg.h
@@ -4841,6 +4841,9 @@
 #define R300_SC_CLIP_0_B				0x43b4
 #       define R300_CLIP_X_SHIFT                        0
 #       define R300_CLIP_Y_SHIFT                        13
+#define R300_SC_CLIP_1_A				0x43b8
+#define R300_SC_CLIP_2_A				0x43c0
+#define R300_SC_CLIP_3_A				0x43c8
 #define R300_SC_CLIP_RULE				0x43d0
 #define R300_SC_SCREENDOOR				0x43e8
 
-- 
1.6.2.2

diff --git a/drivers/gpu/drm/radeon/radeon_cp.c b/drivers/gpu/drm/radeon/radeon_cp.c
index b349ebe..ac31d0b 100644
--- a/drivers/gpu/drm/radeon/radeon_cp.c
+++ b/drivers/gpu/drm/radeon/radeon_cp.c
@@ -1080,11 +1080,9 @@ static void radeon_set_igpgart(drm_radeon_private_t * dev_priv, int on)
 		temp |= (upper_32_bits(dev_priv->gart_info.bus_addr) & 0xff) << 4;
 		RADEON_WRITE_MCIND(RS480_GART_BASE, temp);
 
-		/* enable snooping on gart mapped address */
 		temp = RADEON_READ_MCIND(dev_priv, RS480_AGP_MODE_CNTL);
-		temp &= (RS480_REQ_TYPE_SNOOP_DIS);
-		temp |= (1 << RS480_REQ_TYPE_SNOOP_SHIFT);
-		RADEON_WRITE_MCIND(RS480_AGP_MODE_CNTL, temp);
+		RADEON_WRITE_MCIND(RS480_AGP_MODE_CNTL, ((1 << RS480_REQ_TYPE_SNOOP_SHIFT) |
+							 RS480_REQ_TYPE_SNOOP_DIS));
 
 		if ((dev_priv->flags & RADEON_FAMILY_MASK) == CHIP_RS690) {
 			RADEON_WRITE_MCIND(RS690_MC_AGP_BASE,

From 571cbb0e82349597c27b7174135f1eecb459c96b Mon Sep 17 00:00:00 2001
From: Antti Palosaari <crope@iki.fi>
Date: Fri, 13 Aug 2010 09:41:02 +0300
Subject: [PATCH 1/4] NXP TDA18218 silicon tuner driver

Signed-off-by: Antti Palosaari <crope@iki.fi>
---
 drivers/media/common/tuners/Kconfig         |    7 +
 drivers/media/common/tuners/Makefile        |    1 +
 drivers/media/common/tuners/tda18218.c      |  334 +++++++++++++++++++++++++++
 drivers/media/common/tuners/tda18218.h      |   45 ++++
 drivers/media/common/tuners/tda18218_priv.h |  106 +++++++++
 5 files changed, 493 insertions(+), 0 deletions(-)
 create mode 100644 drivers/media/common/tuners/tda18218.c
 create mode 100644 drivers/media/common/tuners/tda18218.h
 create mode 100644 drivers/media/common/tuners/tda18218_priv.h

--- a/drivers/media/common/tuners/Kconfig
+++ b/drivers/media/common/tuners/Kconfig
@@ -179,4 +179,11 @@ config MEDIA_TUNER_MAX2165
 	help
 	  A driver for the silicon tuner MAX2165 from Maxim.
 
+config MEDIA_TUNER_TDA18218
+	tristate "NXP TDA18218 silicon tuner"
+	depends on VIDEO_MEDIA && I2C
+	default m if MEDIA_TUNER_CUSTOMISE
+	help
+	  NXP TDA18218 silicon tuner driver.
+
 endif # MEDIA_TUNER_CUSTOMISE
--- a/drivers/media/common/tuners/Makefile
+++ b/drivers/media/common/tuners/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_MEDIA_TUNER_MXL5005S) += mx
 obj-$(CONFIG_MEDIA_TUNER_MXL5007T) += mxl5007t.o
 obj-$(CONFIG_MEDIA_TUNER_MC44S803) += mc44s803.o
 obj-$(CONFIG_MEDIA_TUNER_MAX2165) += max2165.o
+obj-$(CONFIG_MEDIA_TUNER_TDA18218) += tda18218.o
 
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 EXTRA_CFLAGS += -Idrivers/media/dvb/frontends
--- /dev/null
+++ b/drivers/media/common/tuners/tda18218.c
@@ -0,0 +1,334 @@
+/*
+ * NXP TDA18218HN silicon tuner driver
+ *
+ * Copyright (C) 2010 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "tda18218.h"
+#include "tda18218_priv.h"
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off debugging (default:off).");
+
+/* write multiple registers */
+static int tda18218_wr_regs(struct tda18218_priv *priv, u8 reg, u8 *val, u8 len)
+{
+	int ret;
+	u8 buf[1+len], quotient, remainder, i, msg_len, msg_len_max;
+	struct i2c_msg msg[1] = {
+		{
+			.addr = priv->cfg->i2c_address,
+			.flags = 0,
+			.buf = buf,
+		}
+	};
+
+	msg_len_max = priv->cfg->i2c_wr_max - 1;
+	quotient = len / msg_len_max;
+	remainder = len % msg_len_max;
+	msg_len = msg_len_max;
+	for (i = 0; (i <= quotient && remainder); i++) {
+		if (i == quotient)  /* set len of the last msg */
+			msg_len = remainder;
+
+		msg[0].len = msg_len + 1;
+		buf[0] = reg + i * msg_len_max;
+		memcpy(&buf[1], &val[i * msg_len_max], msg_len);
+
+		ret = i2c_transfer(priv->i2c, msg, 1);
+		if (ret != 1)
+			break;
+	}
+
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		warn("i2c wr failed ret:%d reg:%02x len:%d", ret, reg, len);
+		ret = -EREMOTEIO;
+	}
+
+	return ret;
+}
+
+/* read multiple registers */
+static int tda18218_rd_regs(struct tda18218_priv *priv, u8 reg, u8 *val, u8 len)
+{
+	int ret;
+	u8 buf[reg+len]; /* we must start read always from reg 0x00 */
+	struct i2c_msg msg[2] = {
+		{
+			.addr = priv->cfg->i2c_address,
+			.flags = 0,
+			.len = 1,
+			.buf = "\x00",
+		}, {
+			.addr = priv->cfg->i2c_address,
+			.flags = I2C_M_RD,
+			.len = sizeof(buf),
+			.buf = buf,
+		}
+	};
+
+	ret = i2c_transfer(priv->i2c, msg, 2);
+	if (ret == 2) {
+		memcpy(val, &buf[reg], len);
+		ret = 0;
+	} else {
+		warn("i2c rd failed ret:%d reg:%02x len:%d", ret, reg, len);
+		ret = -EREMOTEIO;
+	}
+
+	return ret;
+}
+
+/* write single register */
+static int tda18218_wr_reg(struct tda18218_priv *priv, u8 reg, u8 val)
+{
+	return tda18218_wr_regs(priv, reg, &val, 1);
+}
+
+/* read single register */
+
+static int tda18218_rd_reg(struct tda18218_priv *priv, u8 reg, u8 *val)
+{
+	return tda18218_rd_regs(priv, reg, val, 1);
+}
+
+static int tda18218_set_params(struct dvb_frontend *fe,
+	struct dvb_frontend_parameters *params)
+{
+	struct tda18218_priv *priv = fe->tuner_priv;
+	int ret;
+	u8 buf[3], i, BP_Filter, LP_Fc;
+	u32 LO_Frac;
+	/* TODO: find out correct AGC algorithm */
+	u8 agc[][2] = {
+		{ R20_AGC11, 0x60 },
+		{ R23_AGC21, 0x02 },
+		{ R20_AGC11, 0xa0 },
+		{ R23_AGC21, 0x09 },
+		{ R20_AGC11, 0xe0 },
+		{ R23_AGC21, 0x0c },
+		{ R20_AGC11, 0x40 },
+		{ R23_AGC21, 0x01 },
+		{ R20_AGC11, 0x80 },
+		{ R23_AGC21, 0x08 },
+		{ R20_AGC11, 0xc0 },
+		{ R23_AGC21, 0x0b },
+		{ R24_AGC22, 0x1c },
+		{ R24_AGC22, 0x0c },
+	};
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* open I2C-gate */
+
+	/* low-pass filter cut-off frequency */
+	switch (params->u.ofdm.bandwidth) {
+	case BANDWIDTH_6_MHZ:
+		LP_Fc = 0;
+		LO_Frac = params->frequency + 4000000;
+		break;
+	case BANDWIDTH_7_MHZ:
+		LP_Fc = 1;
+		LO_Frac = params->frequency + 3500000;
+		break;
+	case BANDWIDTH_8_MHZ:
+	default:
+		LP_Fc = 2;
+		LO_Frac = params->frequency + 4000000;
+		break;
+	}
+
+	/* band-pass filter */
+	if (LO_Frac < 188000000)
+		BP_Filter = 3;
+	else if (LO_Frac < 253000000)
+		BP_Filter = 4;
+	else if (LO_Frac < 343000000)
+		BP_Filter = 5;
+	else
+		BP_Filter = 6;
+
+	buf[0] = (priv->regs[R1A_IF1] & ~7) | BP_Filter; /* BP_Filter */
+	buf[1] = (priv->regs[R1B_IF2] & ~3) | LP_Fc; /* LP_Fc */
+	buf[2] = priv->regs[R1C_AGC2B];
+	ret = tda18218_wr_regs(priv, R1A_IF1, buf, 3);
+	if (ret)
+		goto error;
+
+	buf[0] = (LO_Frac / 1000) >> 12; /* LO_Frac_0 */
+	buf[1] = (LO_Frac / 1000) >> 4; /* LO_Frac_1 */
+	buf[2] = (LO_Frac / 1000) << 4 |
+		(priv->regs[R0C_MD5] & 0x0f); /* LO_Frac_2 */
+	ret = tda18218_wr_regs(priv, R0A_MD3, buf, 3);
+	if (ret)
+		goto error;
+
+	buf[0] = priv->regs[R0F_MD8] | (1 << 6); /* Freq_prog_Start */
+	ret = tda18218_wr_regs(priv, R0F_MD8, buf, 1);
+	if (ret)
+		goto error;
+
+	buf[0] = priv->regs[R0F_MD8] & ~(1 << 6); /* Freq_prog_Start */
+	ret = tda18218_wr_regs(priv, R0F_MD8, buf, 1);
+	if (ret)
+		goto error;
+
+	/* trigger AGC */
+	for (i = 0; i < ARRAY_SIZE(agc); i++) {
+		ret = tda18218_wr_reg(priv, agc[i][0], agc[i][1]);
+		if (ret)
+			goto error;
+	}
+
+error:
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* close I2C-gate */
+
+	if (ret)
+		dbg("%s: failed ret:%d", __func__, ret);
+
+	return ret;
+}
+
+static int tda18218_sleep(struct dvb_frontend *fe)
+{
+	struct tda18218_priv *priv = fe->tuner_priv;
+	int ret;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* open I2C-gate */
+
+	/* standby */
+	ret = tda18218_wr_reg(priv, R17_PD1, priv->regs[R17_PD1] | (1 << 0));
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* close I2C-gate */
+
+	if (ret)
+		dbg("%s: failed ret:%d", __func__, ret);
+
+	return ret;
+}
+
+static int tda18218_init(struct dvb_frontend *fe)
+{
+	struct tda18218_priv *priv = fe->tuner_priv;
+	int ret;
+
+	/* TODO: calibrations */
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* open I2C-gate */
+
+	ret = tda18218_wr_regs(priv, R00_ID, priv->regs, TDA18218_NUM_REGS);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* close I2C-gate */
+
+	if (ret)
+		dbg("%s: failed ret:%d", __func__, ret);
+
+	return ret;
+}
+
+static int tda18218_release(struct dvb_frontend *fe)
+{
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static const struct dvb_tuner_ops tda18218_tuner_ops = {
+	.info = {
+		.name           = "NXP TDA18218",
+
+		.frequency_min  = 174000000,
+		.frequency_max  = 864000000,
+		.frequency_step =      1000,
+	},
+
+	.release       = tda18218_release,
+	.init          = tda18218_init,
+	.sleep         = tda18218_sleep,
+
+	.set_params    = tda18218_set_params,
+};
+
+struct dvb_frontend *tda18218_attach(struct dvb_frontend *fe,
+	struct i2c_adapter *i2c, struct tda18218_config *cfg)
+{
+	struct tda18218_priv *priv = NULL;
+	u8 val;
+	int ret;
+	/* chip default registers values */
+	static u8 def_regs[] = {
+		0xc0, 0x88, 0x00, 0x8e, 0x03, 0x00, 0x00, 0xd0, 0x00, 0x40,
+		0x00, 0x00, 0x07, 0xff, 0x84, 0x09, 0x00, 0x13, 0x00, 0x00,
+		0x01, 0x84, 0x09, 0xf0, 0x19, 0x0a, 0x8e, 0x69, 0x98, 0x01,
+		0x00, 0x58, 0x10, 0x40, 0x8c, 0x00, 0x0c, 0x48, 0x85, 0xc9,
+		0xa7, 0x00, 0x00, 0x00, 0x30, 0x81, 0x80, 0x00, 0x39, 0x00,
+		0x8a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xf6
+	};
+
+	priv = kzalloc(sizeof(struct tda18218_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
+
+	priv->cfg = cfg;
+	priv->i2c = i2c;
+	fe->tuner_priv = priv;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* open I2C-gate */
+
+	/* check if the tuner is there */
+	ret = tda18218_rd_reg(priv, R00_ID, &val);
+	dbg("%s: ret:%d chip ID:%02x", __func__, ret, val);
+	if (ret || val != def_regs[R00_ID]) {
+		kfree(priv);
+		return NULL;
+	}
+
+	info("NXP TDA18218HN successfully identified.");
+
+	memcpy(&fe->ops.tuner_ops, &tda18218_tuner_ops,
+		sizeof(struct dvb_tuner_ops));
+	memcpy(priv->regs, def_regs, sizeof(def_regs));
+
+	/* loop-through enabled chip default register values */
+	if (priv->cfg->loop_through) {
+		priv->regs[R17_PD1] = 0xb0;
+		priv->regs[R18_PD2] = 0x59;
+	}
+
+	/* standby */
+	ret = tda18218_wr_reg(priv, R17_PD1, priv->regs[R17_PD1] | (1 << 0));
+	if (ret)
+		dbg("%s: failed ret:%d", __func__, ret);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* close I2C-gate */
+
+	return fe;
+}
+EXPORT_SYMBOL(tda18218_attach);
+
+MODULE_DESCRIPTION("NXP TDA18218HN silicon tuner driver");
+MODULE_AUTHOR("Antti Palosaari <crope@iki.fi>");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/media/common/tuners/tda18218.h
@@ -0,0 +1,45 @@
+/*
+ * NXP TDA18218HN silicon tuner driver
+ *
+ * Copyright (C) 2010 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef TDA18218_H
+#define TDA18218_H
+
+#include "dvb_frontend.h"
+
+struct tda18218_config {
+	u8 i2c_address;
+	u8 i2c_wr_max;
+	u8 loop_through:1;
+};
+
+#if defined(CONFIG_MEDIA_TUNER_TDA18218) || \
+	(defined(CONFIG_MEDIA_TUNER_TDA18218_MODULE) && defined(MODULE))
+extern struct dvb_frontend *tda18218_attach(struct dvb_frontend *fe,
+	struct i2c_adapter *i2c, struct tda18218_config *cfg);
+#else
+static inline struct dvb_frontend *tda18218_attach(struct dvb_frontend *fe,
+	struct i2c_adapter *i2c, struct tda18218_config *cfg)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
+
+#endif
--- /dev/null
+++ b/drivers/media/common/tuners/tda18218_priv.h
@@ -0,0 +1,106 @@
+/*
+ * NXP TDA18218HN silicon tuner driver
+ *
+ * Copyright (C) 2010 Antti Palosaari <crope@iki.fi>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef TDA18218_PRIV_H
+#define TDA18218_PRIV_H
+
+#define LOG_PREFIX "tda18218"
+
+#undef dbg
+#define dbg(f, arg...) \
+	if (debug) \
+		printk(KERN_DEBUG   LOG_PREFIX": " f "\n" , ## arg)
+#undef err
+#define err(f, arg...)  printk(KERN_ERR     LOG_PREFIX": " f "\n" , ## arg)
+#undef info
+#define info(f, arg...) printk(KERN_INFO    LOG_PREFIX": " f "\n" , ## arg)
+#undef warn
+#define warn(f, arg...) printk(KERN_WARNING LOG_PREFIX": " f "\n" , ## arg)
+
+#define R00_ID         0x00	/* ID byte */
+#define R01_R1         0x01	/* Read byte 1 */
+#define R02_R2         0x02	/* Read byte 2 */
+#define R03_R3         0x03	/* Read byte 3 */
+#define R04_R4         0x04	/* Read byte 4 */
+#define R05_R5         0x05	/* Read byte 5 */
+#define R06_R6         0x06	/* Read byte 6 */
+#define R07_MD1        0x07	/* Main divider byte 1 */
+#define R08_PSM1       0x08	/* PSM byte 1 */
+#define R09_MD2        0x09	/* Main divider byte 2 */
+#define R0A_MD3        0x0a	/* Main divider byte 1 */
+#define R0B_MD4        0x0b	/* Main divider byte 4 */
+#define R0C_MD5        0x0c	/* Main divider byte 5 */
+#define R0D_MD6        0x0d	/* Main divider byte 6 */
+#define R0E_MD7        0x0e	/* Main divider byte 7 */
+#define R0F_MD8        0x0f	/* Main divider byte 8 */
+#define R10_CD1        0x10	/* Call divider byte 1 */
+#define R11_CD2        0x11	/* Call divider byte 2 */
+#define R12_CD3        0x12	/* Call divider byte 3 */
+#define R13_CD4        0x13	/* Call divider byte 4 */
+#define R14_CD5        0x14	/* Call divider byte 5 */
+#define R15_CD6        0x15	/* Call divider byte 6 */
+#define R16_CD7        0x16	/* Call divider byte 7 */
+#define R17_PD1        0x17	/* Power-down byte 1 */
+#define R18_PD2        0x18	/* Power-down byte 2 */
+#define R19_XTOUT      0x19	/* XTOUT byte */
+#define R1A_IF1        0x1a	/* IF byte 1 */
+#define R1B_IF2        0x1b	/* IF byte 2 */
+#define R1C_AGC2B      0x1c	/* AGC2b byte */
+#define R1D_PSM2       0x1d	/* PSM byte 2 */
+#define R1E_PSM3       0x1e	/* PSM byte 3 */
+#define R1F_PSM4       0x1f	/* PSM byte 4 */
+#define R20_AGC11      0x20	/* AGC1 byte 1 */
+#define R21_AGC12      0x21	/* AGC1 byte 2 */
+#define R22_AGC13      0x22	/* AGC1 byte 3 */
+#define R23_AGC21      0x23	/* AGC2 byte 1 */
+#define R24_AGC22      0x24	/* AGC2 byte 2 */
+#define R25_AAGC       0x25	/* Analog AGC byte */
+#define R26_RC         0x26	/* RC byte */
+#define R27_RSSI       0x27	/* RSSI byte */
+#define R28_IRCAL1     0x28	/* IR CAL byte 1 */
+#define R29_IRCAL2     0x29	/* IR CAL byte 2 */
+#define R2A_IRCAL3     0x2a	/* IR CAL byte 3 */
+#define R2B_IRCAL4     0x2b	/* IR CAL byte 4 */
+#define R2C_RFCAL1     0x2c	/* RF CAL byte 1 */
+#define R2D_RFCAL2     0x2d	/* RF CAL byte 2 */
+#define R2E_RFCAL3     0x2e	/* RF CAL byte 3 */
+#define R2F_RFCAL4     0x2f	/* RF CAL byte 4 */
+#define R30_RFCAL5     0x30	/* RF CAL byte 5 */
+#define R31_RFCAL6     0x31	/* RF CAL byte 6 */
+#define R32_RFCAL7     0x32	/* RF CAL byte 7 */
+#define R33_RFCAL8     0x33	/* RF CAL byte 8 */
+#define R34_RFCAL9     0x34	/* RF CAL byte 9 */
+#define R35_RFCAL10    0x35	/* RF CAL byte 10 */
+#define R36_RFCALRAM1  0x36	/* RF CAL RAM byte 1 */
+#define R37_RFCALRAM2  0x37	/* RF CAL RAM byte 2 */
+#define R38_MARGIN     0x38	/* Margin byte */
+#define R39_FMAX1      0x39	/* Fmax byte 1 */
+#define R3A_FMAX2      0x3a	/* Fmax byte 2 */
+
+#define TDA18218_NUM_REGS 59
+
+struct tda18218_priv {
+	struct tda18218_config *cfg;
+	struct i2c_adapter *i2c;
+
+	u8 regs[TDA18218_NUM_REGS];
+};
+
+#endif

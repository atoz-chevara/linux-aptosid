--- a/fs/aufs/file.c
+++ b/fs/aufs/file.c
@@ -77,7 +77,7 @@ struct file *au_h_open(struct dentry *de
 		flags = au_file_roflags(flags);
 	flags &= ~O_CREAT;
 	atomic_inc(&br->br_count);
-	h_file = dentry_open(dget(h_dentry), mntget(br->br_mnt), flags);
+	h_file = dentry_open(dget(h_dentry), mntget(br->br_mnt), flags, file->f_cred);
 	if (IS_ERR(h_file))
 		goto out_br;
 
--- a/fs/aufs/inode.c
+++ b/fs/aufs/inode.c
@@ -350,7 +350,7 @@ int au_test_ro(struct super_block *sb, a
 
 int au_test_h_perm(struct inode *h_inode, int mask)
 {
-	if (!current->fsuid)
+	if (!current_fsuid())
 		return 0;
 	return inode_permission(h_inode, mask);
 }
--- a/fs/aufs/whout.c
+++ b/fs/aufs/whout.c
@@ -214,7 +214,7 @@ static int do_unlink_wh(struct inode *h_
 	 * this may be a violation of unix fs semantics.
 	 */
 	force = (h_dir->i_mode & S_ISVTX)
-		&& h_path->dentry->d_inode->i_uid != current->fsuid;
+		&& h_path->dentry->d_inode->i_uid != current_fsuid();
 	return vfsub_unlink(h_dir, h_path, force);
 }
 
--- a/fs/aufs/xino.c
+++ b/fs/aufs/xino.c
@@ -155,7 +155,8 @@ static struct file *au_xino_create2(stru
 	}
 
 	file = dentry_open(dget(dentry), mntget(base_file->f_vfsmnt),
-			   O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE);
+			   O_RDWR | O_CREAT | O_EXCL | O_LARGEFILE,
+			   base_file->f_cred);
 	if (IS_ERR(file)) {
 		AuErr("%.*s open err %ld\n", AuLNPair(name), PTR_ERR(file));
 		goto out_dput;
--- a/fs/aufs/dir.c
+++ b/fs/aufs/dir.c
@@ -227,7 +227,7 @@ static int au_do_fsync_dir(struct file *
 		if (!h_file || au_test_ro(sb, bindex, inode))
 			continue;
 
-		err = (int)do_fsync(h_file, datasync);
+		err = (int)vfs_fsync(h_file, h_file->f_path.dentry, datasync);
 		if (!err) {
 			h_mtx = &h_file->f_dentry->d_inode->i_mutex;
 			mutex_lock(h_mtx);

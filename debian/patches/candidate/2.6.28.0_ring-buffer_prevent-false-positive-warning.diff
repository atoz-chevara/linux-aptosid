Gitweb:     http://git.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=98db8df777438e16ad0f44a0fba05ebbdb73db8d
Commit:     98db8df777438e16ad0f44a0fba05ebbdb73db8d
Parent:     a8ccf1d6f60e3e6ae63122e02378cd4d40dd4aac
Author:     Steven Rostedt <srostedt@redhat.com>
AuthorDate: Tue Dec 23 11:32:25 2008 -0500
Committer:  Ingo Molnar <mingo@elte.hu>
CommitDate: Tue Dec 23 18:45:26 2008 +0100

    ring-buffer: prevent false positive warning
    
    Impact: eliminate false WARN_ON message
    
    If an interrupt goes off after the setting of the local variable
    tail_page and before incrementing the write index of that page,
    the interrupt could push the commit forward to the next page.
    
    Later a check is made to see if interrupts pushed the buffer around
    the entire ring buffer by comparing the next page to the last commited
    page. This can produce a false positive if the interrupt had pushed
    the commit page forward as stated above.
    
    Thanks to Jiaying Zhang for finding this race.
    
    Reported-by: Jiaying Zhang <jiayingz@google.com>
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

 kernel/trace/ring_buffer.c |    7 +++++--
 1 files changed, 5 insertions(+), 2 deletions(-)

--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -892,12 +892,15 @@ static struct ring_buffer_event *
 __rb_reserve_next(struct ring_buffer_per_cpu *cpu_buffer,
 		  unsigned type, unsigned long length, u64 *ts)
 {
-	struct buffer_page *tail_page, *head_page, *reader_page;
+	struct buffer_page *tail_page, *head_page, *reader_page, *commit_page;
 	unsigned long tail, write;
 	struct ring_buffer *buffer = cpu_buffer->buffer;
 	struct ring_buffer_event *event;
 	unsigned long flags;
 
+	commit_page = cpu_buffer->commit_page;
+	/* we just need to protect against interrupts */
+	barrier();
 	tail_page = cpu_buffer->tail_page;
 	write = local_add_return(length, &tail_page->write);
 	tail = write - length;
@@ -921,7 +924,7 @@ __rb_reserve_next(struct ring_buffer_per
 		 * it all the way around the buffer, bail, and warn
 		 * about it.
 		 */
-		if (unlikely(next_page == cpu_buffer->commit_page)) {
+		if (unlikely(next_page == commit_page)) {
 			WARN_ON_ONCE(1);
 			goto out_unlock;
 		}

--- a/arch/x86/include/asm/syscalls.h
+++ b/arch/x86/include/asm/syscalls.h
@@ -37,8 +37,8 @@ asmlinkage int sys_get_thread_area(struc
 unsigned long sys_sigreturn(void);
 
 /* kernel/vm86_32.c */
-asmlinkage long sys_vm86old(struct vm86_struct __user *);
-asmlinkage long sys_vm86(unsigned long, unsigned long);
+int sys_vm86old(struct vm86_struct __user *);
+int sys_vm86(unsigned long, unsigned long);
 
 #else /* CONFIG_X86_32 */
 
--- a/arch/x86/kernel/vm86_32.c
+++ b/arch/x86/kernel/vm86_32.c
@@ -33,7 +33,6 @@
 #include <linux/capability.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
-#include <linux/syscalls.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
 #include <linux/signal.h>
@@ -49,6 +48,7 @@
 #include <asm/io.h>
 #include <asm/tlbflush.h>
 #include <asm/irq.h>
+#include <asm/syscalls.h>
 
 /*
  * Known problems:
@@ -202,32 +202,36 @@ out:
 static int do_vm86_irq_handling(int subfunction, int irqnumber);
 static void do_sys_vm86(struct kernel_vm86_struct *info, struct task_struct *tsk);
 
-SYSCALL_DEFINE1(vm86old, struct vm86_struct __user *, v86)
+int sys_vm86old(struct vm86_struct __user *v86)
 {
 	struct kernel_vm86_struct info; /* declare this _on top_,
 					 * this avoids wasting of stack space.
 					 * This remains on the stack until we
 					 * return to 32 bit user space.
 					 */
-	struct task_struct *tsk = current;
-	int tmp;
+	struct task_struct *tsk;
+	int tmp, ret = -EPERM;
 
+	tsk = current;
 	if (tsk->thread.saved_sp0)
-		return -EPERM;
+		goto out;
 	tmp = copy_vm86_regs_from_user(&info.regs, &v86->regs,
 				       offsetof(struct kernel_vm86_struct, vm86plus) -
 				       sizeof(info.regs));
+	ret = -EFAULT;
 	if (tmp)
-		return -EFAULT;
+		goto out;
 	memset(&info.vm86plus, 0, (int)&info.regs32 - (int)&info.vm86plus);
 	info.regs32 = current_pt_regs();
 	tsk->thread.vm86_info = v86;
 	do_sys_vm86(&info, tsk);
-	return 0;	/* we never return here */
+	ret = 0;	/* we never return here */
+out:
+	return ret;
 }
 
 
-SYSCALL_DEFINE2(vm86, unsigned long, cmd, unsigned long, arg)
+int sys_vm86(unsigned long cmd, unsigned long arg)
 {
 	struct kernel_vm86_struct info; /* declare this _on top_,
 					 * this avoids wasting of stack space.
@@ -235,7 +239,7 @@ SYSCALL_DEFINE2(vm86, unsigned long, cmd
 					 * return to 32 bit user space.
 					 */
 	struct task_struct *tsk;
-	int tmp;
+	int tmp, ret;
 	struct vm86plus_struct __user *v86;
 
 	tsk = current;
@@ -244,7 +248,8 @@ SYSCALL_DEFINE2(vm86, unsigned long, cmd
 	case VM86_FREE_IRQ:
 	case VM86_GET_IRQ_BITS:
 	case VM86_GET_AND_RESET_IRQ:
-		return do_vm86_irq_handling(cmd, (int)arg);
+		ret = do_vm86_irq_handling(cmd, (int)arg);
+		goto out;
 	case VM86_PLUS_INSTALL_CHECK:
 		/*
 		 * NOTE: on old vm86 stuff this will return the error
@@ -252,23 +257,28 @@ SYSCALL_DEFINE2(vm86, unsigned long, cmd
 		 *  interpreted as (invalid) address to vm86_struct.
 		 *  So the installation check works.
 		 */
-		return 0;
+		ret = 0;
+		goto out;
 	}
 
 	/* we come here only for functions VM86_ENTER, VM86_ENTER_NO_BYPASS */
+	ret = -EPERM;
 	if (tsk->thread.saved_sp0)
-		return -EPERM;
+		goto out;
 	v86 = (struct vm86plus_struct __user *)arg;
 	tmp = copy_vm86_regs_from_user(&info.regs, &v86->regs,
 				       offsetof(struct kernel_vm86_struct, regs32) -
 				       sizeof(info.regs));
+	ret = -EFAULT;
 	if (tmp)
-		return -EFAULT;
+		goto out;
 	info.regs32 = current_pt_regs();
 	info.vm86plus.is_vm86pus = 1;
 	tsk->thread.vm86_info = (struct vm86_struct __user *)v86;
 	do_sys_vm86(&info, tsk);
-	return 0;	/* we never return here */
+	ret = 0;	/* we never return here */
+out:
+	return ret;
 }
 
 

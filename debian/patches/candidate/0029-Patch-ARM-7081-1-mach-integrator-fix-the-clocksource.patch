From d43dcf4d8ebd1ec376ed6af8539404c32b47fd41 Mon Sep 17 00:00:00 2001
From: "gregkh@suse.de" <gregkh@suse.de>
Date: Thu, 15 Sep 2011 12:13:07 +0200
Subject: [PATCH 29/91] Patch "ARM: 7081/1: mach-integrator: fix the
 clocksource" has been added to the 3.0-stable tree

This is a note to let you know that I've just added the patch titled

    ARM: 7081/1: mach-integrator: fix the clocksource

to the 3.0-stable tree which can be found at:
    http://www.kernel.org/git/?p=linux/kernel/git/stable/stable-queue.git;a=summary

The filename of the patch is:
     arm-7081-1-mach-integrator-fix-the-clocksource.patch
and it can be found in the queue-3.0 subdirectory.

If you, or anyone else, feels it should not be added to the stable tree,
please let <stable@kernel.org> know about it.

>From bb9ea77846620ed2b37e74c852d72c7a476b248c Mon Sep 17 00:00:00 2001
From: Linus Walleij <linus.walleij@linaro.org>
Date: Tue, 6 Sep 2011 08:08:13 +0100
Subject: ARM: 7081/1: mach-integrator: fix the clocksource

From: Linus Walleij <linus.walleij@linaro.org>

commit bb9ea77846620ed2b37e74c852d72c7a476b248c upstream.

I was intrigued by the fact that the clock stood still on
the Integrator, but it wasn't strange at all, because the
timer was set up all wrong and probably has been for a
while. With this patch the clock starts ticking again:
make the timer periodic (reload), |= on the divisor bit
and load the timer before starting it.

Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 arch/arm/mach-integrator/integrator_ap.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

--- a/arch/arm/mach-integrator/integrator_ap.c
+++ b/arch/arm/mach-integrator/integrator_ap.c
@@ -337,15 +337,15 @@ static unsigned long timer_reload;
 static void integrator_clocksource_init(u32 khz)
 {
 	void __iomem *base = (void __iomem *)TIMER2_VA_BASE;
-	u32 ctrl = TIMER_CTRL_ENABLE;
+	u32 ctrl = TIMER_CTRL_ENABLE | TIMER_CTRL_PERIODIC;
 
 	if (khz >= 1500) {
 		khz /= 16;
-		ctrl = TIMER_CTRL_DIV16;
+		ctrl |= TIMER_CTRL_DIV16;
 	}
 
-	writel(ctrl, base + TIMER_CTRL);
 	writel(0xffff, base + TIMER_LOAD);
+	writel(ctrl, base + TIMER_CTRL);
 
 	clocksource_mmio_init(base + TIMER_VALUE, "timer2",
 		khz * 1000, 200, 16, clocksource_mmio_readl_down);

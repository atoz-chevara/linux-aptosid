re- add accidentially dropped patch e51959faa61278c762389802faf8ba1a40676628
(Fix potential interrupts during alternative patching), lost in 
e587cadd8f47e202a30712e2906a65a0606d5865 (x86: enhance DEBUG_RODATA support -
alternatives), thanks to Frank Mehnert <Frank.Mehnert@Sun.COM> for noticing.

Signed-off-by: Stefan Lippers-Hollmann <s.l-h@gmx.de>

 [PATCH] Fix potential interrupts during alternative patching
 
 Interrupts must be disabled during alternative instruction patching.  On
 systems with high timer IRQ rates, or when running in an emulator, timing
 differences can result in random kernel panics because of running partially
 patched instructions.  This doesn't yet fix NMIs, which requires extricating
 the patch code from the late bug checking and is logically separate (and also
 less likely to cause problems).
 
 Signed-off-by: Zachary Amsden <zach@vmware.com>
 Signed-off-by: Andrew Morton <akpm@osdl.org>
 Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff -Nrup a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
--- a/arch/x86/kernel/alternative.c	2008-08-19 19:03:18.000000000 +0200
+++ b/arch/x86/kernel/alternative.c	2008-08-19 19:11:26.000000000 +0200
@@ -420,6 +420,7 @@ extern struct paravirt_patch_site __star
 
 void __init alternative_instructions(void)
 {
+	unsigned long flags;
 	/* The patching is not fully atomic, so try to avoid local interruptions
 	   that might execute the to be patched code.
 	   Other CPUs are not running. */
@@ -428,6 +429,7 @@ void __init alternative_instructions(voi
 	stop_mce();
 #endif
 
+	local_irq_save(flags);
 	apply_alternatives(__alt_instructions, __alt_instructions_end);
 
 	/* switch to patch-once-at-boottime-only mode and free the
@@ -459,6 +461,7 @@ void __init alternative_instructions(voi
 	}
 #endif
  	apply_paravirt(__parainstructions, __parainstructions_end);
+	local_irq_restore(flags);
 
 	if (smp_alt_once)
 		free_init_pages("SMP alternatives",

This fixes a possible MMIO access while the device is still down
from a suspend cycle. MMIO accesses with the device powered down
may cause crashes on certain devices.

Upstream commit is
33598cf261e393f2b3349cb55509e358014bfd1f

Signed-off-by: Michael Buesch <mb@bu3sch.de>


Index: linux-2.6.25.9/drivers/net/wireless/b43/leds.c
===================================================================
--- linux-2.6.25.9.orig/drivers/net/wireless/b43/leds.c	2008-07-03 01:12:00.000000000 +0200
+++ linux-2.6.25.9/drivers/net/wireless/b43/leds.c	2008-07-03 01:15:01.000000000 +0200
@@ -69,12 +69,15 @@ static void b43_led_brightness_set(struc
 				   enum led_brightness brightness)
 {
 	struct b43_led *led = container_of(led_dev, struct b43_led, led_dev);
 	struct b43_wldev *dev = led->dev;
 	bool radio_enabled;
 
+	if (unlikely(b43_status(dev) < B43_STAT_INITIALIZED))
+		return;
+
 	/* Checking the radio-enabled status here is slightly racy,
 	 * but we want to avoid the locking overhead and we don't care
 	 * whether the LED has the wrong state for a second. */
 	radio_enabled = (dev->phy.radio_on && dev->radio_hw_enable);
 
 	if (brightness == LED_OFF || !radio_enabled)

Gitweb:     http://git.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=7b574b7b0124ed344911f5d581e9bc2d83bbeb19
Commit:     7b574b7b0124ed344911f5d581e9bc2d83bbeb19
Parent:     7d3b56ba37a95f1f370f50258ed3954c304c524b
Author:     Li Zefan <lizf@cn.fujitsu.com>
AuthorDate: Sun Jan 4 12:00:45 2009 -0800
Committer:  Linus Torvalds <torvalds@linux-foundation.org>
CommitDate: Sun Jan 4 13:33:19 2009 -0800

    cgroups: fix a race between cgroup_clone and umount
    
    The race is calling cgroup_clone() while umounting the ns cgroup subsys,
    and thus cgroup_clone() might access invalid cgroup_fs, or kill_sb() is
    called after cgroup_clone() created a new dir in it.
    
    The BUG I triggered is BUG_ON(root->number_of_cgroups != 1);
    
      ------------[ cut here ]------------
      kernel BUG at kernel/cgroup.c:1093!
      invalid opcode: 0000 [#1] SMP
      ...
      Process umount (pid: 5177, ti=e411e000 task=e40c4670 task.ti=e411e000)
      ...
      Call Trace:
       [<c0493df7>] ? deactivate_super+0x3f/0x51
       [<c04a3600>] ? mntput_no_expire+0xb3/0xdd
       [<c04a3ab2>] ? sys_umount+0x265/0x2ac
       [<c04a3b06>] ? sys_oldumount+0xd/0xf
       [<c0403911>] ? sysenter_do_call+0x12/0x31
      ...
      EIP: [<c0456e76>] cgroup_kill_sb+0x23/0xe0 SS:ESP 0068:e411ef2c
      ---[ end trace c766c1be3bf944ac ]---
    
    Cc: Serge E. Hallyn <serue@us.ibm.com>
    Signed-off-by: Li Zefan <lizf@cn.fujitsu.com>
    Cc: Paul Menage <menage@google.com>
    Cc: "Serge E. Hallyn" <serue@us.ibm.com>
    Cc: Balbir Singh <balbir@in.ibm.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

 kernel/cgroup.c |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)

diff --git a/kernel/cgroup.c b/kernel/cgroup.c
index 48348dd..891a84e 100644
--- a/kernel/cgroup.c
+++ b/kernel/cgroup.c
@@ -2945,7 +2945,11 @@ int cgroup_clone(struct task_struct *tsk, struct cgroup_subsys *subsys,
 	parent = task_cgroup(tsk, subsys->subsys_id);
 
 	/* Pin the hierarchy */
-	atomic_inc(&parent->root->sb->s_active);
+	if (!atomic_inc_not_zero(&parent->root->sb->s_active)) {
+		/* We race with the final deactivate_super() */
+		mutex_unlock(&cgroup_mutex);
+		return 0;
+	}
 
 	/* Keep the cgroup alive */
 	get_css_set(cg);

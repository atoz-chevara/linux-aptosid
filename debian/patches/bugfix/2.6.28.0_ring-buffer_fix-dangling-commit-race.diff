Gitweb:     http://git.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=a8ccf1d6f60e3e6ae63122e02378cd4d40dd4aac
Commit:     a8ccf1d6f60e3e6ae63122e02378cd4d40dd4aac
Parent:     30cd324e9787ccc9a5ede59742d5409857550692
Author:     Steven Rostedt <srostedt@redhat.com>
AuthorDate: Tue Dec 23 11:32:24 2008 -0500
Committer:  Ingo Molnar <mingo@elte.hu>
CommitDate: Tue Dec 23 18:45:25 2008 +0100

    ring-buffer: fix dangling commit race
    
    Impact: fix stuck trace-buffers
    
    If an interrupt comes in during the rb_set_commit_to_write and
    pushes the tail page forward just at the right time, the commit
    updates will miss the adding of the interrupt data. This will
    cause the commit pointer to cease from moving forward.
    
    Thanks to Jiaying Zhang for finding this race.
    
    Reported-by: Jiaying Zhang <jiayingz@google.com>
    Signed-off-by: Steven Rostedt <srostedt@redhat.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

 kernel/trace/ring_buffer.c |   12 ++++++++++++
 1 files changed, 12 insertions(+), 0 deletions(-)

diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c
index bb6922a..d03f4f4 100644
--- a/kernel/trace/ring_buffer.c
+++ b/kernel/trace/ring_buffer.c
@@ -838,6 +838,7 @@ rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)
 	 * back to us). This allows us to do a simple loop to
 	 * assign the commit to the tail.
 	 */
+ again:
 	while (cpu_buffer->commit_page != cpu_buffer->tail_page) {
 		cpu_buffer->commit_page->page->commit =
 			cpu_buffer->commit_page->write;
@@ -853,6 +854,17 @@ rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)
 			cpu_buffer->commit_page->write;
 		barrier();
 	}
+
+	/* again, keep gcc from optimizing */
+	barrier();
+
+	/*
+	 * If an interrupt came in just after the first while loop
+	 * and pushed the tail page forward, we will be left with
+	 * a dangling commit that will never go forward.
+	 */
+	if (unlikely(cpu_buffer->commit_page != cpu_buffer->tail_page))
+		goto again;
 }
 
 static void rb_reset_reader_page(struct ring_buffer_per_cpu *cpu_buffer)

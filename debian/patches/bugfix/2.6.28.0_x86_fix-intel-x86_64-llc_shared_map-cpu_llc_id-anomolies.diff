Gitweb:     http://git.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=345077cd98ff5532b2d1158013c3fec7b1ae85ec
Commit:     345077cd98ff5532b2d1158013c3fec7b1ae85ec
Parent:     40fb17152c50a69dc304dd632131c2f41281ce44
Author:     Suresh Siddha <suresh.b.siddha@intel.com>
AuthorDate: Thu Dec 18 18:09:21 2008 -0800
Committer:  Ingo Molnar <mingo@elte.hu>
CommitDate: Fri Dec 19 09:13:50 2008 +0100

    x86: fix intel x86_64 llc_shared_map/cpu_llc_id anomolies
    
    Impact: fix wrong cache sharing detection on platforms supporting > 8 bit apicid's
    
    In the presence of extended topology eumeration leaf 0xb provided
    by cpuid, 32bit extended initial_apicid in cpuinfo_x86 struct will be
    updated by detect_extended_topology(). At this instance, we should also
    reinit the apicid (which could also potentially be extended to 32bit).
    
    With out this there will potentially be duplicate apicid's populated in the
    per cpu's cpuinfo_x86 struct, resulting in wrong cache sharing topology etc
    detected by init_intel_cacheinfo().
    
    Reported-by: Dimitri Sivanich <sivanich@sgi.com>
    Signed-off-by: Suresh Siddha <suresh.b.siddha@intel.com>
    Acked-by: Dimitri Sivanich <sivanich@sgi.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Cc: <stable@kernel.org>

 arch/x86/kernel/cpu/addon_cpuid_features.c |    8 ++++++++
 arch/x86/kernel/cpu/intel.c                |    8 +++++++-
 2 files changed, 15 insertions(+), 1 deletions(-)

diff --git a/arch/x86/kernel/cpu/addon_cpuid_features.c b/arch/x86/kernel/cpu/addon_cpuid_features.c
index ef8f831..2cf2363 100644
--- a/arch/x86/kernel/cpu/addon_cpuid_features.c
+++ b/arch/x86/kernel/cpu/addon_cpuid_features.c
@@ -120,9 +120,17 @@ void __cpuinit detect_extended_topology(struct cpuinfo_x86 *c)
 	c->cpu_core_id = phys_pkg_id(c->initial_apicid, ht_mask_width)
 						 & core_select_mask;
 	c->phys_proc_id = phys_pkg_id(c->initial_apicid, core_plus_mask_width);
+	/*
+	 * Reinit the apicid, now that we have extended initial_apicid.
+	 */
+	c->apicid = phys_pkg_id(c->initial_apicid, 0);
 #else
 	c->cpu_core_id = phys_pkg_id(ht_mask_width) & core_select_mask;
 	c->phys_proc_id = phys_pkg_id(core_plus_mask_width);
+	/*
+	 * Reinit the apicid, now that we have extended initial_apicid.
+	 */
+	c->apicid = phys_pkg_id(0);
 #endif
 	c->x86_max_cores = (core_level_siblings / smp_num_siblings);
 
diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index caec594..b21c37c 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -252,6 +252,13 @@ static void __cpuinit init_intel(struct cpuinfo_x86 *c)
 
 	intel_workarounds(c);
 
+	/*
+	 * Detect the extended topology information if available. This
+	 * will reinitialise the initial_apicid which will be used
+	 * in init_intel_cacheinfo()
+	 */
+	detect_extended_topology(c);
+
 	l2 = init_intel_cacheinfo(c);
 	if (c->cpuid_level > 9) {
 		unsigned eax = cpuid_eax(10);
@@ -323,7 +330,6 @@ static void __cpuinit init_intel(struct cpuinfo_x86 *c)
 
 #endif
 
-	detect_extended_topology(c);
 	if (!cpu_has(c, X86_FEATURE_XTOPOLOGY)) {
 		/*
 		 * let's use the legacy cpuid vector 0x1 and 0x4 for topology
